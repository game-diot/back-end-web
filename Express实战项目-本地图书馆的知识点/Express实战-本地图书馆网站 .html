<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Express实战-本地图书馆网站</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
	margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(50, 48, 44, 1);
}
.highlight-gray {
	color: rgba(115, 114, 110, 1);
	fill: rgba(115, 114, 110, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(205, 60, 58, 1);
	fill: rgba(205, 60, 58, 1);
}
.highlight-default_background {
	color: rgba(50, 48, 44, 1);
}
.highlight-gray_background {
	background: rgba(248, 248, 247, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(248, 243, 252, 1);
}
.highlight-pink_background {
	background: rgba(252, 241, 246, 1);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(115, 114, 110, 1);
	fill: rgba(115, 114, 110, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(205, 60, 58, 1);
	fill: rgba(205, 60, 58, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(248, 248, 247, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(248, 243, 252, 1);
}
.block-color-pink_background {
	background: rgba(252, 241, 246, 1);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: undefined; }
.select-value-color-pink { background-color: rgba(225, 136, 179, 0.27); }
.select-value-color-purple { background-color: rgba(168, 129, 197, 0.27); }
.select-value-color-green { background-color: rgba(123, 183, 129, 0.27); }
.select-value-color-gray { background-color: rgba(84, 72, 49, 0.15); }
.select-value-color-translucentGray { background-color: undefined; }
.select-value-color-orange { background-color: rgba(224, 124, 57, 0.27); }
.select-value-color-brown { background-color: rgba(210, 162, 141, 0.35); }
.select-value-color-red { background-color: rgba(244, 171, 159, 0.4); }
.select-value-color-yellow { background-color: rgba(236, 191, 66, 0.39); }
.select-value-color-blue { background-color: rgba(93, 165, 206, 0.27); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="1f3694d5-ea46-8032-9f80-e0d4438be999" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">🥴</span></div><h1 class="page-title">Express实战-本地图书馆网站</h1><p class="page-description"></p></header><div class="page-body"><p id="1f4694d5-ea46-80dc-90d3-f12b645dad50" class="">// 导入 mongoose 模块<br/>const mongoose = require(&quot;mongoose&quot;);<br/></p><p id="1f4694d5-ea46-8082-aa6c-dfa204f403a3" class="">// 设置默认 mongoose 连接<br/>const mongoDB = &quot;mongodb://127.0.0.1/my_database&quot;;<br/>mongoose.connect(mongoDB);<br/>// 让 mongoose 使用全局 Promise 库<br/>mongoose.Promise = global.Promise;<br/>// 取得默认连接<br/>const db = mongoose.connection;<br/></p><p id="1f4694d5-ea46-80db-ab68-e7e50030c6d7" class="">// 将连接与错误事件绑定（以获得连接错误的提示）<br/>db.on(&quot;error&quot;, console.error.bind(console, &quot;MongoDB 连接错误：&quot;));<br/></p><p id="1f3694d5-ea46-80dd-ae1d-fa4dd57e6738" class="">app.use(logger(&quot;dev&quot;));<br/>app.use(express.json());<br/>app.use(express.urlencoded({ extended: false }));<br/>app.use(cookieParser());<br/>app.use(express.static(path.join(__dirname, &quot;public&quot;)));<br/></p><p id="1f3694d5-ea46-80a1-a098-f0454cf5818a" class=""><strong><span style="border-bottom:0.05em solid">概览：</span></strong></p><ul id="1f3694d5-ea46-8006-92a1-e3892361f497" class="bulleted-list"><li style="list-style-type:disc">本教程教会<ul id="1f3694d5-ea46-802b-a916-c944ade373ec" class="bulleted-list"><li style="list-style-type:circle">使用Express应用生成器创建一个应用骨架</li></ul><ul id="1f3694d5-ea46-803e-a487-f7db4f3f0bc2" class="bulleted-list"><li style="list-style-type:circle">启动和停止Node web服务器</li></ul><ul id="1f3694d5-ea46-8092-b0fc-cbba5f8b6ecb" class="bulleted-list"><li style="list-style-type:circle">使用数据库存放应用数据</li></ul><ul id="1f3694d5-ea46-80fc-aa00-f96d334221fd" class="bulleted-list"><li style="list-style-type:circle">创建路由来处理不同信息的请求，创建模板（“视图”）来渲染HTML数据，在浏览器中显示</li></ul><ul id="1f3694d5-ea46-80ef-b4e9-d6636a5d08dc" class="bulleted-list"><li style="list-style-type:circle">使用表单</li></ul><ul id="1f3694d5-ea46-8071-bcbb-ef70f04bd24f" class="bulleted-list"><li style="list-style-type:circle">部署应用到生产环境</li></ul></li></ul><p id="1f3694d5-ea46-802a-a6cb-cded77975d4d" class="">
</p><p id="1f3694d5-ea46-800c-a20f-cdfbdd0cb073" class=""><mark class="highlight-red"><strong><span style="border-bottom:0.05em solid">本地图书馆（LocalLibrary）</span></strong></mark></p><p id="1f3694d5-ea46-8078-950e-d04e55039942" class="">
</p><p id="1f3694d5-ea46-803e-bdd4-de001f89c3d1" class=""><strong><span style="border-bottom:0.05em solid">【第一步创建站点框架】：</span></strong></p><p id="1f3694d5-ea46-80f1-91ea-c1ffdd4bbf7e" class="">
</p><p id="1f3694d5-ea46-80da-8b92-e14021651fc2" class=""><strong>概览：</strong></p><ul id="1f3694d5-ea46-806d-8999-e75ccc6f5b43" class="bulleted-list"><li style="list-style-type:disc">使用Express应用生成器创建一个可以添加路由、模板/视图、数据库调用的框架网站。使用命令行运行（生成器 + 项目名）即可</li></ul><ul id="1f3694d5-ea46-807b-9f5f-d0d6b0a3eddd" class="bulleted-list"><li style="list-style-type:disc">以下介绍了应用生成器的用法，以及视图/CSS的不同选项，框架网站的组织结构，站点的运行方法等</li></ul><p id="1f3694d5-ea46-80ea-a5a4-e4bf6a48fad9" class=""><strong>使用应用生成器：</strong></p><ul id="1f3694d5-ea46-80c5-b7f0-d19317e00a29" class="bulleted-list"><li style="list-style-type:disc">安装全局生成器<ul id="1f3694d5-ea46-80aa-b579-e104f36b633c" class="bulleted-list"><li style="list-style-type:circle">npm install express-generator -g</li></ul></li></ul><ul id="1f3694d5-ea46-808d-b9e8-ce7ee9f13725" class="bulleted-list"><li style="list-style-type:disc">生成器选项 <ul id="1f3694d5-ea46-8006-abb3-f8bf13dda04f" class="bulleted-list"><li style="list-style-type:circle">express —help或-h</li></ul></li></ul><figure id="1f3694d5-ea46-8041-8c7c-e81cae91418b" class="image"><a href="image.png"><img style="width:561.1875px" src="image.png"/></a></figure><figure id="1f3694d5-ea46-801f-b37b-cac9185588a3" class="image"><a href="image%201.png"><img style="width:561.1875px" src="image%201.png"/></a></figure><ul id="1f3694d5-ea46-80a2-bd55-f3dec5ee423f" class="bulleted-list"><li style="list-style-type:disc">运行express命令，将使用Jade视图引擎和CSS在当前目录创建项目<ul id="1f3694d5-ea46-8090-9bb0-d6b9e75630f8" class="bulleted-list"><li style="list-style-type:circle">express</li></ul></li></ul><ul id="1f3694d5-ea46-80bb-b5a5-cec207d0df22" class="bulleted-list"><li style="list-style-type:disc">也可以使用 —view选择视图（模板）引擎，使用—css选择CSS生成引擎</li></ul><p id="1f3694d5-ea46-8038-8a7e-e985c02a3bd5" class=""><strong>如何选择合适的视图引擎：本项目使用Pug模板</strong></p><ul id="1f3694d5-ea46-80f8-87b2-dd483f11d37b" class="bulleted-list"><li style="list-style-type:disc">选择模板引擎考虑以下因素<ul id="1f3694d5-ea46-8068-9e7a-ff7e9185759d" class="bulleted-list"><li style="list-style-type:circle">进入生产状态的时间——如果你的团队已经有某个模板语言的经验，那么用它可能更快进入生产状态。否则你应该考虑所选模板引擎的学习曲线。</li></ul><ul id="1f3694d5-ea46-80b7-a321-c199cc3709f8" class="bulleted-list"><li style="list-style-type:circle">流行度和活跃度——要评估所选引擎的流行程度，以及它是否拥有活跃的社区。在网站的生命周期中遇到问题时，是否能够获得相关支持非常重要。</li></ul><ul id="1f3694d5-ea46-80b3-b9b3-d152ef4e5fba" class="bulleted-list"><li style="list-style-type:circle">风格——某些模板引擎使用特定标记，来标识插入“普通”HTML 中的内容，而另一些模板引擎使用不同的语法（例如使用缩进和块名称）构造 HTML。</li></ul><ul id="1f3694d5-ea46-80dd-a385-c28c14d87da3" class="bulleted-list"><li style="list-style-type:circle">性能/渲染时间。</li></ul><ul id="1f3694d5-ea46-8033-853e-efc92bc6457a" class="bulleted-list"><li style="list-style-type:circle">功能——你应该考虑所选引擎是否具有以下功能：<ul id="1f3694d5-ea46-80ff-a287-e24f450b7487" class="bulleted-list"><li style="list-style-type:square">布局继承：可以定义基本模板，然后“继承”它的一部分，使不同页面可以有不同的呈现。这通常比包含大量所需组件，或每次从头开始构建模板更好。</li></ul><ul id="1f3694d5-ea46-80f8-aff0-db489c24cc0a" class="bulleted-list"><li style="list-style-type:square">“包含”支持：可以通过包含其他模板来构建新模板。</li></ul><ul id="1f3694d5-ea46-807d-bda9-f903f3eeede3" class="bulleted-list"><li style="list-style-type:square">简明的变量和循环控制语法。</li></ul><ul id="1f3694d5-ea46-80d1-96b9-d111027de728" class="bulleted-list"><li style="list-style-type:square">能够在模板级别过滤变量值（例如，将变量设置为大写，或格式化日期值）。</li></ul><ul id="1f3694d5-ea46-807b-8fcc-c432eea4369b" class="bulleted-list"><li style="list-style-type:square">能够生成 HTML 以外的输出格式（例如 JSON 或 XML）。</li></ul><ul id="1f3694d5-ea46-8029-b69a-da5dc72281c2" class="bulleted-list"><li style="list-style-type:square">支持异步操作和流。</li></ul><ul id="1f3694d5-ea46-809c-b902-cd3752a180ed" class="bulleted-list"><li style="list-style-type:square">可以在同时在客户端和服务器上使用。如果一款模板引擎可以在客户端使用，那么就使在客户端托管数据并完成所有（或大多数）渲染成为可能。</li></ul></li></ul></li></ul><p id="1f3694d5-ea46-80f2-989c-deef3c1feb9c" class=""><strong>如何选择合适的CSS引擎：本项目使用默认CSS</strong></p><ul id="1f3694d5-ea46-8055-8167-d7e4c20ec097" class="bulleted-list"><li style="list-style-type:disc">常见的CSS引擎有LESS、SASS、Compass、Stylus</li></ul><ul id="1f3694d5-ea46-80ed-b0de-c03975a59043" class="bulleted-list"><li style="list-style-type:disc">与模板引擎一样，推荐使用样式表引擎，这样可以最大化团队生产力</li></ul><p id="1f3694d5-ea46-8046-8989-d6775d249b63" class=""><strong>如何选择合适的数据库：本项目暂不使用数据库</strong></p><ul id="1f3694d5-ea46-80b9-9f91-f7108a4c0064" class="bulleted-list"><li style="list-style-type:disc">生成器生成的代码不使用、也不包含任何数据库，</li></ul><ul id="1f3694d5-ea46-80bc-a452-ecff14761855" class="bulleted-list"><li style="list-style-type:disc">Express应用可以使用Node支持的所有数据库</li></ul><p id="1f3694d5-ea46-80ab-a287-c6ba47fb7e86" class="">
</p><p id="1f3694d5-ea46-80d5-8c21-cc988d357129" class=""><strong>创建项目：</strong></p><ul id="1f3694d5-ea46-80fe-af84-f06ea1a295db" class="bulleted-list"><li style="list-style-type:disc">本地图书馆应用创建一个express-locallibrary-tutorial的项目，使用Pug模板，不使用CSS引擎</li></ul><ul id="1f3694d5-ea46-8087-b1cf-f5d636c2ba09" class="bulleted-list"><li style="list-style-type:disc">首先，进入目录，在命令行中运行Express应用生成器，创建项目文件</li></ul><p id="1f3694d5-ea46-806f-8be6-de78a8f187ad" class="">
</p><p id="1f3694d5-ea46-8033-8450-e7194495df53" class=""><strong>运行框架网站：</strong></p><ul id="1f3694d5-ea46-8014-abe0-dd6f52caf90b" class="bulleted-list"><li style="list-style-type:disc">现在有了完整的项目框架，展示一下工作原理</li></ul><ul id="1f3694d5-ea46-80fe-9f5d-cc073d2dfdd8" class="bulleted-list"><li style="list-style-type:disc">首先，安装依赖项（install命令将获取项目的package.json文件中列出的所有依赖项包）<ul id="1f3694d5-ea46-8058-adde-e4de68f41f6d" class="bulleted-list"><li style="list-style-type:circle">npm install</li></ul></li></ul><ul id="1f3694d5-ea46-805e-ba59-df34b0ceb56a" class="bulleted-list"><li style="list-style-type:disc">运行该应用<ul id="1f3694d5-ea46-8091-8248-eb042f1a8ac2" class="bulleted-list"><li style="list-style-type:circle">先赋予DEBUG变量<ul id="1f3694d5-ea46-80c3-91b8-eb1444179f20" class="bulleted-list"><li style="list-style-type:square">$env:DEBUG = &quot;express:*”</li></ul></li></ul><ul id="1f3694d5-ea46-80a5-869e-dcb3f0fd7f02" class="bulleted-list"><li style="list-style-type:circle">在启动Express应用<ul id="1f3694d5-ea46-80f5-b92c-d89951a80422" class="bulleted-list"><li style="list-style-type:square">npm start</li></ul></li></ul></li></ul><ul id="1f3694d5-ea46-80e1-9117-e4c1546e4539" class="bulleted-list"><li style="list-style-type:disc">浏览器中导航至URL，访问该应用<ul id="1f3694d5-ea46-803e-ab11-e06a8f877210" class="bulleted-list"><li style="list-style-type:circle"> <a href="http://localhost:3000/">http://localhost:3000/</a> </li></ul></li></ul><ul id="1f3694d5-ea46-8076-8302-e2d9ee6a31ff" class="bulleted-list"><li style="list-style-type:disc">该Express应用托关于localhost：3000</li></ul><p id="1f3694d5-ea46-80e0-afc5-e64258d89703" class="">
</p><p id="1f3694d5-ea46-8098-b5d7-c2417b53d3c0" class=""><strong>文件改动时重启服务器：</strong></p><ul id="1f3694d5-ea46-80b1-b002-e9c4d5ff83a0" class="bulleted-list"><li style="list-style-type:disc">只有重启服务器才能看到Express网站所作的改动，每次改动后需要手动启动/停止服务器，很麻烦</li></ul><ul id="1f3694d5-ea46-80ff-a1b2-c35677321d22" class="bulleted-list"><li style="list-style-type:disc">使用自动化工具-nodemon，全局安装<ul id="1f3694d5-ea46-80f4-bbc6-eacdb85ef587" class="bulleted-list"><li style="list-style-type:circle">npm install -g nodemon</li></ul></li></ul><ul id="1f3694d5-ea46-8005-9ade-ca692cb32f83" class="bulleted-list"><li style="list-style-type:disc">也可以将其作为开发依赖安装在本地，于是使用这个项目的开发人员只要安装这个应用就能自动获得，通过以下命令将其安装在框架项目的根目录<ul id="1f3694d5-ea46-800c-8646-db39c5e72241" class="bulleted-list"><li style="list-style-type:circle">npm install —save-dev nodemon</li></ul></li></ul><ul id="1f3694d5-ea46-8046-bd9c-c4b708dbf02b" class="bulleted-list"><li style="list-style-type:disc">项目的package.json文件自动添加新属性<ul id="1f3694d5-ea46-8029-97eb-c58f0943a2b1" class="bulleted-list"><li style="list-style-type:circle">devDependencies</li></ul></li></ul><ul id="1f3694d5-ea46-8081-a9a7-d491de42ab02" class="bulleted-list"><li style="list-style-type:disc">如果没有全局安装该工具，就无法在命令行启动，到那时可以在NPM脚本中调用它，因为NPM脚本掌握所有已安装的包信息，<ul id="1f3694d5-ea46-80c0-b835-e31abc7a848b" class="bulleted-list"><li style="list-style-type:circle">在package.json中的scripts部分，在start一行末尾添加都好，并在新的一行中添加devstart。<ul id="1f3694d5-ea46-80bc-bd49-c40dff354c95" class="bulleted-list"><li style="list-style-type:square">&quot;scripts&quot;: {<br/>&quot;start&quot;: &quot;node ./bin/www&quot;,<br/>&quot;devstart&quot;: &quot;nodemon ./bin/www&quot;<br/>},<br/></li></ul></li></ul></li></ul><ul id="1f3694d5-ea46-809c-8f26-e23751452b91" class="bulleted-list"><li style="list-style-type:disc">现在就可以使用新建的devstart命令启动服务器<ul id="1f3694d5-ea46-8061-9747-f619d67c6730" class="bulleted-list"><li style="list-style-type:circle">npm run devstart</li></ul></li></ul><ul id="1f3694d5-ea46-8074-8f90-fed583b241ae" class="bulleted-list"><li style="list-style-type:disc">现在编辑项目中的任何文件，服务器都会自动重启（或者可以随时使用rs命令来重启），查看更新后的页面需要点击浏览器的刷新按钮</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f3694d5-ea46-80c4-ae91-f2424c7c1ccd"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f3694d5-ea46-8074-bc95-ca5c5ffba532" class=""><strong>这里必须使用 npm run &lt;script name&gt;命令来运行，而不是npm start。</strong></p><p id="1f3694d5-ea46-80f4-80bb-f85e7b8b6478" class="">因为start本质是映射到脚本的一条NPM命令，可以在start脚本中替换他，但我们只想在开发期间使用nodemon，因此有必要创建一条新的脚本命令</p></div></figure><p id="1f3694d5-ea46-807b-b2b5-d19295840959" class="">
</p><p id="1f3694d5-ea46-80e0-a34f-fbe6152c1ff1" class=""><strong>生成的项目：查看项目内容</strong></p><p id="1f3694d5-ea46-80dc-8423-e98e14c443e8" class="">【目录结构】：</p><ul id="1f3694d5-ea46-80f2-88d9-f1a13d0ff047" class="bulleted-list"><li style="list-style-type:disc">安装好依赖项的生成项目具有如下文件结构（不带“/”前缀的是文件）<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f3694d5-ea46-80c7-abe5-d72831d18abd" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">/express-locallibrary-tutorial
    app.js
    /bin
        www
    package.json
    /node_modules
        [约 4,500 个子文件夹和文件]
    /public
        /images
        /javascripts
        /stylesheets
            style.css
    /routes
        index.js
        users.js
    /views
        error.pug
        index.pug
        layout.pug</code></pre><ul id="1f3694d5-ea46-805d-8751-c1bb6855badb" class="bulleted-list"><li style="list-style-type:circle">package.json文件定义依赖项和其他信息，以及一个调用应用入口（/bin/www，一个JS文件）的启动脚本，脚本中设置了一些应用的错误处理，加载app.js来完成其余工作。/routes目录中用不同模块保存应用路由。/views目录保存模板</li></ul></li></ul><p id="1f3694d5-ea46-80a1-87c6-d8ebe121b5d8" class="">【package.json】：</p><ul id="1f3694d5-ea46-8077-b3a5-ec56f1d7dfe5" class="bulleted-list"><li style="list-style-type:disc">package.json文件中定义了应用依赖和其他信息<ul id="1f3694d5-ea46-80cb-8c9f-ef342c6b55bb" class="bulleted-list"><li style="list-style-type:circle">{<br/>&quot;name&quot;: &quot;express-locallibrary-tutorial&quot;,<br/>&quot;version&quot;: &quot;0.0.0&quot;,<br/>&quot;private&quot;: true,<br/><br/><strong><span style="border-bottom:0.05em solid">&quot;scripts&quot;: {<br/>&quot;start&quot;: &quot;node ./bin/www&quot;<br/>&quot;devstart&quot;: &quot;nodemon ./bin/www&quot;<br/>},<br/></span></strong><br/>&quot;dependencies&quot;: {<br/>&quot;cookie-parser&quot;: &quot;~1.4.3&quot;,<br/>&quot;debug&quot;: &quot;~2.6.9&quot;,<br/>&quot;express&quot;: &quot;~4.16.0&quot;,<br/>&quot;http-errors&quot;: &quot;~1.6.2&quot;,<br/>&quot;morgan&quot;: &quot;~1.9.0&quot;,<br/>&quot;pug&quot;: &quot;2.0.0-beta11&quot;<br/>},<br/>&quot;devDependencies&quot;: {<br/>&quot;nodemon&quot;: &quot;^1.18.9&quot;<br/>}<br/>}<br/></li></ul><ul id="1f3694d5-ea46-8029-84e4-e50d244a9a5f" class="bulleted-list"><li style="list-style-type:circle">这些包括express包，选用的视图引擎包（pug）还有以下包<ul id="1f3694d5-ea46-806e-99e1-c90b98620dfb" class="bulleted-list"><li style="list-style-type:square">cookie-parser：解析cookie头来填充req.cookies（提供访问cookie信息的便捷方法）</li></ul><ul id="1f3694d5-ea46-8075-99cc-cc2218131b21" class="bulleted-list"><li style="list-style-type:square">debug：小型node调试程序，仿照node核心的调试技术建立</li></ul><ul id="1f3694d5-ea46-802a-9cf8-ebd3fcddcdc9" class="bulleted-list"><li style="list-style-type:square">http-errors：处理错误中间件</li></ul><ul id="1f3694d5-ea46-806c-890f-d1d0bb8adcb9" class="bulleted-list"><li style="list-style-type:square">morgan：node专用HTTP请求记录器中间件</li></ul></li></ul><ul id="1f3694d5-ea46-805c-ad76-c09310f9ebc3" class="bulleted-list"><li style="list-style-type:circle">“scripts”部分，定义了一个“start”脚本，当运行npm start时会调用它来启动服务器。在脚本定义中看到start实际运行了node ./bin/www。还有一个devstart脚本，通过运行npm run dev start来运行nodemon ./bin/www</li></ul></li></ul><p id="1f3694d5-ea46-8032-95a7-f898fb838cab" class="">【www文件】：</p><ul id="1f3694d5-ea46-80a1-9473-deb1ded2caea" class="bulleted-list"><li style="list-style-type:disc">/bin/www文件为应用入口，做的事是require（）真实的应用入口（即项目根目录中的app.js），app.js会设置并返回express（）应用对象<ul id="1f3694d5-ea46-806c-a454-f29f1bd3582f" class="bulleted-list"><li style="list-style-type:circle">var app = require（“../app.js”）<figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f3694d5-ea46-80cf-91e1-e682144036ab"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f3694d5-ea46-8056-bc1b-d3f5013c6ab9" class="">require（）使用该全局的node函数，可以i将模块导入当前文件，这里使用相对路径指定app.js模块，可以省略文件扩展名</p></div></figure></li></ul></li></ul><ul id="1f3694d5-ea46-804a-8e87-da539f7b7cd5" class="bulleted-list"><li style="list-style-type:disc">文件的区域部分为app设置端口（环境变量中预定义值或默认值3000），再创建一个HTTP服务器，然后开始监听请求，报告服务器错误和连接信息</li></ul><p id="1f3694d5-ea46-806f-ad77-c7cdf65f5997" class="">【app.js】：</p><ul id="1f3694d5-ea46-8014-9b7b-fc90c86a03f8" class="bulleted-list"><li style="list-style-type:disc">此文件创建一个express应用对象，通过各种设置选项和中间件来设置这个应用，然后从该模块中导出<ul id="1f3694d5-ea46-80fd-90d5-d43c6c49d737" class="bulleted-list"><li style="list-style-type:circle">var app = express（）</li></ul><ul id="1f3694d5-ea46-800a-abbe-cf8b709f9aaf" class="bulleted-list"><li style="list-style-type:circle">module.exports = app<ul id="1f3694d5-ea46-80a3-9089-f3714e20448d" class="bulleted-list"><li style="list-style-type:square">www入口文件中的require（）的app就是这里导出的</li></ul></li></ul></li></ul><ul id="1f3694d5-ea46-806e-aac9-ce9b71e51c24" class="bulleted-list"><li style="list-style-type:disc"><strong>了解一下app.js文件。</strong></li></ul><ul id="1f3694d5-ea46-80e0-a416-d5184ad8adf7" class="bulleted-list"><li style="list-style-type:disc">首先使用require（）导入了一些使用node库，其中包括之前用NPM下载的express、http-errors、morgan、cookie-parser，还有一个path库，用于解析文件和目录的核心node库<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f3694d5-ea46-80be-aa9b-d22d79023e92" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">var express = require(&quot;express&quot;);
var createError = require(&quot;http-errors&quot;);
var logger = require(&quot;morgan&quot;);
var cookieParser = require(&quot;cookie-parser&quot;);
var path = require(&quot;path&quot;);</code></pre></li></ul><ul id="1f3694d5-ea46-809e-a6fb-ed79c0ed95e7" class="bulleted-list"><li style="list-style-type:disc">然后require（）的是用户路由中的模块，这些模块/文件用于处理特定的路由（URL路径）。可以通过添加新文件来扩展框架应用，比如添加图书相关的路由来列出所有书目<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f3694d5-ea46-8039-ac82-f2538a1be806" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">var indexRouter = require(&quot;./routes/index&quot;);
var usersRouter = require(&quot;./routes/users&quot;);</code></pre></li></ul><ul id="1f3694d5-ea46-8027-bf76-f0f9611c0597" class="bulleted-list"><li style="list-style-type:disc">之后用导入的express模块来创建app对象，然后使用它来设置视图（模板）引擎，设置引擎分为两步<ul id="1f3694d5-ea46-80ab-a7d0-ee6d2ad92949" class="bulleted-list"><li style="list-style-type:circle">首先按设置views来指定模板的存储文件夹（此处设为子文件夹/views）</li></ul><ul id="1f3694d5-ea46-80c8-b143-fadb9c3caaa5" class="bulleted-list"><li style="list-style-type:circle">然后设置view engine来指定模板库（本例设为pug）<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f3694d5-ea46-8043-b1c7-ea130dcc9e29" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">var app = express();

// view engine setup
// 视图引擎设定
app.set(&quot;views&quot;, path.join(__dirname, &quot;views&quot;));
app.set(&quot;view engine&quot;, &quot;pug&quot;);</code></pre></li></ul></li></ul><ul id="1f3694d5-ea46-807d-aa16-e0a7dd4e569b" class="bulleted-list"><li style="list-style-type:disc">app.use（）调用将中间件库添加进请求处理链，处理之前导入的第三方库之外，我们还是用express.static中间件将项目 /public目录下所有静态文件托管至根目录。<p id="1f3694d5-ea46-8088-be5d-da10b733bcf2" class="">app.use(logger(&quot;dev&quot;));<br/>app.use(express.json());<br/>app.use(express.urlencoded({ extended: false }));<br/>app.use(cookieParser());<br/>app.use(express.static(path.join(__dirname, &quot;public&quot;)));<br/></p></li></ul><ul id="1f3694d5-ea46-80f6-bf41-ec3686e607fc" class="bulleted-list"><li style="list-style-type:disc">中间件都设置完毕，现在把之前导入的路由处理器添加到请求处理链中，从而为网站的不同部分定义具体的路由<p id="1f3694d5-ea46-807e-8172-d688833539ed" class="">app.use(&quot;/&quot;, indexRouter);<br/>app.use(&quot;/users&quot;, usersRouter);<br/></p></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f3694d5-ea46-80f3-90b1-f0255cccfdf6"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f3694d5-ea46-8004-9fa7-d5cefb66b5df" class="">这些路径（‘/’和‘/user’）将作为导入路由的前缀，如果导入的模块user在/profile定义了路由，则可以在/users/profile访问该路由</p></div></figure><ul id="1f3694d5-ea46-806a-a7b5-c5bbf2ddd457" class="bulleted-list"><li style="list-style-type:disc">最后一个中间件为错误和HTTP404响应添加处理方法<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f3694d5-ea46-8076-ba90-fb4089988ad8" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">// catch 404 and forward to error handler
// 捕获 404 并抛给错误处理器
app.use(function (req, res, next) {
  next(createError(404));
});

// error handler
// 错误处理器
app.use(function (err, req, res, next) {
  // set locals, only providing error in development
  // 设置 locals，只在开发环境提供错误信息
  res.locals.message = err.message;
  res.locals.error = req.app.get(&quot;env&quot;) === &quot;development&quot; ? err : {};

  // render the error page
  // 渲染出错页面
  res.status(err.status || 500);
  res.render(&quot;error&quot;);
});</code></pre></li></ul><p id="1f3694d5-ea46-8025-baaa-f8f0d1e9dae0" class="">Express应用程序app现在已完成配置，最后一步将其添加到export模块（使其可以通过 /bin/www导入）<div class="indented"><p id="1f3694d5-ea46-8026-9d5c-f456107980ef" class="">module.exports = app;</p></div></p><p id="1f3694d5-ea46-8057-b147-fd3f0f254051" class="">【路由】：</p><ul id="1f3694d5-ea46-8049-aaec-da695a9dce97" class="bulleted-list"><li style="list-style-type:disc">路由文档 /routes/users.js如下所示（路由文件都是用类似结构，所以index.js跳过）。<ul id="1f3694d5-ea46-80d1-95ab-d0059cedcafb" class="bulleted-list"><li style="list-style-type:circle">首先加载express模块，并获取express.Router对象（命名为router）。然后为router指定路由，最后导出router（就可以导入app.js）<p id="1f3694d5-ea46-80c9-ab91-cd4c890adcb5" class="">var express = require(&quot;express&quot;);<br/>var router = express.Router();<br/></p><p id="1f3694d5-ea46-8018-8358-fb0b86eb64cc" class="">/* GET users listing. */<br/>router.get(&quot;/&quot;, function (req, res, next) {<br/>res.send(&quot;respond with a resource&quot;);<br/>});<br/></p><p id="1f3694d5-ea46-802d-920d-e7200525b0f6" class="">module.exports = router;<div class="indented"><ul id="1f3694d5-ea46-8052-8d32-f8ea8428f391" class="bulleted-list"><li style="list-style-type:disc">该路由定义了一个回调，在检测正确描述的HTTP GET请求时调用该回调，正确描述即导入该模块时指定的路由‘/users’加载模块‘/’中定义的任何内容。就是在收到/users/URL请求时使用该路由</li></ul><ul id="1f3694d5-ea46-805f-916c-ea26968cab18" class="bulleted-list"><li style="list-style-type:disc">回调函数中有第三个参数next，因此他为中间件函数，而不是简单的路由回调，在‘/’路径中添加多个路由处理器时才会涉及到next</li></ul></div></p></li></ul></li></ul><p id="1f3694d5-ea46-8001-9604-ce396d2bcacd" class="">【视图（模板）】：</p><ul id="1f3694d5-ea46-8056-bb5c-d14a38e721e3" class="bulleted-list"><li style="list-style-type:disc">视图（模板）保存在/views目录中（app.js指定），使用.pug作为拓展名</li></ul><ul id="1f3694d5-ea46-80d5-852e-dffd373400b8" class="bulleted-list"><li style="list-style-type:disc">Response.render（）Fangfa用某对象的某个变量值来渲染特定模板，然后将其作为响应发送<ul id="1f3694d5-ea46-8040-a3f8-fd4f15442397" class="bulleted-list"><li style="list-style-type:circle">在/routes/index.js可以看到，该路由使用index模板和一个模板变量title来渲染响应<ul id="1f3694d5-ea46-801d-ab5b-f702ee0e57f3" class="bulleted-list"><li style="list-style-type:square">/* GET home page. */<br/>router.get(&quot;/&quot;, function (req, res) {<br/>res.render(&quot;index&quot;, { title: &quot;Express&quot; });<br/>});<br/></li></ul></li></ul><ul id="1f3694d5-ea46-8037-a320-ced34b6b3019" class="bulleted-list"><li style="list-style-type:circle">以下是上文代码中涉及到的模板index.pug。title变量将以express作为值插入模板指定位置<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f3694d5-ea46-807b-9135-d7253fd9423d" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">extends layout

block content
  h1= title
  p Welcome to #{title}</code></pre></li></ul></li></ul><p id="1f4694d5-ea46-8010-87e2-cd5edd713dcb" class="">
</p><p id="1f4694d5-ea46-805a-8505-d557fb34e1a0" class=""><strong><span style="border-bottom:0.05em solid">【第二步使用数据库（Mongoose）】：</span></strong></p><ul id="1f4694d5-ea46-8027-bd7b-daea8fb6c5f8" class="bulleted-list"><li style="list-style-type:disc">介绍数据库以及Node/Express应用的数据库继承，演示Mongoose为LocalLibrary提供数据库访问的方式，</li></ul><ul id="1f4694d5-ea46-8048-8b9c-f9fc30c01685" class="bulleted-list"><li style="list-style-type:disc">讲解对项目是（Schema）和模型（Model）的声明方式、主要域的类型、基础验证机制。</li></ul><ul id="1f4694d5-ea46-804b-b1ea-c3395c3a9e7d" class="bulleted-list"><li style="list-style-type:disc">访问模型数据的方法</li></ul><p id="1f4694d5-ea46-80b5-bc33-e8a17b2c0a0b" class="">
</p><p id="1f4694d5-ea46-80cc-8042-c554e96f6333" class=""><strong>概览：</strong></p><ul id="1f4694d5-ea46-80f0-9c83-ea880b8398aa" class="bulleted-list"><li style="list-style-type:disc">员工使用LocalLibrary网站来保存藏书和借阅者的信息，用户会浏览和查找所需藏书，找到后预约或借阅。</li></ul><ul id="1f4694d5-ea46-8047-aedd-c674bd72997d" class="bulleted-list"><li style="list-style-type:disc">Express应用支持多款数据库，执行新建（Create）、读取（Read）、更新（Update）、删除（Delete）操作（CRUD）操作有很多方式</li></ul><p id="1f4694d5-ea46-8067-b62a-e88df3f41345" class="">
</p><p id="1f4694d5-ea46-8049-9d90-e88908dc23e1" class=""><strong>使用什么数据库：</strong></p><p id="1f4694d5-ea46-809a-a0a5-c51697edee14" class="">Express应用可以使用Node支持的所有数据库，包括PostgreSQL、MySQL、Redis、SQLite和MongoDB。</p><ul id="1f4694d5-ea46-8044-acd1-d29e8132977b" class="bulleted-list"><li style="list-style-type:disc">选取数据看应考虑以下因素<ul id="1f4694d5-ea46-8059-a1ad-e5b4d1e798c1" class="bulleted-list"><li style="list-style-type:circle">进入生产状态用时/学习曲线、性能、复制/备份的易用度、成本、社区支持等等。</li></ul></li></ul><p id="1f4694d5-ea46-80b5-ab4f-c83f8a8eee55" class="">
</p><p id="1f4694d5-ea46-80b7-b57f-de464a9641ee" class=""><strong>与数据库交互的最佳方式是什么：</strong></p><ul id="1f4694d5-ea46-80f4-8eed-f13f7fd2f0dd" class="bulleted-list"><li style="list-style-type:disc">与数据库交互有两种方法：<ul id="1f4694d5-ea46-8075-bd5c-e95876933558" class="bulleted-list"><li style="list-style-type:circle">使用数据库的原生查询语言（SQL）</li></ul><ul id="1f4694d5-ea46-80ab-8155-d6062114dc46" class="bulleted-list"><li style="list-style-type:circle">使用对象数据模型（Object Data Model）或对象关系模型（Object Relational Model）。ODM/ORM能将网站的数据表示为JS对象，然后将他们映射到底层数据库。一些ORM只适用于某些特定数据库，还有一些是普遍适用的</li></ul></li></ul><ul id="1f4694d5-ea46-8018-8d97-d3bb848b814a" class="bulleted-list"><li style="list-style-type:disc">使用SQL或其他收到支持的查询语言能实现最佳性能。ODM通常慢一些，因为在对象和数据库格式之间存在一层用于映射的翻译代码，使用它不一定会选用最高性能的数据库查询（尤其是普遍适用的ODM，他必须在各类数据库功能方面做出更大的折损）</li></ul><ul id="1f4694d5-ea46-80cd-9307-daa25f054bb8" class="bulleted-list"><li style="list-style-type:disc">使用ORM的好处是，程序员可以继续用JS对象的思维而不用转向数据库语义的思维。在（同一个或不同网站）使用不同数据库时更为明显。使用ORM可以更方便的对数据进行验证和检查</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f4694d5-ea46-8089-a329-e4ebab6e4c3e"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f4694d5-ea46-80e4-a091-e5ca0bfaa4d4" class="">使用ODM/ORM通常可以降低开发和维护成本。除非非常熟悉本地查询语言，或者项目对性能要求很高，否则使用ODM</p></div></figure><p id="1f4694d5-ea46-806b-88e7-e98a9e2486fc" class="">
</p><p id="1f4694d5-ea46-801e-b530-fbe1d61b3b52" class=""><strong>选择哪种ORM/ODM：</strong></p><ul id="1f4694d5-ea46-80b1-bca4-f128800ffadc" class="bulleted-list"><li style="list-style-type:disc">NPM站点上有许多ORM/ODM解决方案。下面是流行的解决方案<ul id="1f4694d5-ea46-807a-9ce7-ce5d62f43cb7" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.npmjs.com/package/mongoose">Mongoose</a>：一款为异步工作环境设计的 <a href="https://www.mongodb.org/">MongoDB</a> 对象建模工具。</li></ul><ul id="1f4694d5-ea46-8024-885b-dc7624c02220" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.npmjs.com/package/waterline">Waterline</a>：从基于 Express 的 <a href="http://sailsjs.com/">Sails</a> 框架中提取的 ORM。它提供了一套统一的 API 来访问众多不同的数据库，其中包括 Redis，mySQL，LDAP，MongoDB 和 Postgres。</li></ul><ul id="1f4694d5-ea46-80c2-b731-c092d1da87e9" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.npmjs.com/package/bookshelf">Bookshelf</a>：同时提供基于 promise 和传统回调两套接口，支持事务处理、渴求式/嵌套渴求式关系加载、多态关联，以及对一对一，一对多和多对多关系。支持 PostgreSQL、MySQL 和 SQLite3。</li></ul><ul id="1f4694d5-ea46-80b6-8175-c9065c672149" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.npmjs.com/package/objection">Objection</a>：以尽可能简单的方式使用 SQL 和底层数据库引擎的全部功能（支持 SQLite3、Postgres 和 MySQL）。</li></ul><ul id="1f4694d5-ea46-80e4-882a-c5f6f4ce4b56" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.npmjs.com/package/sequelize">Sequelize</a>：基于 promise 的 Node.js 版 ORM，它支持 PostgreSQL、MySQL、MariaDB、SQLite 和 MSSQL，并提供可靠的事务支持、关系、复本读取等功能。</li></ul><ul id="1f4694d5-ea46-80aa-b553-e018f79c3524" class="bulleted-list"><li style="list-style-type:circle"><a href="https://node-orm.readthedocs.io/en/latest/">Node ORM2</a>：一款 Node.js 对象关系管理系统。支持 MySQL、SQLite 以及 Progress，可以帮助你用面向对象的方法操作数据库。</li></ul><ul id="1f4694d5-ea46-80a9-a9c2-c85b45fa872b" class="bulleted-list"><li style="list-style-type:circle"><a href="http://1602.github.io/jugglingdb/">JugglingDB</a>：一款 Node.js 版跨数据库的 ORM。它为多数流行数据库提供了统一接口，当前支持 MySQL、SQLite3、Postgres、MongoDB、Redis 和 js-memory-storage（自写引擎，仅供测试用）。</li></ul></li></ul><ul id="1f4694d5-ea46-802a-958d-c536d6688edd" class="bulleted-list"><li style="list-style-type:disc">选择解决方案考虑功能和社区活跃度。</li></ul><p id="1f4694d5-ea46-80db-b236-ca8e7ede70e2" class="">
</p><p id="1f4694d5-ea46-80d0-891a-c4ab97589936" class=""><strong>在LocalLibrary中使用Mongoose和MongoDB：</strong></p><p id="1f4694d5-ea46-80af-a7a1-e14a54a08e5f" class="">
</p><p id="1f4694d5-ea46-800b-acd7-d4744d48bc03" class=""><strong>设计LocalLibrary模型：</strong></p><ul id="1f4694d5-ea46-80e2-a028-f07f3f41f915" class="bulleted-list"><li style="list-style-type:disc">编写模型之前，要思考：本网站需要存储什么数据？不同对象之间的关系是怎样的？<ul id="1f4694d5-ea46-806d-beba-ead96c296ca9" class="bulleted-list"><li style="list-style-type:circle">图书馆需要存储藏书信息（书目、摘要、作者、种类、ISBN），藏书副本信息（全站唯一ID、借出状态等）。还可能需要存储作者姓名之外的更多信息，以及多个作者的信息。还希望数据库内容能够根据书目、作者署名、种类、编目进行排序</li></ul><ul id="1f4694d5-ea46-8070-ae22-cc4d6441dc31" class="bulleted-list"><li style="list-style-type:circle">为每个对象（一组相关信息）设计独立的模型。本实例的关键对象为书籍、书籍副本和作者</li></ul><ul id="1f4694d5-ea46-8073-bce7-d61879c192fa" class="bulleted-list"><li style="list-style-type:circle">希望使用模型而不是站点代码来表示选项表（比如下拉列表），在选项无法预知或可能更改时更推荐模型方式。藏书类型（科幻、诗歌等）这种情况</li></ul><ul id="1f4694d5-ea46-808e-a6ee-e69f69206483" class="bulleted-list"><li style="list-style-type:circle">确定模型和字段后还要考虑它们之间的关系，以下 UML 图显示了本示例即将定义的模型（框图）。如上所述，我们为藏书（一般细节）、藏书副本（系统）和作者创建了模型。还有一个可以动态选择的书籍种类模型。对于 <code>BookInstance:status</code>，我们不会为它建立模型，而是将可能的值直接编入站点代码中，因为我们不希望这些值发生变化。下图每个框都包括模型名、字段名和类型，还有方法及其返回类型。</li></ul><ul id="1f4694d5-ea46-806c-9fc0-d0e203669c8c" class="bulleted-list"><li style="list-style-type:circle">下图还展示了模型之间的关系以及重复度（Multiplicity）。重复度就是图中两框间连线两端的数字，表示两个模型之间存在的关系的数量（最大值和最小值）。例如，<code>Book</code> 框和 <code>Genre</code> 框之间有连线说明二者之间存在关系，<code>Book</code> 模型端的数字（0..*）表示一个种类必包括零种或多种藏书（多少都可以），而 <code>Genre</code> 端的数字表示一种藏书可以有零个或多个种类</li></ul><figure id="1f4694d5-ea46-80a7-8388-ceeed484a265" class="image"><a href="image%202.png"><img style="width:531.1625366210938px" src="image%202.png"/></a></figure></li></ul><p id="1f4694d5-ea46-8053-a0d4-e927044df5ab" class="">
</p><p id="1f4694d5-ea46-80ee-afe5-f025799915e6" class=""><strong>Mongoose入门：</strong></p><ul id="1f4694d5-ea46-8067-8f9f-e83c913fddc3" class="bulleted-list"><li style="list-style-type:disc">简要介绍如何将Mongoose连接到MongoDB数据库，如何定义模式和模型，以及如何进行基本查询</li></ul><p id="1f4694d5-ea46-80dd-9d50-d44724c9f5bd" class="">
</p><p id="1f4694d5-ea46-80e5-b578-cf9b426225e8" class="">【安装Mongoose和MongoDB】：</p><ul id="1f4694d5-ea46-807c-bdfc-e4cf8d12e4cb" class="bulleted-list"><li style="list-style-type:disc">Mongoose像其他依赖一样，使用NPM安装到项目（package.json）中，在项目文件夹中执行以下命令<ul id="1f4694d5-ea46-80c9-af05-e0b5b00a4ae3" class="bulleted-list"><li style="list-style-type:circle">npm install mongoose</li></ul></li></ul><ul id="1f4694d5-ea46-80e8-af79-dd0a75160402" class="bulleted-list"><li style="list-style-type:disc">安装Mongoose会添加所有依赖项，包括M哦能够DB数据库驱动程序，但不会安装MongoDB本身。安装MongoDB服务器，可以将不同系统的安装程序在本地安装。也可以在云端MongoDB实例</li></ul><p id="1f4694d5-ea46-8043-8a84-db5cf90b69c5" class="">
</p><p id="1f4694d5-ea46-8060-81f5-c566a751c83a" class="">【连接到MongoDB】：</p><ul id="1f4694d5-ea46-80f5-b073-dd0899fea9a0" class="bulleted-list"><li style="list-style-type:disc">Mongoose需要连接到MongoDB数据库。可以require（）引入，并通过mongoose.connect（）连接到本地数据库，如下<ul id="1f4694d5-ea46-8041-934a-dbc4575efa8a" class="bulleted-list"><li style="list-style-type:circle">// 导入 mongoose 模块<br/>const mongoose = require(&quot;mongoose&quot;);<br/><p id="1f4694d5-ea46-80fa-b0bb-d5a584bb8db2" class="">// 设置默认 mongoose 连接<br/>const mongoDB = &quot;mongodb://127.0.0.1/my_database&quot;;<br/>mongoose.connect(mongoDB);<br/>// 让 mongoose 使用全局 Promise 库<br/>mongoose.Promise = global.Promise;<br/>// 取得默认连接<br/>const db = mongoose.connection;<br/></p><p id="1f4694d5-ea46-80e5-b9c5-ead8de79ec9d" class="">// 将连接与错误事件绑定（以获得连接错误的提示）<br/>db.on(&quot;error&quot;, console.error.bind(console, &quot;MongoDB 连接错误：&quot;));<br/></p></li></ul><ul id="1f4694d5-ea46-80b8-bd92-fbe9122d601d" class="bulleted-list"><li style="list-style-type:circle">可以使用mongoose.connection取得默认的Connection对象，一旦链接，Connection实例将触发打开事件<figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f4694d5-ea46-8056-9a37-d457389ab39f"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f4694d5-ea46-802e-ba2b-db23fda74437" class="">可以使用mongoose.createConnection（）创建其他链接。该函数与connect（）的参数（数据库URL、包括主机地址、数据库名、端口、选项等）一致，并返回一个Connection对象</p></div></figure></li></ul></li></ul><p id="1f4694d5-ea46-8097-83cc-c35373797669" class="">
</p><p id="1f4694d5-ea46-8026-9efb-c99c2129e46a" class="">【定义和添加模型】：</p><ul id="1f4694d5-ea46-808b-b95b-d3a462c8cbbd" class="bulleted-list"><li style="list-style-type:disc">模型使用Schema接口进行定义。Schema可以定义每个文档中存储的字段，以及字段的验证要求和默认值。还可以通过定义静态和实例辅助方式来更轻松地处理各种类型的数据，还可以像使用普通字段一样使用数据库中并不存在的虚拟属性</li></ul><ul id="1f4694d5-ea46-8086-9708-c635b01d0f48" class="bulleted-list"><li style="list-style-type:disc">mongoose.model（）方法将模式编译为模型，模型可以用来查找、创建、更新和删除特定类型的对象。</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f4694d5-ea46-809b-acbc-dfd32f6201c4"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f4694d5-ea46-8053-a3de-c9de15d3db68" class="">MongoDB数据库中，每个模型都映射至一组文档，这些文档包含Schema模型定义的字段名/模式类型</p></div></figure><p id="1f4694d5-ea46-8006-a5c7-c0a48ef84c41" class=""><strong>—定义模式：</strong></p><ul id="1f4694d5-ea46-803f-b47f-fb774749c1d5" class="bulleted-list"><li style="list-style-type:disc">下面片段定义了一个简单的模式。首先require（）mongoose，然后使用Schema构造器创建一个新的模式实例，使用构造器的对象参数定义各个字段<p id="1f4694d5-ea46-8009-b88a-f13ff39b5813" class="">// 获取 Mongoose<br/>const mongoose = require(&quot;mongoose&quot;);<br/></p><p id="1f4694d5-ea46-80d4-b5fb-d47fe9de4296" class="">// 定义一个模式<br/>var Schema = mongoose.Schema;<br/></p><p id="1f4694d5-ea46-80e8-82cf-ef5d72f36d58" class="">var SomeModelSchema = new Schema({<br/>a_string: String,<br/>a_date: Date,<br/>});<br/></p></li></ul><ul id="1f4694d5-ea46-8076-8441-fee38d567c49" class="bulleted-list"><li style="list-style-type:disc">只定义了两个字段（一个字符串和一个日期），接下来展示其他字段类型、验证和其他方法</li></ul><p id="1f4694d5-ea46-8014-a9f5-d4816c5647c7" class="">
</p><p id="1f4694d5-ea46-804b-b2bb-e075305d1443" class=""><strong>—创建模型：</strong></p><ul id="1f4694d5-ea46-8053-9195-f5b9cb5a0ad9" class="bulleted-list"><li style="list-style-type:disc">使用mongoose.model（）方法从模式创建模型<p id="1f4694d5-ea46-8051-8931-ee30db2726ec" class="">// 定义模式<br/>const Schema = mongoose.Schema;<br/></p><p id="1f4694d5-ea46-8000-b876-f3d78a459fa3" class="">const SomeModelSchema = new Schema({<br/>a_string: String,<br/>a_date: Date,<br/>});<br/></p><p id="1f4694d5-ea46-80c9-a67d-f64be3aea46f" class="">// 使用模式“编译”模型<br/>const SomeModel = mongoose.model(&quot;SomeModel&quot;, SomeModelSchema);<br/></p></li></ul><ul id="1f4694d5-ea46-8063-9a7a-f68f6a06f243" class="bulleted-list"><li style="list-style-type:disc">第一个参数为模型所创建集合的别名（Mongoose敬畏SomeModel模型创建数据库集合），第二个参数时创建模型时使用的模型</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f4694d5-ea46-8077-99d6-de4c823090af"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f4694d5-ea46-8028-aca2-d7f37fa16447" class="">定义模型类后，可以使用他们来创建、更新或删除记录，以及通过查询来获取所有记录或特定子集。</p></div></figure><p id="1f4694d5-ea46-80dd-b708-cdea80b2e0a3" class="">
</p><p id="1f4694d5-ea46-80ec-ad0c-e03f7b37c749" class=""><strong>—模式类型（字段）：</strong></p><ul id="1f4694d5-ea46-80fa-9464-e74c9e4fa838" class="bulleted-list"><li style="list-style-type:disc">模式可以包含任意数量的字段，每个字段代表MongoDB文档中的一段存储区域，下面实例包含常见字段类型和声明方式<p id="1f4694d5-ea46-80c9-8409-d5fa89af4997" class="">const schema = new Schema({<br/>name: String,<br/>binary: Buffer,<br/>living: Boolean,<br/>updated: { type: Date, default: Date.now },<br/>age: { type: Number, min: 18, max: 65, required: true },<br/>mixed: Schema.Types.Mixed,<br/>_someId: Schema.Types.ObjectId,<br/>array: [],<br/>ofString: [String], // 其他类型也可使用数组<br/>nested: { stuff: { type: String, lowercase: true, trim: true } },<br/>});<br/></p></li></ul><ul id="1f4694d5-ea46-80f1-bca0-e596c889d9e4" class="bulleted-list"><li style="list-style-type:disc">大多数模式类型是自解释的，除了<ul id="1f4694d5-ea46-80b0-a80f-c7a451ff2e26" class="bulleted-list"><li style="list-style-type:circle">ObjectID：表示数据库中的某一模型的特定实例。例如一本书可能会使用它来代表其作者对象。它实际只包含指定对象的唯一ID（_id），可以使用populate（）方法在需要时提取相关信息</li></ul><ul id="1f4694d5-ea46-8033-a41f-ef0adf762942" class="bulleted-list"><li style="list-style-type:circle">Mixed：任意模式类型</li></ul><ul id="1f4694d5-ea46-80d0-a609-dc1204eab1b8" class="bulleted-list"><li style="list-style-type:circle">【】：对象数组，以在此类模型上执行JS数组操作（push、pop、unshift等）。上例中有一个没有指定类型的对象数组和一个String对象数组，数组中的对象可以是任意类型</li></ul></li></ul><ul id="1f4694d5-ea46-80da-af05-c32d59b368a7" class="bulleted-list"><li style="list-style-type:disc">代码还展示了声明字段的两种方法：<ul id="1f4694d5-ea46-805f-8a6c-c1a94e0ff6c1" class="bulleted-list"><li style="list-style-type:circle">字段名和类型名作为键值对（name、binary和living）</li></ul><ul id="1f4694d5-ea46-8088-aabc-c20a160a8f29" class="bulleted-list"><li style="list-style-type:circle">字段名加对象，在对象中定义type和字段的其他选项，可以是<ul id="1f4694d5-ea46-808b-aa07-e475eb2abbaa" class="bulleted-list"><li style="list-style-type:square">默认值</li></ul><ul id="1f4694d5-ea46-80c9-9c1d-cd8f199122ed" class="bulleted-list"><li style="list-style-type:square">内置验证器（最大最小值等）和自定义验证函数</li></ul><ul id="1f4694d5-ea46-8000-ae09-df736d6b574d" class="bulleted-list"><li style="list-style-type:square">该字段是否必须</li></ul><ul id="1f4694d5-ea46-80d8-ba3c-c41c46c10623" class="bulleted-list"><li style="list-style-type:square">是否将String字段自动转换为小写、大写、截断两端空格（{type:String，lowercase：true，trim：true}）</li></ul></li></ul></li></ul><p id="1f4694d5-ea46-8043-a15b-c62edfa3aee8" class="">
</p><p id="1f4694d5-ea46-802f-9600-f89607f29bd8" class=""><strong>—验证：</strong></p><ul id="1f4694d5-ea46-8029-9b31-c1de0f9d6bb3" class="bulleted-list"><li style="list-style-type:disc">Mongoose提供内置的和自定义的验证器，以及同步的和异步的验证其，可以在所有情况下指定可接受的范围和值，以及验证失败的错误消息</li></ul><ul id="1f4694d5-ea46-8017-90c8-e846a33dd159" class="bulleted-list"><li style="list-style-type:disc">内置的验证其包括<ul id="1f4694d5-ea46-80ad-bfa0-e636fdbd8ecd" class="bulleted-list"><li style="list-style-type:circle">所有模式类型都具有内置的required和验证其，用于指定当前字段是否为保存文档所必需的</li></ul><ul id="1f4694d5-ea46-80b3-b72a-f5cf0632431c" class="bulleted-list"><li style="list-style-type:circle">Number有数值范围验证其min和max</li></ul><ul id="1f4694d5-ea46-80ab-827d-df628c15fc49" class="bulleted-list"><li style="list-style-type:circle">String有<ul id="1f4694d5-ea46-8019-92ee-dc1bb248c606" class="bulleted-list"><li style="list-style-type:square">enum：指定当前字段允许值的集合</li></ul><ul id="1f4694d5-ea46-805e-9278-ce060f7b7e45" class="bulleted-list"><li style="list-style-type:square">match：指定字符串必须匹配的正则表达式</li></ul><ul id="1f4694d5-ea46-800f-94d5-c80f6427fb58" class="bulleted-list"><li style="list-style-type:square">字符串的最大长度maxlength和最小长度minlength</li></ul></li></ul></li></ul><ul id="1f4694d5-ea46-802a-9892-c6d9eea25b21" class="bulleted-list"><li style="list-style-type:disc">以下是类型验证其和错误消息的设定方法（从Mongoose文档稍作修改而来）：<p id="1f4694d5-ea46-80f2-a692-c60be6f5d09d" class="">const breakfastSchema = new Schema({<br/>eggs: {<br/>type: Number,<br/>min: [6, &quot;鸡蛋太少&quot;],<br/>max: 12,<br/>},<br/>drink: {<br/>type: String,<br/>enum: [&quot;咖啡&quot;, &quot;茶&quot;],<br/>},<br/>});<br/></p></li></ul><p id="1f4694d5-ea46-8027-92ba-ff40997ace0c" class="">
</p><p id="1f4694d5-ea46-80ee-aa86-cbe39afd5587" class=""><strong>—虚拟属性：</strong></p><ul id="1f4694d5-ea46-8049-920d-e37ae8e19dd6" class="bulleted-list"><li style="list-style-type:disc">虚拟属性是可以获取和设置、但不会保存到MongoDB的文档属性，getter可用于格式化或组合字段，而setter可用于将单个值分解为多个值从而便于存储。</li></ul><ul id="1f4694d5-ea46-8041-b0bc-e17cba18c26d" class="bulleted-list"><li style="list-style-type:disc">文档的实例，从名字和姓氏字段构造（并解构）一个全名虚拟属性，这笔每次在模板做使用全面更简单</li></ul><ul id="1f4694d5-ea46-8028-8aef-c23bddc04735" class="bulleted-list"><li style="list-style-type:disc">使用库中的一个虚拟属性，用路径和记录的_id来为每个模型记录定义唯一的URL</li></ul><p id="1f4694d5-ea46-806c-8454-d34247d96bfd" class="">
</p><p id="1f4694d5-ea46-80b2-9e7b-efdcc1b27c91" class=""><strong>—方法和查询助手：</strong></p><ul id="1f4694d5-ea46-8030-91ea-df1d0f25be2e" class="bulleted-list"><li style="list-style-type:disc">模式支持实例方法、静态方法、查询助手。<ul id="1f4694d5-ea46-80d0-9686-c75a2cf00589" class="bulleted-list"><li style="list-style-type:circle">实例方法和静态方法外表很相似，但有本质区别，实例方法针对特定记录，且可以访问当前对象</li></ul><ul id="1f4694d5-ea46-80b1-b88e-e2d6b7ac74ea" class="bulleted-list"><li style="list-style-type:circle">查询助手可用于扩展Mongoose的链式查询API（例如在find（）、findOnde（）、findById（）方法外可以添加一个byName查询。）</li></ul></li></ul><p id="1f4694d5-ea46-80e7-9652-cc00e525ef08" class="">
</p><p id="1f4694d5-ea46-80b0-a766-cf3000419eff" class=""><strong>—使用模型：</strong></p><ul id="1f4694d5-ea46-8031-8320-d75eed3da182" class="bulleted-list"><li style="list-style-type:disc">可以使用创建好的模式来创建模型。模型即数据库中可以搜索到的一类文档，模型的实例既可以存取单个文档</li></ul><p id="1f4694d5-ea46-8015-8965-c54e02012359" class="">
</p><p id="1f4694d5-ea46-80b8-8829-c12b68dbfea9" class=""><strong>—创建和修改文档：</strong></p><ul id="1f4694d5-ea46-8017-a05d-d29f77ceecf9" class="bulleted-list"><li style="list-style-type:disc">可以通过定义模型的实例并调用save（）来创建记录，以下示例假定SomeModel时使用现有模式创建的模型（只有一个字段name）<p id="1f4694d5-ea46-80ec-b3b7-ea6d68ca9a76" class="">// 创建一个 SomeModel 模型的实例<br/>const awesome_instance = new SomeModel({ name: &quot;牛人&quot; });<br/></p><p id="1f4694d5-ea46-80eb-a9a9-fbbef4ebfaea" class="">// 传递回调以保存这个新建的模型实例<br/>awesome_instance.save(function (err) {<br/>if (err) {<br/>return handleError(err);<br/>} // 已保存<br/>});<br/></p><ul id="1f4694d5-ea46-80c6-a653-fd0781d6601d" class="bulleted-list"><li style="list-style-type:circle">记录的创建（更新、删除、查询）操作都是异步的，可以提供一个回调函数在操作完成时调用。由于API遵循错误参数有限的惯例，因此毁掉的第一个参数为错误值（或null），如果API需要返回一些结果，则将结果作为第二个参数。</li></ul></li></ul><ul id="1f4694d5-ea46-8045-a7ca-e2ee7a81b4e8" class="bulleted-list"><li style="list-style-type:disc">还可以使用create（），在定义模型实例的同时将其保存，回调的第一个参数返回错误，第二个参数返回新建的模型实例<p id="1f4694d5-ea46-807e-953c-d7ce22bdaf8d" class="">SomeModel.create({ name: &quot;也是牛人&quot; }, function (err, awesome_instance) {<br/>if (err) {<br/>return handleError(err);<br/>} // 已保存<br/>});<br/></p></li></ul><ul id="1f4694d5-ea46-8062-b65f-dea13e65f760" class="bulleted-list"><li style="list-style-type:disc">每个模型都有一个相关的链接（使用mongoose.model（）时将作为默认链接）。可以通过创建新连接并对其使用.model，从而在另一个数据库上创建文档。</li></ul><ul id="1f4694d5-ea46-8079-92dd-c7ef8aa6f9c8" class="bulleted-list"><li style="list-style-type:disc">可以使用圆点加字段名来访问、修改新纪录中的字段。操作后必须调用save（）或update（）来将改动保存回数据库<p id="1f4694d5-ea46-80f7-9d21-fb40473737d6" class="">// 使用圆点来访问模型的字段值<br/>console.log(awesome_instance.name); // 控制台将显示 &#x27;也是牛人&#x27;<br/></p><p id="1f4694d5-ea46-802e-a8c0-d791342472f2" class="">// 修改字段内容并调用 save() 以修改记录<br/>awesome_instance.name = &quot;酷毙了的牛人&quot;;<br/>awesome_instance.save(function (err) {<br/>if (err) {<br/>return handleError(err);<br/>} // 已保存<br/>});<br/></p></li></ul><p id="1f4694d5-ea46-8000-bfa8-eab22cba4c1b" class="">
</p><p id="1f4694d5-ea46-80d7-b80f-d91b37a0b9e7" class=""><strong>—搜索记录：</strong></p><ul id="1f4694d5-ea46-8037-a075-c2f1fcbef085" class="bulleted-list"><li style="list-style-type:disc">可以使用查询方法搜索记录，查询条件可以列在JSON文档中，以下代码展示了如何在数据库中找到所有网球运动员，并返回运动员姓名、年龄字段，这里只指定了一个匹配字段（运动项目，sport），可以添加更多条件，指定正则表达式，获取出所有条件来返回所有运动员<p id="1f4694d5-ea46-80bc-b7a5-db1797634d9d" class="">const Athlete = mongoose.model(&quot;Athlete&quot;, yourSchema);</p><p id="1f4694d5-ea46-801a-9d15-caaecf9fb429" class="">// SELECT name, age FROM Athlete WHERE sport=&#x27;Tennis&#x27;<br/>Athlete.find({ sport: &quot;Tennis&quot; }, &quot;name age&quot;, function (err, athletes) {<br/>if (err) {<br/>return handleError(err);<br/>} // &#x27;athletes&#x27; 中保存一个符合条件的运动员的列表<br/>});<br/></p><ul id="1f4694d5-ea46-802b-ab48-f3b421149ff2" class="bulleted-list"><li style="list-style-type:circle">像上述代码指定回调，查询会立即执行，搜索完成后将调用回调</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f4694d5-ea46-8060-aba9-eb0e5a362be0"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f4694d5-ea46-8036-b009-fdb10ddf753f" class="">Mongoose中所有回调都使用callback（error，result）模式，如果查询时发生错误，则参数error将包含错误稳定，result为null。查询成功则error为null，查询结果填充至result</p></div></figure><ul id="1f4694d5-ea46-80d6-a330-e4e47a87acec" class="bulleted-list"><li style="list-style-type:circle">若未指定回调，则API将返回Query类型的变量，可以使用该查询对象来构建查询，随后使用exec（）方法执行（使用回调函数）<p id="1f4694d5-ea46-8072-ba57-c3addca7343f" class="">// 寻找所有网球运动员<br/>const query = Athlete.find({ sport: &quot;Tennis&quot; });<br/></p><p id="1f4694d5-ea46-808a-b98a-ee53bf64ac82" class="">// 查找 name, age 两个字段<br/>query.select(&quot;name age&quot;);<br/></p><p id="1f4694d5-ea46-80e9-9883-d12624196a2e" class="">// 只查找前 5 条记录<br/>query.limit(5);<br/></p><p id="1f4694d5-ea46-806e-b5ce-f9e3db33db0c" class="">// 按年龄排序<br/>query.sort({ age: -1 });<br/></p><p id="1f4694d5-ea46-80bd-b2f3-d0a036b6afdb" class="">// 以后某个时间运行该查询<br/>query.exec(function (err, athletes) {<br/>if (err) {<br/>return handleError(err);<br/>} // athletes 中保存网球运动员列表，按年龄排序，共 5 条记录<br/>});<br/></p><ul id="1f4694d5-ea46-8094-89f3-e650591e1f4c" class="bulleted-list"><li style="list-style-type:square">上面的查询条件定义在find（）方法中，也可以使用where（）函数来执行此操作，可以使用点运算符（.）将查询连接在一起，以下代码和上述代码查询基本相同，还添加了年龄范围的附加条件</li></ul></li></ul><p id="1f4694d5-ea46-80c2-b314-f4ff80214dd1" class="">Athlete.find()<br/>.where(&quot;sport&quot;)<br/>.equals(&quot;Tennis&quot;)<br/>.where(&quot;age&quot;)<br/>.gt(17)<br/>.lt(50) // 附加 WHERE 查询<br/>.limit(5)<br/>.sort({ age: -1 })<br/>.select(&quot;name age&quot;)<br/>.exec(callback); // 回调函数的名字是 callback<br/></p></li></ul><ul id="1f4694d5-ea46-80af-8df5-cbe10f23aa4a" class="bulleted-list"><li style="list-style-type:disc">find（）方法会取得所有匹配记录，使用下面方法查询单个记录<ul id="1f4694d5-ea46-80b6-bd00-f74a8a237f9c" class="bulleted-list"><li style="list-style-type:circle">findById（）：使用指定id查找文档（每个文档都有一个唯一的id）</li></ul><ul id="1f4694d5-ea46-800e-a291-f3deab049b24" class="bulleted-list"><li style="list-style-type:circle">findOnde（）：查找与指定条件匹配的第一个文档</li></ul><ul id="1f4694d5-ea46-8022-8d73-f74dbe18ac16" class="bulleted-list"><li style="list-style-type:circle">findByIdAndRemove（）、findByIdAndUpdate（）、findOneAndRemove（）、findOneAndUpdate（）：通过id或条件查找单个文档，并进行更新或删除。</li></ul><ul id="1f4694d5-ea46-800f-b74f-fc2114c7c487" class="bulleted-list"><li style="list-style-type:circle">count（）：可获取匹配条件的项目的个数，不会获取实际记录，仅获得记录个数。</li></ul></li></ul><p id="1f4694d5-ea46-8086-8ada-e7cb5e203112" class="">
</p><p id="1f4694d5-ea46-800a-a6a7-f6275931350a" class=""><strong>—文档间协调-population：</strong></p><ul id="1f4694d5-ea46-800d-980e-c610b7f40a21" class="bulleted-list"><li style="list-style-type:disc">可以使用ObjectId模式字段来创建两个文档/模型实例间一对一引用（一组ObjectIds可以创建一对多的引用），该字段存储相关模型的id。如果需要相关文档的实际内容，可以在查询中使用populate（）方法，将id替换为实际数据<ul id="1f4694d5-ea46-80de-9861-cb87222d96a3" class="bulleted-list"><li style="list-style-type:circle">例如，一下模式定义了作者和间接，每个作者可以有多条简介，我们将其表示为一个ObjectId数组，每条简介只对应一个作者“ref”（黑体字）告知模式分配哪个模型给该字段<p id="1f4694d5-ea46-8046-adf5-e66acd8a30a6" class="">const mongoose = require(&quot;mongoose&quot;);<br/>const Schema = mongoose.Schema;<br/></p><p id="1f4694d5-ea46-804f-89d7-d57215921516" class="">const authorSchema = Schema({<br/>name: String,<br/>stories: [{ type: Schema.Types.ObjectId, ref: &quot;Story&quot; }],<br/>});<br/></p><p id="1f4694d5-ea46-80e6-abe7-d615f07e4038" class="">const storySchema = Schema({<br/>author: { type: Schema.Types.ObjectId, ref: &quot;Author&quot; },<br/>title: String,<br/>});<br/></p><p id="1f4694d5-ea46-80f9-b595-dae90a43bbbe" class="">const Story = mongoose.model(&quot;Story&quot;, storySchema);<br/>const Author = mongoose.model(&quot;Author&quot;, authorSchema);<br/></p></li></ul><ul id="1f4694d5-ea46-8035-9f28-fd8032b8e4ad" class="bulleted-list"><li style="list-style-type:circle">通过分配_id至来保存对相关文档的引用。下面创建一个作者、一条简介，并将新简介的author字段设置为新建作者的id<p id="1f4694d5-ea46-8004-bd0f-d109b8fba41a" class="">const wxm = new Author({ name: &quot;司马迁&quot; });</p><p id="1f4694d5-ea46-807e-be87-dfd65672f0b6" class="">wxm.save(function (err) {<br/>if (err) {<br/>return handleError(err);<br/>}<br/></p><p id="1f4694d5-ea46-808a-95d7-c3568b47e7b9" class="">// 现在库中有了作者司马迁，我们来新建一条简介<br/>const story = new Story({<br/>title: &quot;司马迁是历史学家&quot;,<br/>author: wxm._id, // author 设置为作者 司马迁 的 _id。ID 是自动创建的。<br/>});<br/></p><p id="1f4694d5-ea46-807e-aa56-fadf35a513cb" class="">story.save(function (err) {<br/>if (err) {<br/>return handleError(err);<br/>} // 司马迁有了一条简介<br/>});<br/>});<br/></p></li></ul><ul id="1f4694d5-ea46-8036-9239-ff3caac29323" class="bulleted-list"><li style="list-style-type:circle">下面简介文档通过作者文档的ID引用作者，可使用populate（）在简介中获取作者信息<p id="1f4694d5-ea46-8094-9b8f-ed2798053a74" class="">Story.findOne({ title: &quot;司马迁是历史学家&quot; })<br/>.populate(&quot;author&quot;) // 使用作者 id 填充实际作者信息<br/>.exec(function (err, story) {<br/>if (err) {<br/>return handleError(err);<br/>}<br/>console.log(&quot;作者是 %s&quot;, <br/><a href="http://story.author.name/">story.author.name</a>);<br/>// 控制台将打印 &quot;作者是 司马迁&quot;<br/>});<br/></p></li></ul></li></ul><p id="1f4694d5-ea46-80f9-89c6-ffc6f711fe16" class="">
</p><p id="1f4694d5-ea46-8084-9165-efc244ae8c73" class=""><strong>—模式（模型）配对一文件：</strong></p><ul id="1f4694d5-ea46-804a-8384-d2fb0659f182" class="bulleted-list"><li style="list-style-type:disc">虽然创建模式和模型没有文件结构的限制，但强烈建议将单一模式定义在单一模块（文件）中，并通过导出方法来创建模型，如下所示<p id="1f4694d5-ea46-809b-bcc4-fb9b9c51eea2" class="">// 文件：./models/somemodel.js</p><p id="1f4694d5-ea46-80f2-bfcf-f15c07fa9ec6" class="">// Require Mongoose<br/>const mongoose = require(&quot;mongoose&quot;);<br/></p><p id="1f4694d5-ea46-8084-a3af-cd5d397b13d1" class="">// 定义一个模式<br/>const Schema = mongoose.Schema;<br/></p><p id="1f4694d5-ea46-808a-88ae-ced8b6eddd3e" class="">const SomeModelSchema = new Schema({<br/>a_string: String,<br/>a_date: Date,<br/>});<br/></p><p id="1f4694d5-ea46-801a-95a2-cf1e132b69a6" class="">// 导出函数来创建 &quot;SomeModel&quot; 模型类<br/>module.exports = mongoose.model(&quot;SomeModel&quot;, SomeModelSchema);<br/></p></li></ul><ul id="1f4694d5-ea46-8008-adc9-cd313d6101ba" class="bulleted-list"><li style="list-style-type:disc">然后就可以在其他文件中，require并使用该模型，下面时通过SomeModel模块来获取所有实例的方法<p id="1f4694d5-ea46-8061-bec9-d8b73cb18c90" class="">// 通过 require 模块来创建 SomeModel 模型<br/>const SomeModel = require(&quot;../models/somemodel&quot;);<br/></p><p id="1f4694d5-ea46-804d-b2b2-fd797c4842df" class="">// 使用 SomeModel 对象（模型）来查找所有的 SomeModel 记录<br/>SomeModel.find(callback_function);<br/></p></li></ul><p id="1f4694d5-ea46-80ce-89a0-e60495152690" class="">
</p><p id="1f4694d5-ea46-805c-9339-c4f820c22f82" class=""><strong>【架设MongoDB数据库】：</strong></p><ul id="1f4694d5-ea46-80c4-be9d-f06536ed8a66" class="bulleted-list"><li style="list-style-type:disc">此处使用的是云数据库 mLab免费版</li></ul><ul id="1f4694d5-ea46-8080-affa-e81aa33a4acb" class="bulleted-list"><li style="list-style-type:disc">也可以下载并安装对应的安装包，设置本地版M哦能够DB数据库，指令与使用云数据库是一样的，除了连接时数据库的URL</li></ul><ul id="1f4694d5-ea46-80fe-9a72-dae99a088d87" class="bulleted-list"><li style="list-style-type:disc">下载安装本地版</li></ul><p id="1f4694d5-ea46-808e-ba10-fd22576ae657" class="">
</p><p id="1f4694d5-ea46-8060-9477-ddbfe339cb94" class=""><strong>—安装Mongoose：</strong></p><ul id="1f4694d5-ea46-80a7-80dd-f6836426de93" class="bulleted-list"><li style="list-style-type:disc">打开终端，到项目目录，使用以下命令安装Mongoose及其依赖项。并将其添加至package.json<ul id="1f4694d5-ea46-804e-a7e3-e845f19cf227" class="bulleted-list"><li style="list-style-type:circle">npm install mongoose</li></ul></li></ul><p id="1f4694d5-ea46-8082-8f85-e2ec7f95c0b6" class="">
</p><p id="1f4694d5-ea46-8068-9c69-f2099a83838e" class=""><strong>—连接到MongoDB：</strong></p><ul id="1f4694d5-ea46-80f3-b343-e6377293d192" class="bulleted-list"><li style="list-style-type:disc">打开/app.js（项目根目录），将以下代码复制到声明Express应用对象的位置（var app = express（）；之后）。将数据库URL字符串替换为真实的URL<ul id="1f4694d5-ea46-808a-b039-c3502196de85" class="bulleted-list"><li style="list-style-type:circle">// 设置 Mongoose 连接<br/>const mongoose = require(&quot;mongoose&quot;);<br/>const mongoDB = &quot;在此插入数据库_URL&quot;;<br/>mongoose.connect(mongoDB, { useNewUrlParser: true, useUnifiedTopology: true });<br/>mongoose.Promise = global.Promise;<br/>const db = mongoose.connection;<br/>db.on(&quot;error&quot;, console.error.bind(console, &quot;MongoDB 连接错误：&quot;));<br/><ul id="1f4694d5-ea46-8046-8faa-ed0a20a0f872" class="bulleted-list"><li style="list-style-type:square">如上文所属，代码创建了与数据库的默认链接，并绑定了错误时间。错误信息将打印到控制台</li></ul></li></ul></li></ul><p id="1f4694d5-ea46-80ee-b602-d3f5cf471c82" class="">
</p><p id="1f4694d5-ea46-809e-8a97-f2aa7c04ceb7" class=""><strong>—定义LocalLibrary模式：</strong></p><ul id="1f4694d5-ea46-80c3-b9b2-cef7c5567b5e" class="bulleted-list"><li style="list-style-type:disc">如上文所述，将每个模型定义为单独的模块，首先在项目根目录中创建一个文件夹用来保存模型（/models），然后为每个模型创建单独的文件</li></ul><figure id="1f4694d5-ea46-803e-b59a-d119073ce5ea" class="image"><a href="image%203.png"><img style="width:561.1625366210938px" src="image%203.png"/></a></figure><p id="1f4694d5-ea46-8097-89fb-d2de43a5a61d" class="">
</p><p id="1f4694d5-ea46-80f0-bc43-c9ac79a929c4" class=""><strong>—作者模型（Author）：</strong></p><ul id="1f4694d5-ea46-805b-8bfd-d97976de0e6a" class="bulleted-list"><li style="list-style-type:disc">代码如下，模式中定义了两个String模式类型来表示作者的姓氏和名字（这两个字段是必须的，且长度不得超过100字符），定义了两个Date字段作为作者生卒日期。<ul id="1f4694d5-ea46-80cc-aa95-c87038c48fc0" class="bulleted-list"><li style="list-style-type:circle">const mongoose = require(&quot;mongoose&quot;);<p id="1f4694d5-ea46-8085-a8a5-e3c656334910" class="">const Schema = mongoose.Schema;</p><p id="1f4694d5-ea46-8058-9bc2-c1846224a6e1" class="">const AuthorSchema = new Schema({<br/>first_name: { type: String, required: true, max: 100 },<br/>family_name: { type: String, required: true, max: 100 },<br/>date_of_birth: { type: Date },<br/>date_of_death: { type: Date },<br/>});<br/></p><p id="1f4694d5-ea46-80d8-a1a2-efc5bfe9a6de" class="">// 虚拟属性&#x27;name&#x27;：表示作者全名<br/>AuthorSchema.virtual(&quot;name&quot;).get(function () {<br/>return this.family_name + &quot;, &quot; + this.first_name;<br/>});<br/></p><p id="1f4694d5-ea46-80fc-a31b-c1503f5d6573" class="">// 虚拟属性&#x27;lifespan&#x27;：作者寿命<br/>AuthorSchema.virtual(&quot;lifespan&quot;).get(function () {<br/>return (<br/>this.date_of_death.getYear() - this.date_of_birth.getYear()<br/>).toString();<br/>});<br/></p><p id="1f4694d5-ea46-8087-a966-d77727ae4fcd" class="">// 虚拟属性&#x27;url&#x27;：作者 URL<br/>AuthorSchema.virtual(&quot;url&quot;).get(function () {<br/>return &quot;/catalog/author/&quot; + this._id;<br/>});<br/></p><p id="1f4694d5-ea46-8034-bb4c-f639fd2d6f36" class="">// 导出 Author 模型<br/>module.exports = mongoose.model(&quot;Author&quot;, AuthorSchema);<br/></p></li></ul><ul id="1f4694d5-ea46-80ba-8e59-f97ee68d0483" class="bulleted-list"><li style="list-style-type:circle">为AuthorSchema声明了一个url虚拟属性，一返回母校特定实例的绝对URL，在模板中需要获取特定作者的链接时可以使用该属性。</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f4694d5-ea46-80d4-b1e9-dbcabcad74e6"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f4694d5-ea46-8074-ac72-d843f7131984" class="">有必要将URL声明为虚拟属性，因为这样，项目的URL只需要在一处进行更改，此时使用此URL的链接还不能工作，因为目前还没有设置任何路由，无法处理特定模型实例的代码</p></div></figure></li></ul><p id="1f4694d5-ea46-8064-be0d-c8da859a125d" class="">
</p><p id="1f4694d5-ea46-8007-b92b-d95e927653a4" class=""><strong>—藏书模型（Book）：</strong></p><ul id="1f4694d5-ea46-8069-8ddd-c2fae015bdd4" class="bulleted-list"><li style="list-style-type:disc">大体结构类似于作者模型，有三个字符串字段，一个用于获取特定藏书记录URL的虚拟属性，代码最后对模型进行导出<ul id="1f4694d5-ea46-8032-b70e-e3397519e201" class="bulleted-list"><li style="list-style-type:circle">const mongoose = require(&quot;mongoose&quot;);<p id="1f4694d5-ea46-8083-a0d3-cee6025c7a6f" class="">const Schema = mongoose.Schema;</p><p id="1f4694d5-ea46-800c-8b81-fa47f069a65f" class="">const BookSchema = new Schema({<br/>title: { type: String, required: true },<br/>author: { type: Schema.Types.ObjectId, ref: &quot;Author&quot;, required: true },<br/>summary: { type: String, required: true },<br/>isbn: { type: String, required: true },<br/>genre: [{ type: Schema.Types.ObjectId, ref: &quot;Genre&quot; }],<br/>});<br/></p><p id="1f4694d5-ea46-80c6-832a-f86b648daf3c" class="">// 虚拟属性&#x27;url&#x27;：藏书 URL<br/>BookSchema.virtual(&quot;url&quot;).get(function () {<br/>return &quot;/catalog/book/&quot; + this._id;<br/>});<br/></p><p id="1f4694d5-ea46-8098-8d12-f9668e97c871" class="">// 导出 Book 模块<br/>module.exports = mongoose.model(&quot;Book&quot;, BookSchema);<br/></p></li></ul></li></ul><ul id="1f4694d5-ea46-80b2-a3e4-cc3b27cc9b21" class="bulleted-list"><li style="list-style-type:disc">主要区别在于：此处有两个字段是对其他模型的引用<ul id="1f4694d5-ea46-801a-aae4-d01c896b6748" class="bulleted-list"><li style="list-style-type:circle">author是对单一Author模型对象的引用，而且是必须的</li></ul><ul id="1f4694d5-ea46-80bb-a4b3-cc1b565de22d" class="bulleted-list"><li style="list-style-type:circle">genre是对Genre模型对象数组的引用</li></ul></li></ul><p id="1f4694d5-ea46-80fe-8541-e8124c8a9619" class="">
</p><p id="1f4694d5-ea46-8064-a5cd-ef1849691533" class=""><strong>—藏书副本模型（BookInstance）：</strong></p><ul id="1f4694d5-ea46-8043-8886-de90848fdf51" class="bulleted-list"><li style="list-style-type:disc">该模型表示可供借阅的藏书的特定副本，其中包含该副本是否可用、幻术期限、出版批次、版本详细信息等<ul id="1f4694d5-ea46-808c-9ccc-cec2543d5a80" class="bulleted-list"><li style="list-style-type:circle">const mongoose = require(&quot;mongoose&quot;);<p id="1f4694d5-ea46-80c9-a650-cb24b6d66956" class="">const Schema = mongoose.Schema;</p><p id="1f4694d5-ea46-80b0-8e85-cd79bc9fdb75" class="">const BookInstanceSchema = new Schema({<br/>// 指向相关藏书的引用<br/>book: { type: Schema.Types.ObjectId, ref: &quot;Book&quot;, required: true },<br/>// 出版项<br/>imprint: { type: String, required: true },<br/>status: {<br/>type: String,<br/>required: true,<br/>enum: [&quot;Available&quot;, &quot;Maintenance&quot;, &quot;Loaned&quot;, &quot;Reserved&quot;],<br/>default: &quot;Maintenance&quot;,<br/>},<br/>due_back: { type: Date, default: Date.now },<br/>});<br/></p><p id="1f4694d5-ea46-80fc-86b5-d3447b1d2224" class="">// 虚拟属性&#x27;url&#x27;：藏书副本 URL<br/>BookInstanceSchema.virtual(&quot;url&quot;).get(function () {<br/>return &quot;/catalog/bookinstance/&quot; + this._id;<br/>});<br/></p><p id="1f4694d5-ea46-807a-9f0f-d48e52b7b0e5" class="">// 导出 BookInstance 模型<br/>module.exports = mongoose.model(&quot;BookInstance&quot;, BookInstanceSchema);<br/></p></li></ul></li></ul><ul id="1f4694d5-ea46-8030-94be-e0b2db297357" class="bulleted-list"><li style="list-style-type:disc">上述代码添加了字段选项<ul id="1f4694d5-ea46-8008-a23c-ce92fbdd7a0a" class="bulleted-list"><li style="list-style-type:circle">enum：可以设置字符串允许的值，本例中可指定书记的状态（使用美剧可以避免状态中出现错误拼写或不允许的值）</li></ul><ul id="1f4694d5-ea46-80fc-ac17-c861e082c28a" class="bulleted-list"><li style="list-style-type:circle">default：即默认值可以设定新建藏书实例的默认状态（馆藏维护ing），还可以奖门人还书期限日期（due_back）设置为今天（now）（设置日期时注意Date函数的用法）</li></ul></li></ul><p id="1f4694d5-ea46-80c4-99e3-dd26e67ac50b" class="">
</p><p id="1f4694d5-ea46-80a4-be39-e6279a16e138" class=""><strong>—图书种类模型（Genre）：</strong></p><ul id="1f4694d5-ea46-80ac-96bd-cb32a8486ba5" class="bulleted-list"><li style="list-style-type:disc">创建模式来存储Genre（书本类别、小说、纪实类、爱情、军事、历史等）</li></ul><ul id="1f4694d5-ea46-80a7-b226-e29f6cc76b4d" class="bulleted-list"><li style="list-style-type:disc">与之前模型定义方式类似<ul id="1f4694d5-ea46-8021-9540-f5c1639c6535" class="bulleted-list"><li style="list-style-type:circle">有String模式类型，命名为name，用来描述图书种类</li></ul><ul id="1f4694d5-ea46-8098-8b0e-d4e65c5f65eb" class="bulleted-list"><li style="list-style-type:circle">name字段是必须的，3-100字符</li></ul><ul id="1f4694d5-ea46-8091-824a-d80266f509fe" class="bulleted-list"><li style="list-style-type:circle">声明虚拟属性，命名为url，返回图书类型URL</li></ul><ul id="1f4694d5-ea46-80a3-9bfe-d518051270fe" class="bulleted-list"><li style="list-style-type:circle">导出模型</li></ul><p id="1f4694d5-ea46-8089-a9b1-f4ba2ca0b6fe" class="">
</p><p id="1f4694d5-ea46-803a-b0b8-eff1f31fd0c0" class="">
</p></li></ul><p id="1f4694d5-ea46-8026-879e-e73a810393b5" class=""><strong>【测试-添加项目】：</strong></p><ul id="1f4694d5-ea46-8044-8d7d-defe7e59b074" class="bulleted-list"><li style="list-style-type:disc">测试模型，并添加一些示例藏书和项目便于以后使用。</li></ul><ul id="1f4694d5-ea46-8008-8978-e4d08e15708d" class="bulleted-list"><li style="list-style-type:disc">运行一个单独的脚本为每种类型创建一些项目<ul id="1f4694d5-ea46-8093-8027-f33c274d0ed4" class="bulleted-list"><li style="list-style-type:circle">下载populatedb.js，保存在express-locallibrary-tutorial目录（package.json所在位置）</li></ul><ul id="1f4694d5-ea46-80f6-90b1-f9e59c356947" class="bulleted-list"><li style="list-style-type:circle">在项目根目录运行以下命令，来安装脚本所需的异步模块<ul id="1f4694d5-ea46-80ea-86f4-f976bf2fa444" class="bulleted-list"><li style="list-style-type:square">npm install async</li></ul></li></ul><ul id="1f4694d5-ea46-8098-8d9e-d2f19834c844" class="bulleted-list"><li style="list-style-type:circle">在命令行用node运行此脚本并以一MongoDB数据库的url作为参数（同app.js中替换的URL一致）<ul id="1f4694d5-ea46-808f-b930-cc866dbd4105" class="bulleted-list"><li style="list-style-type:square">node populatedb &lt;mongodb url&gt;<ul id="1f4694d5-ea46-8021-b61a-ed42d05a364f" class="bulleted-list"><li style="list-style-type:disc">一般为mongodb://127.0.0.1:27017/name</li></ul></li></ul></li></ul><ul id="1f4694d5-ea46-8054-9507-db1d92e908f6" class="bulleted-list"><li style="list-style-type:circle">该脚本应一路运行至完成，并在终端中记录所创建的项目</li></ul></li></ul><p id="1f5694d5-ea46-80c2-9240-d80d76825112" class="">
</p><p id="1f5694d5-ea46-8058-84db-df3d6afbebcd" class=""><strong><span style="border-bottom:0.05em solid">【第三步-路由和控制器】：</span></strong></p><p id="1f5694d5-ea46-8069-aa3c-e4354535166d" class="">为该项目需要的所有资源端点设置为具有虚拟处理器函数的路由（URL处理代码）。完成后，就有了路由处理代码的模块化解构</p><p id="1f5694d5-ea46-80e4-99cf-caa5b6164501" class="">
</p><p id="1f5694d5-ea46-80bf-9bd0-e71a50c50b7f" class=""><strong>概览：</strong></p><ul id="1f5694d5-ea46-80f4-9cc5-fc8a2067fc3a" class="bulleted-list"><li style="list-style-type:disc">上一步定义了与数据库交互的Mongoose模型，并使用了一个独立的脚本创建了一些初始的图书馆记录，现在来编写代码向用户来展示这些信息。首先确定要在页面中显示哪些信息，然后定义适当的URL来返回这些资源，之后创建路由（URL处理器）和视图（模板）来显示这些页面</li></ul><ul id="1f5694d5-ea46-80f5-bf98-ff297fe00811" class="bulleted-list"><li style="list-style-type:disc">下图展示了HTTP请求/响应处理的主数据流和需要实现的行为，途中除视图（view）和路由（Route）之外，还展示了控制器（Controller），即将路由请求的代码和实际处理请求的代码分离的函数。</li></ul><ul id="1f5694d5-ea46-8054-a440-e1b3cae6b206" class="bulleted-list"><li style="list-style-type:disc">以下是需要创建的内容<ul id="1f5694d5-ea46-80c6-8918-c26a8ad0c776" class="bulleted-list"><li style="list-style-type:circle">模型（上一步完成）</li></ul><ul id="1f5694d5-ea46-80a4-8a4f-ef7e8f041b2a" class="bulleted-list"><li style="list-style-type:circle">路由：把需要支持的请求（以及请求URL中编码的任何信息）转发到适当的控制器函数</li></ul><ul id="1f5694d5-ea46-8071-a4ff-c029a86693da" class="bulleted-list"><li style="list-style-type:circle">控制器函数：从模型中获取请求的数据，创建一个显示数据的HTML页面，并将页面返回给用户，以便在浏览器中查看</li></ul><ul id="1f5694d5-ea46-80bd-b80a-e302b0dcf1cd" class="bulleted-list"><li style="list-style-type:circle">视图（模板）：供控制器来渲染数据</li></ul><figure id="1f5694d5-ea46-808f-83f8-d183b10d3253" class="image"><a href="image%204.png"><img style="width:533.1749877929688px" src="image%204.png"/></a></figure></li></ul><ul id="1f5694d5-ea46-80ac-b4ef-dc7850e38c7c" class="bulleted-list"><li style="list-style-type:disc">最终需要显示图书、图书种类、作者、图书副本的列表和详细信息的页面，还需要页面来创建、更新和删除记录。<ul id="1f5694d5-ea46-8020-be81-d65670ee1d89" class="bulleted-list"><li style="list-style-type:circle">本步骤主要集中在路由和控制器设置。</li></ul></li></ul><p id="1f5694d5-ea46-802b-9312-e4f0a01547d0" class="">
</p><p id="1f5694d5-ea46-80ee-b2cf-ee108f4f47b6" class=""><strong>路由入门：</strong></p><ul id="1f5694d5-ea46-8053-920a-c4ec4626c2bb" class="bulleted-list"><li style="list-style-type:disc">路由是一段Express代码，将HTTP动词（GET、POST、PUT、DELETE等）、URL路径/模式、处理函数三者关联起来</li></ul><ul id="1f5694d5-ea46-807a-bcb6-e7572a270773" class="bulleted-list"><li style="list-style-type:disc">创建路由有很多方法，本步骤使用express.Router中间件。可以将网站特定部分的路由处理器分组在一起并使用共同的路由前缀访问他们。<ul id="1f5694d5-ea46-80f6-994f-c3204b3a9945" class="bulleted-list"><li style="list-style-type:circle">将所有与图书馆相关的路由都保存在catalog（目录）模块中，如果我们添加了用于处理用户账户或其他功能的路由，可以将其单独分组</li></ul></li></ul><p id="1f5694d5-ea46-806c-bc3c-ca5763f9b76c" class="">
</p><p id="1f5694d5-ea46-80fe-acf4-dcfba4c8213a" class=""><strong>定义和使用单独的路由模块：</strong></p><ul id="1f5694d5-ea46-801a-b3c5-d6b1cbd89674" class="bulleted-list"><li style="list-style-type:disc">下面示例说明如何创建路由模块，以及如何在Express应用中使用它<ul id="1f5694d5-ea46-80d4-ac93-cad65eda49b6" class="bulleted-list"><li style="list-style-type:circle">首先在wiki.js模块中创建一个维基路由。代码一开始导入Express应用对象，使用它获得一个Router对象，然后用get（）方法向其添加两个具体的路由。模块的最后导出该Router对象<ul id="1f5694d5-ea46-80b4-9e79-c33d8701d6c6" class="bulleted-list"><li style="list-style-type:square">// wiki.js - 维基路由模块<p id="1f5694d5-ea46-806d-8082-d5ef8c9be66f" class="">const express = require(&quot;express&quot;);<br/>const router = express.Router();<br/></p><p id="1f5694d5-ea46-8062-80aa-d54e03feedab" class="">// 主页路由<br/>router.get(&quot;/&quot;, (req, res) =&gt; {<br/>res.send(&quot;维基主页&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8055-bd20-c077d9e171a6" class="">// “关于页面”路由<br/>router.get(&quot;/about&quot;, (req, res) =&gt; {<br/>res.send(&quot;关于此维基&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8022-be51-fd784e005b70" class="">module.exports = router;</p></li></ul></li></ul><ul id="1f5694d5-ea46-80fa-b8ed-cf9357964059" class="bulleted-list"><li style="list-style-type:circle">在主应用中使用该路由模块，首先应该require（）它，然后再Express应用对象上调用use（）（指定URL路径wiki），即可将其添加到中间件处理路径<ul id="1f5694d5-ea46-8049-a971-db2194990443" class="bulleted-list"><li style="list-style-type:square">const wiki = require(&quot;./wiki.js&quot;);<br/>// …<br/>app.use(&quot;/wiki&quot;, wiki);<br/></li></ul></li></ul><ul id="1f5694d5-ea46-809a-8d3b-e4cc46ff6e82" class="bulleted-list"><li style="list-style-type:circle">这里wiki模块中定义的两个路由就可以从/wiki/和/wiki/about/访问了</li></ul></li></ul><p id="1f5694d5-ea46-8074-8c5c-ec60aec5e950" class="">
</p><p id="1f5694d5-ea46-8004-98bf-ccc2b6f28802" class=""><strong>路由函数：</strong></p><ul id="1f5694d5-ea46-80eb-bd8e-f2aca5dfa0ac" class="bulleted-list"><li style="list-style-type:disc">上述模块定义了两个典型的路由函数，router.get（）方法定义的about路由，仅响应HTTP GET请求，第一个参数时URL路径，第二个参数是回调函数，收到带有路径的HTTP GET请求会调用它<ul id="1f5694d5-ea46-80e8-90ce-e69f7423ed7e" class="bulleted-list"><li style="list-style-type:circle">router.get(&quot;/about&quot;, (req, res) =&gt; {<br/>res.send(&quot;关于此维基&quot;);<br/>});<br/></li></ul></li></ul><ul id="1f5694d5-ea46-8012-90cf-ee181bb59191" class="bulleted-list"><li style="list-style-type:disc">回调函数有三个参数（通常命名为：req、res、next），分别为HTTP请求对象，HTTP响应，中间件链中的下一个函数</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f5694d5-ea46-8091-994c-f73a64798408"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f5694d5-ea46-8032-af79-d63aced9efef" class="">路由函数就是 Express 中间件，这意味着它们要么（通过响应）结束请求，要么调用链中的 <code>next</code> 函数。在上述示例中，我们使用 <code>send()</code> 完成了请求，因而没有用上 <code>next</code> 参数（参数表中将其省略）。</p><p id="1f5694d5-ea46-80f2-bad1-f0ed99bc3b0c" class="">上述路由函数只需要一个回调。我们可以根据需要指定任意数量的回调参数或一个回调函数数组。每个函数都将加入中间件链，并且将按添加顺序调用（若有回调完成请求则中止当前周期）。</p></div></figure><ul id="1f5694d5-ea46-8002-ad0c-c85ec42cf3c5" class="bulleted-list"><li style="list-style-type:disc">此处的回调是对响应对象调用send（），当收到带有路径/about的GET请求时将返回字符串’关于此维基‘。<ul id="1f5694d5-ea46-80f7-ad66-f14251aaa4b9" class="bulleted-list"><li style="list-style-type:circle">还有很多可以结束请求/响应周期相应方法，例如可以调用res.json（）来发送JSON响应，或者调用res.sendFile（）来发送文件。</li></ul></li></ul><ul id="1f5694d5-ea46-80e5-bb33-e4fd2ac33a31" class="bulleted-list"><li style="list-style-type:disc">构建本项目最常用的是render（）相应方法，它使用模板和数据创建并返回HTML文件。</li></ul><p id="1f5694d5-ea46-8072-849d-c9eff14999c2" class="">
</p><p id="1f5694d5-ea46-80fe-b255-f2891a9e61fc" class=""><strong>HTTP动词：</strong></p><ul id="1f5694d5-ea46-8081-b20d-db9dd8826723" class="bulleted-list"><li style="list-style-type:disc">上面示例使用Router.get（）方法来响应特定路径的HTTP GET 请求</li></ul><ul id="1f5694d5-ea46-80c6-afa6-c5e3f2059f33" class="bulleted-list"><li style="list-style-type:disc">Router还为其他HTTP动词提供路由方法，大多用法相同：<ul id="1f5694d5-ea46-80ff-a511-fdadc818c337" class="bulleted-list"><li style="list-style-type:circle">post（）、put（）、delete（）、options（）、trace（）、copy（）、lock（）、mkcol（）、move（）、purge（）、propfind（）、proppatch（）、unlock（）、report（）、mkactivity（）、checkout（）、merge（）、m-search（）、notify（）、subscribe（）、patch（）、search（）和connect（）</li></ul></li></ul><ul id="1f5694d5-ea46-8040-9b3f-e075967e9fa5" class="bulleted-list"><li style="list-style-type:disc">下面示例代码同上方/about路径行为一直，但只响应HTTP POST请求<ul id="1f5694d5-ea46-8088-9e6d-f7c058c1848b" class="bulleted-list"><li style="list-style-type:circle">router.post(&quot;/about&quot;, (req, res) =&gt; {<br/>res.send(&quot;关于此维基&quot;);<br/>});<br/></li></ul></li></ul><p id="1f5694d5-ea46-8095-9fd0-f707230f9d1c" class="">
</p><p id="1f5694d5-ea46-80b8-882f-c87c6c79b1db" class=""><strong>路由路径：</strong></p><ul id="1f5694d5-ea46-80ce-86b6-f532cc20c120" class="bulleted-list"><li style="list-style-type:disc">路由路径用于定义可请求的端点，之前示例路径都是字符串，而且必须精确到’/‘、‘/about’、’/book‘类似</li></ul><ul id="1f5694d5-ea46-8090-bc78-ed3da7987838" class="bulleted-list"><li style="list-style-type:disc">路由路径也可以是字符串模式（string pattern）。字符串模式使用正则表达式语法来定义将匹配的端点模式。语法如下（注意连字符-和点.再基于字符串路径中被解释为字面量）<ul id="1f5694d5-ea46-80a4-8c8c-f716d28e2b00" class="bulleted-list"><li style="list-style-type:circle">？：问号之前的字符只能出现零次或一次，例如路由路径’/ab？cd‘路径匹配端点acd或abcd等</li></ul><ul id="1f5694d5-ea46-8029-9260-e6cc03c8f327" class="bulleted-list"><li style="list-style-type:circle">+：加号之前的一个字符至少出现一次，例如路由路径’/ab+cd‘路径匹配端点abcd、abbcd、abbbcd等</li></ul><ul id="1f5694d5-ea46-806f-a795-c32fd06bc24d" class="bulleted-list"><li style="list-style-type:circle"><em>*：星号可以替换为任意字符串，例如路由路径’/ab*cd</em>‘匹配端点abcd、abXcd、abSOMErandomTEXTcd等</li></ul><ul id="1f5694d5-ea46-80e7-9a9d-c47fee00eb37" class="bulleted-list"><li style="list-style-type:circle">（）：将一个字符串视为一体执行？、+、*操作，例如’/ab（cd）？e‘将对（cd）进行匹配，将匹配到abe和abcde</li></ul></li></ul><ul id="1f5694d5-ea46-806d-8000-e73dcfb05228" class="bulleted-list"><li style="list-style-type:disc">路由路径可以是JS正则表达式，例如，下面路由路径将匹配catfish和dogfish而不是catflap、catfishhead等。注意正则表达式路径不再用引号“…”括起来，而是用正则表达式语法/…/<ul id="1f5694d5-ea46-8039-ae7d-e31ee45cb6b2" class="bulleted-list"><li style="list-style-type:circle">app.get(/.*fish$/, (req, res) =&gt; {<br/>...<br/>});<br/></li></ul></li></ul><p id="1f5694d5-ea46-80b3-8632-d58ec1caf511" class="">
</p><p id="1f5694d5-ea46-8081-bb93-cb5107851eaf" class=""><strong>路由参数：</strong></p><ul id="1f5694d5-ea46-802f-b4cf-fa1109859bf5" class="bulleted-list"><li style="list-style-type:disc">路径参数是具名URL片段，用于捕获在URL中的位置指定的值，具名段一冒号为前缀并紧接着名称（如/：your_name/）。捕获的值保存在req.params对象中，其中参数名对应对象的键（例如req.params.your_name）</li></ul><ul id="1f5694d5-ea46-804d-aa09-da21503b565e" class="bulleted-list"><li style="list-style-type:disc">比如，考虑应该包含用户和图书信息的URLhttp：//localhost：3000/users/34/books/8989.这样就可以提取信息（使用userId和bookId路径参数）<ul id="1f5694d5-ea46-8034-8bb5-e26e58af12c7" class="bulleted-list"><li style="list-style-type:circle">app.get(&quot;/users/:userId/books/:bookId&quot;, (req, res) =&gt; {<br/>// 通过 req.params.userId 访问 userId<br/>// 通过 req.params.bookId 访问 bookId<br/>res.send(req.params);<br/>});<br/></li></ul></li></ul><ul id="1f5694d5-ea46-80a1-849f-dc31070796fa" class="bulleted-list"><li style="list-style-type:disc">路由参数名必须有单词字符（A-Z、a-z、0-9、_）组成</li></ul><p id="1f5694d5-ea46-80d6-9c95-e8fe328a3525" class="">
</p><p id="1f5694d5-ea46-80e6-b2ed-ed484d30f470" class=""><strong>处理路由函数中的错误：</strong></p><ul id="1f5694d5-ea46-805e-92be-ff700f6685c3" class="bulleted-list"><li style="list-style-type:disc">上述的路由函数都有参数req和res，分别代表请求和响应，路由函数还可以使用第三个参数next，该参数可用于将错误传递给Express中间件链</li></ul><ul id="1f5694d5-ea46-8002-8781-e46b4626cc48" class="bulleted-list"><li style="list-style-type:disc">下面的代码展示next如何工作，使用一个数据库查询的示例，该查询采用回调函数并返回错误err或一些结果。如果返回err，就将err传入next方法（最终错误会传播到我们的全局错误处理代码），如果成功，将返回所需的数据并将在响应中使用<ul id="1f5694d5-ea46-8061-a29a-f7440b2db809" class="bulleted-list"><li style="list-style-type:circle">router.get(&quot;/about&quot;, (req, res, next) =&gt; {<br/>About.find({}).exec((err, queryResults) =&gt; {<br/>if (err) {<br/>return next(err);<br/>}<br/>// 成功了，那么就渲染吧<br/>res.render(&quot;about_view&quot;, { title: &quot;About&quot;, list: queryResults });<br/>});<br/>});<br/></li></ul></li></ul><p id="1f5694d5-ea46-8040-9fda-f49bb4e991e9" class="">
</p><p id="1f5694d5-ea46-8024-adec-ff50ed3d2d92" class=""><strong>处理路由函数中的异常：</strong></p><ul id="1f5694d5-ea46-800d-a8b5-c3451f6dde04" class="bulleted-list"><li style="list-style-type:disc">上面展示了Express期望路由函数返回错误的方式，该框架设计用于异步函数，这些函数采用回调函数（带有错误和结果参数），该函数在操作完成时调用。<ul id="1f5694d5-ea46-8056-80be-d2a6cdbe9bdf" class="bulleted-list"><li style="list-style-type:circle">稍后使用基于Promise的API进行Mongoose数据库查询，并且可能会在路由函数抛出异常（而不是在回调中返回错误）</li></ul></li></ul><ul id="1f5694d5-ea46-80c6-ad57-d60603cc083e" class="bulleted-list"><li style="list-style-type:disc">为例使框架正确处理异常，这些异常必须被捕获，然后将其作为错误转发。</li></ul><ul id="1f5694d5-ea46-80d9-8ba3-f274293c2ce8" class="bulleted-list"><li style="list-style-type:disc">上一节示例中，About.find（）.exec是返回Promise的数据库查询，我们可以在try … catch块内编写路由函数，如下<ul id="1f5694d5-ea46-80cb-a927-de68e4dc0aaa" class="bulleted-list"><li style="list-style-type:circle">exports.get(&quot;/about&quot;, async function (req, res, next) {<br/>try {<br/>const successfulResult = await About.find({}).exec();<br/>res.render(&quot;about_view&quot;, { title: &quot;About&quot;, list: successfulResult });<br/>} catch (error) {<br/>return next(error);<br/>}<br/>});<br/></li></ul></li></ul><ul id="1f5694d5-ea46-8088-b921-cf45c72eb287" class="bulleted-list"><li style="list-style-type:disc">每个函数都需要添加大量的样板样式，本项目中使用express-async-handler模块，它定义了一个包装器函数，隐藏了try … catch块和用于转发错误的代码，现在相同的示例更为简单，只需要为假设成功的情况编写代码即可<ul id="1f5694d5-ea46-80b4-ad1d-d17abf0a8da0" class="bulleted-list"><li style="list-style-type:circle">// 导入模块<br/>const asyncHandler = require(&quot;express-async-handler&quot;);<br/><p id="1f5694d5-ea46-8077-82ad-e8345bad1b4c" class="">exports.get(<br/>&quot;/about&quot;,<br/>asyncHandler(async (req, res, next) =&gt; {<br/>const successfulResult = await About.find({}).exec();<br/>res.render(&quot;about_view&quot;, { title: &quot;About&quot;, list: successfulResult });<br/>}),<br/>);<br/></p></li></ul></li></ul><p id="1f5694d5-ea46-8022-8052-fdc2ad08a364" class="">
</p><p id="1f5694d5-ea46-8052-b097-c7d5ffa25cb5" class=""><strong>图书馆项目所需的路由：</strong></p><ul id="1f5694d5-ea46-80ab-a581-e7359a011c9b" class="bulleted-list"><li style="list-style-type:disc">以下是站点页面完整的URL列表，其中object是模型名称（book、bookinstance、genre、author），objects是一组模型，id是每个Mongoose模型实例默认的标识字段（_id）<ul id="1f5694d5-ea46-8000-b418-d243d2abb663" class="bulleted-list"><li style="list-style-type:circle">catalog/：主页</li></ul><ul id="1f5694d5-ea46-8052-bfb2-e8601f487151" class="bulleted-list"><li style="list-style-type:circle">catallog/&lt;bojects&gt;/：模型（书本、图书副本、图书种类、作者）的完整列表（例如/catalog/books/、/catalog/genres/等）</li></ul><ul id="1f5694d5-ea46-8033-b544-d9aea5f3f3b1" class="bulleted-list"><li style="list-style-type:circle">catalog/&lt;boject&gt;/&lt;_id&gt;：具有_id字段值的特定模型的详细页面（例如/catalog/book/52727687367）</li></ul><ul id="1f5694d5-ea46-8077-95af-c1a9e639625a" class="bulleted-list"><li style="list-style-type:circle">catalog/&lt;object&gt;/create：添加新模型的表单（例如/catalog/book/create）</li></ul><ul id="1f5694d5-ea46-8000-be60-f239b6d790a6" class="bulleted-list"><li style="list-style-type:circle">catalog/&lt;object&gt;/&lt;id&gt;/update：更新具有 _id 字段值的特定模型的表单（例如 /catalog/book/584493c1f4887f06c0e67d37/update）。</li></ul><ul id="1f5694d5-ea46-803b-8ec4-fd9f7fd95dec" class="bulleted-list"><li style="list-style-type:circle">catalog/&lt;object&gt;/&lt;id&gt;/delete：删除具有 _id 字段值的特定模型的表单（例如 /catalog/book/584493c1f4887f06c0e67d37/delete）。</li></ul></li></ul><ul id="1f5694d5-ea46-8081-94dc-e030ab208413" class="bulleted-list"><li style="list-style-type:disc">首页和列表页面没有包含任何额外信息，因此他们返回的结果只取决于模型类型和数据库内容，获取信息的查询操作是恒定不变的（类似的，创建对象的代码也没有较大改动）</li></ul><ul id="1f5694d5-ea46-8008-8409-d67a8b4e6105" class="bulleted-list"><li style="list-style-type:disc">与之相反，其他URL是用于处理特定文档/模型实例的，他们会将项目的表示嵌入URL（上文的_id）中，可以用路径参数来提取嵌入的信息，并传递给路由处理器。</li></ul><ul id="1f5694d5-ea46-8063-a5c8-c990f00368a1" class="bulleted-list"><li style="list-style-type:disc">通过在URL中嵌入信息，使得每种类型的所有资源都只需要一个路由（例如，所有图书副本的显示操作都只需要一个路由）</li></ul><p id="1f5694d5-ea46-805a-be55-e1dfce766e0f" class="">
</p><p id="1f5694d5-ea46-8012-aa9e-cd8e24d25afc" class=""><strong>创建路由处理器回调函数：</strong></p><ul id="1f5694d5-ea46-80ed-9c51-e506d229232e" class="bulleted-list"><li style="list-style-type:disc">在定义路由之前，首先需要创建他们将调用的所有虚拟/框架回调函数。这些回调函数将分别存储在Book、BookInstance、Genre、Author的控制器模块中（可以使用任何文件/模块解构。）</li></ul><ul id="1f5694d5-ea46-80b3-a0e3-f126966434ab" class="bulleted-list"><li style="list-style-type:disc">首先在项目根目录下为控制器创建一个文件夹（/controllers），然后为处理每个模型创建独立的控制器文件/模块</li></ul><ul id="1f5694d5-ea46-80a7-8496-ca0c77b34179" class="bulleted-list"><li style="list-style-type:disc">控制器将使用express-async-handler模块，使用npm安装<ul id="1f5694d5-ea46-807e-af2c-c9a15e50e8dc" class="bulleted-list"><li style="list-style-type:circle">npm install express-async-handler</li></ul></li></ul><p id="1f5694d5-ea46-8079-9892-e4c0720b6486" class="">
</p><p id="1f5694d5-ea46-807d-ac46-fa897f583187" class="">【Author控制器】：</p><ul id="1f5694d5-ea46-808e-bb07-d6b4c392e7e6" class="bulleted-list"><li style="list-style-type:disc">写入js文件<ul id="1f5694d5-ea46-8064-ae1b-e8fff1c52e35" class="bulleted-list"><li style="list-style-type:circle">const Author = require(&quot;../models/author&quot;);<br/>const asyncHandler = require(&quot;express-async-handler&quot;);<br/><p id="1f5694d5-ea46-8055-8f12-f6e17f535f8c" class="">// 显示完整的作者列表<br/>exports.author_list = (req, res) =&gt; {<br/>res.send(&quot;未实现：作者列表&quot;);<br/>};<br/></p><p id="1f5694d5-ea46-801e-bef5-d645ec0ad8e1" class="">// 为每位作者显示详细信息的页面<br/>exports.author_detail = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：作者详细信息：&quot; + <br/><a href="http://req.params.id/">req.params.id</a>);<br/>});<br/></p><p id="1f5694d5-ea46-807b-bb8c-c5c4180efc1f" class="">// 由 GET 显示创建作者的表单<br/>exports.author_create_get = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：创建作者的 GET&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8059-8f8e-c3705b964cc7" class="">// 由 POST 处理作者创建操作<br/>exports.author_create_post = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：创建作者的 POST&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8023-b8b5-c95e5e786caa" class="">// 由 GET 显示删除作者的表单<br/>exports.author_delete_get = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：删除作者的 GET&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-80e1-9b0d-fc679c3db351" class="">// 由 POST 处理作者删除操作<br/>exports.author_delete_post = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：删除作者的 POST&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-80fe-8487-dafee168f551" class="">// 由 GET 显示更新作者的表单<br/>exports.author_update_get = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：更新作者的 GET&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-80de-a0b4-c414287fee92" class="">// 由 POST 处理作者更新操作<br/>exports.author_update_post = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：更新作者的 POST&quot;);<br/>});<br/></p></li></ul></li></ul><ul id="1f5694d5-ea46-80af-8956-ecb40605ff0a" class="bulleted-list"><li style="list-style-type:disc">模块首先需要Author模型和asyncHandler包装器（捕获路由处理函数中抛出的任何异常）。然后处理每个URL输出函数。<ul id="1f5694d5-ea46-80ea-af38-d908ba62e34b" class="bulleted-list"><li style="list-style-type:circle">这里创建、更新、删除操作使用的表单，还需要额外的方法来处理表单发布请求。</li></ul></li></ul><ul id="1f5694d5-ea46-80b0-a513-f3576297a57e" class="bulleted-list"><li style="list-style-type:disc">这些函数都是用了上文中处理路由函数中的异常中的封装函数，其参数包括请求、响应、next。函数会响应一个字符串、表示相关页面为创建，如果控制器函数预计会接受路径参数，则会在消息祖父传中输出这些参数</li></ul><ul id="1f5694d5-ea46-8062-809c-e77f27b20b48" class="bulleted-list"><li style="list-style-type:disc">某些路由函数在实现后可能不包含任何可抛出的异常代码，可以使用时将他们改回正常的路由处理器函数</li></ul><p id="1f5694d5-ea46-8028-b57c-fe0cf4203e1f" class="">
</p><p id="1f5694d5-ea46-8016-a7d9-dde9dfc28e4a" class="">【BookInstance控制器】：</p><ul id="1f5694d5-ea46-807c-99df-d6930200d74d" class="bulleted-list"><li style="list-style-type:disc">写入js文件<ul id="1f5694d5-ea46-8010-98d3-f029b73a3b74" class="bulleted-list"><li style="list-style-type:circle">const BookInstance = require(&quot;../models/bookinstance&quot;);<br/>const asyncHandler = require(&quot;express-async-handler&quot;);<br/><p id="1f5694d5-ea46-80f5-a85a-e5d4186a59a1" class="">// 显示所有的 BookInstances<br/>exports.bookinstance_list = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：BookInstance 列表&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8013-aefa-db11e11dc2a9" class="">// 显示特定 BookInstance 的详情页<br/>exports.bookinstance_detail = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(<br/><code>未实现：BookInstance 详情页面：${req.params.id}</code>);<br/>});<br/></p><p id="1f5694d5-ea46-8030-a9b5-f09634f5abd1" class="">// 由 GET 显示创建 BookInstance 的表单<br/>exports.bookinstance_create_get = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：BookInstance 创建 GET&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8074-a06c-db3e1189d9e5" class="">// 由 POST 处理创建 BookInstance<br/>exports.bookinstance_create_post = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：BookInstance 创建 POST&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-802c-a46b-fee4d4f3ac92" class="">// 由 GET 显示删除 BookInstance 的表单<br/>exports.bookinstance_delete_get = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：BookInstance 删除 GET&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-80a2-9759-e0078b884bdc" class="">// 由 POST 删除 BookInstance<br/>exports.bookinstance_delete_post = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：BookInstance 删除 POST&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-80e8-a281-f9ad71042857" class="">// 由 GET 显示更新 BookInstance 的表单<br/>exports.bookinstance_update_get = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：BookInstance 更新 GET&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8053-8922-e7136793bc9d" class="">// 由 POST 处理更新 BookInstance<br/>exports.bookinstance_update_post = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：BookInstance 更新 POST&quot;);<br/>});<br/></p></li></ul></li></ul><p id="1f5694d5-ea46-8064-8cfc-cf6ec711cdf5" class="">
</p><p id="1f5694d5-ea46-802d-9fd8-e0d6290956c0" class="">【Genre控制器】：</p><ul id="1f5694d5-ea46-80c2-bf1f-f272f43fe18e" class="bulleted-list"><li style="list-style-type:disc">写入js文件<ul id="1f5694d5-ea46-8036-8a43-d5d28096d92a" class="bulleted-list"><li style="list-style-type:circle">const genre = require(&quot;../models/genre&quot;);<br/>const asyncHandler = require(&quot;express-async-handler&quot;);<br/><p id="1f5694d5-ea46-80ac-a628-c33b0e1fd418" class="">// 显示所有的流派。<br/>exports.genre_list = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：流派列表&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8040-a9b5-e43c83824b06" class="">// 显示特定流派的详情页。<br/>exports.genre_detail = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(<br/><code>未实现：流派详情页：${req.params.id}</code>);<br/>});<br/></p><p id="1f5694d5-ea46-808d-914b-d522e994b963" class="">// 通过 GET 显示创建流派。<br/>exports.genre_create_get = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：流派创建 GET&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-80aa-be68-e5ed11e0d49e" class="">// 以 POST 方式处理创建流派。<br/>exports.genre_create_post = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：流派创建 POST&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-806b-bef6-f2006ca7aac4" class="">// 通过 GET 显示流派删除表单。<br/>exports.genre_delete_get = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：流派删除 GET&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-807e-ba27-e6146f32fe3f" class="">// 处理 POST 时的流派删除。<br/>exports.genre_delete_post = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：流派删除 POST&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8035-956c-fb84bc4fc522" class="">// 通过 GET 显示流派更新表单。<br/>exports.genre_update_get = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：流派更新 GET&quot;);<br/>});<br/></p><p id="1f5694d5-ea46-8058-8e41-db7311679bc7" class="">// 处理 POST 上的流派更新。<br/>exports.genre_update_post = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;未实现：流派更新 POST&quot;);<br/>});<br/></p></li></ul></li></ul><p id="1f5694d5-ea46-8076-bd27-e56b02dd95e1" class="">
</p><p id="1f5694d5-ea46-802c-b7ac-d1807a463afc" class="">【创建catalog路由模块】</p><ul id="1f5694d5-ea46-80ec-bac7-f98d79045f1a" class="bulleted-list"><li style="list-style-type:disc">为本地图书馆网站创建完整的URL路由<ul id="1f5694d5-ea46-8027-948a-f8942d9e53ca" class="bulleted-list"><li style="list-style-type:circle">项目根目录中有一个/routes文件夹，包含两个路由文件index和users，这里新建一个catalog.js路由文件</li></ul><ul id="1f5694d5-ea46-806f-8fa2-ede1a507ce72" class="bulleted-list"><li style="list-style-type:circle">写入JS代码<ul id="1f5694d5-ea46-80af-b4f4-ee559d5c25b6" class="bulleted-list"><li style="list-style-type:square">const express = require(&quot;express&quot;);<br/>const router = express.Router();<br/><p id="1f5694d5-ea46-8047-b33c-ffec77a565ae" class="">// 导入控制器模块<br/>const book_controller = require(&quot;../controllers/bookController&quot;);<br/>const author_controller = require(&quot;../controllers/authorController&quot;);<br/>const genre_controller = require(&quot;../controllers/genreController&quot;);<br/>const book_instance_controller = require(&quot;../controllers/bookinstanceController&quot;);<br/></p><p id="1f5694d5-ea46-80aa-b391-dfde81333971" class="">/// 图书路由 ///</p><p id="1f5694d5-ea46-808a-9760-c44700146809" class="">// GET 获取图书编目主页<br/>router.get(&quot;/&quot;, book_controller.index);<br/></p><p id="1f5694d5-ea46-808c-bece-fcca11bb0eeb" class="">// GET 请求添加新的图书。注意此项必须位于显示图书的路由（使用了 id）之前。<br/>router.get(&quot;/book/create&quot;, book_controller.book_create_get);<br/></p><p id="1f5694d5-ea46-807d-b576-cbd97ca1623e" class="">// POST 请求添加新的图书<br/>router.post(&quot;/book/create&quot;, book_controller.book_create_post);<br/></p><p id="1f5694d5-ea46-8039-b47d-d4b26c595134" class="">// GET 请求删除图书<br/>router.get(&quot;/book/:id/delete&quot;, book_controller.book_delete_get);<br/></p><p id="1f5694d5-ea46-8037-baf3-e3c7cc5108cf" class="">// POST 请求删除图书<br/>router.post(&quot;/book/:id/delete&quot;, book_controller.book_delete_post);<br/></p><p id="1f5694d5-ea46-802e-ada2-fd4240febcba" class="">// GET 请求更新图书<br/>router.get(&quot;/book/:id/update&quot;, book_controller.book_update_get);<br/></p><p id="1f5694d5-ea46-80af-8664-e3fe8b3ad52f" class="">// POST 请求更新图书<br/>router.post(&quot;/book/:id/update&quot;, book_controller.book_update_post);<br/></p><p id="1f5694d5-ea46-80a7-a0b5-c23984afe708" class="">// GET 请求图书<br/>router.get(&quot;/book/:id&quot;, book_controller.book_detail);<br/></p><p id="1f5694d5-ea46-80e1-bd87-c6bbfe48afa7" class="">// GET 请求完整图书列表<br/>router.get(&quot;/books&quot;, book_controller.book_list);<br/></p><p id="1f5694d5-ea46-8013-9478-edfc03f694f1" class="">/// 作者路由 ///</p><p id="1f5694d5-ea46-802a-9972-d3786327f6dc" class="">// 用于创建作者的 GET 请求。注意这必须在 id 的路由之前（比如说显示作者）<br/>router.get(&quot;/author/create&quot;, author_controller.author_create_get);<br/></p><p id="1f5694d5-ea46-80fb-b62b-dc7d8e424469" class="">// 创建作者的 POST 请求。<br/>router.post(&quot;/author/create&quot;, author_controller.author_create_post);<br/></p><p id="1f5694d5-ea46-8064-bc66-d74d7ee6ab99" class="">// 删除作者的 GET 请求。<br/>router.get(&quot;/author/:id/delete&quot;, author_controller.author_delete_get);<br/></p><p id="1f5694d5-ea46-80a5-8f1f-ca747fcf8395" class="">// POST 请求删除作者。<br/>router.post(&quot;/author/:id/delete&quot;, author_controller.author_delete_post);<br/></p><p id="1f5694d5-ea46-8072-abe3-e35cbb5f9b1f" class="">// 更新作者的 GET 请求。<br/>router.get(&quot;/author/:id/update&quot;, author_controller.author_update_get);<br/></p><p id="1f5694d5-ea46-80a1-a2d5-f55f0132e1ce" class="">// POST 请求更新作者。<br/>router.post(&quot;/author/:id/update&quot;, author_controller.author_update_post);<br/></p><p id="1f5694d5-ea46-8001-b2e4-e5d31f89093e" class="">// 获取一个作者的 GET 请求。<br/>router.get(&quot;/author/:id&quot;, author_controller.author_detail);<br/></p><p id="1f5694d5-ea46-8072-b0a0-e0d01a489029" class="">// 获取所有作者列表的 GET 请求。<br/>router.get(&quot;/authors&quot;, author_controller.author_list);<br/></p><p id="1f5694d5-ea46-8010-97cb-e54e641ef66d" class="">/// 流派路由 ///</p><p id="1f5694d5-ea46-8067-bb87-e0886f120ecb" class="">// 用于创建流派的 GET 请求。注意：这必须在显示流派的路由之前（使用 id 的路由）。<br/>router.get(&quot;/genre/create&quot;, genre_controller.genre_create_get);<br/></p><p id="1f5694d5-ea46-806b-ab71-f2f330364c59" class="">// POST 请求创建 Genre。<br/>router.post(&quot;/genre/create&quot;, genre_controller.genre_create_post);<br/></p><p id="1f5694d5-ea46-80ec-8526-d111b948d434" class="">// 删除流派的 GET 请求。<br/>router.get(&quot;/genre/:id/delete&quot;, genre_controller.genre_delete_get);<br/></p><p id="1f5694d5-ea46-80cf-9682-d673348c9590" class="">// POST 请求删除 Genre。<br/>router.post(&quot;/genre/:id/delete&quot;, genre_controller.genre_delete_post);<br/></p><p id="1f5694d5-ea46-80df-9168-c1029b1d49a9" class="">// 更新流派的 GET 请求。<br/>router.get(&quot;/genre/:id/update&quot;, genre_controller.genre_update_get);<br/></p><p id="1f5694d5-ea46-8078-bf7f-e24a445e2b7b" class="">// 更新流派的 POST 请求。<br/>router.post(&quot;/genre/:id/update&quot;, genre_controller.genre_update_post);<br/></p><p id="1f5694d5-ea46-8022-af33-d7ef98cdca9d" class="">// 获取一个流派的 GET 请求。<br/>router.get(&quot;/genre/:id&quot;, genre_controller.genre_detail);<br/></p><p id="1f5694d5-ea46-8065-b8f2-f2689fcf7baa" class="">// 获取所有流派列表的 GET 请求<br/>router.get(&quot;/genres&quot;, genre_controller.genre_list);<br/></p><p id="1f5694d5-ea46-800c-9bc0-f9a9b0f8ae68" class="">/// BOOKINSTANCE 路由 ///</p><p id="1f5694d5-ea46-800c-92a3-c90ac993319b" class="">// 用于创建 BookInstance 的 GET 请求。注意：这必须在显示 BookInstance 的路由之前（使用 id 的路由）。<br/>router.get(<br/>&quot;/bookinstance/create&quot;,<br/>book_instance_controller.bookinstance_create_get,<br/>);<br/></p><p id="1f5694d5-ea46-80d3-8100-ca9249a64a9c" class="">// 创建 BookInstance 的 POST 请求。<br/>router.post(<br/>&quot;/bookinstance/create&quot;,<br/>book_instance_controller.bookinstance_create_post,<br/>);<br/></p><p id="1f5694d5-ea46-8037-a17e-f9d6d73403be" class="">// 删除 BookInstance 的 GET 请求。<br/>router.post(<br/>&quot;/bookinstance/:id/delete&quot;,<br/>book_instance_controller.bookinstance_delete_get,<br/>);<br/></p><p id="1f5694d5-ea46-80fa-9077-e63639db1d98" class="">// POST 请求删除 BookInstance。<br/>router.post(<br/>&quot;/bookinstance/:id/delete&quot;,<br/>book_instance_controller.bookinstance_delete_post,<br/>);<br/></p><p id="1f5694d5-ea46-80aa-af20-d7937be1dd75" class="">// 更新 BookInstance 的 GET 请求。<br/>router.get(<br/>&quot;/bookinstance/:id/delete&quot;,<br/>book_instance_controller.bookinstance_update_get,<br/>);<br/></p><p id="1f5694d5-ea46-8086-b0fd-d65345371612" class="">// 更新 BookInstance 的 POST 请求。<br/>router.post(<br/>&quot;/bookinstance/:id/update&quot;,<br/>book_instance_controller.bookinstance_update_post,<br/>);<br/></p><p id="1f5694d5-ea46-808b-9f4f-ecd6e6f81a4d" class="">// 一个 BookInstance 的 GET 请求。<br/>router.get(&quot;/bookinstance/:id&quot;, book_instance_controller.bookinstance_detail);<br/></p><p id="1f5694d5-ea46-8096-a907-d9fbed2de340" class="">// GET 请求获取所有 BookInstance 的列表。<br/>router.get(&quot;/bookinstances&quot;, book_instance_controller.bookinstance_list);<br/></p><p id="1f5694d5-ea46-807f-ab78-faf2bfef0be3" class="">module.exports = router;</p></li></ul></li></ul></li></ul><ul id="1f5694d5-ea46-806e-ba1b-d1532a8ce142" class="bulleted-list"><li style="list-style-type:disc">模块导入了express并创建了一个Router对象router，所有路由都设置在router上，最后将其导出</li></ul><ul id="1f5694d5-ea46-80fc-9e1f-d3c16ae77423" class="bulleted-list"><li style="list-style-type:disc">对router对象调用.get（）或.post（）函数即可定义路由。这里所有路径都是用字符串定义（不使用字符串模式或正则表达式）。某些特定资源（例如图书）的路由使用路径参数从URL中获取对象标识</li></ul><p id="1f5694d5-ea46-8088-be5f-dabad25f7009" class="">
</p><p id="1f5694d5-ea46-8076-9ef4-ff788c5e59d2" class=""><strong>更新索引路由模块：</strong></p><ul id="1f5694d5-ea46-80dc-96aa-e71a7981d943" class="bulleted-list"><li style="list-style-type:disc">设置了所有新路径，还有一条路径指向原始页面，需要重定向到catalog路径下创建的新索引页面</li></ul><ul id="1f5694d5-ea46-80be-b251-ea46fa7a7e5d" class="bulleted-list"><li style="list-style-type:disc">修改/routes/index.js中间件<ul id="1f5694d5-ea46-80cc-aa90-e5b48af1528b" class="bulleted-list"><li style="list-style-type:circle">// GET 请求主页<br/>router.get(&quot;/&quot;, (req, res) =&gt; {<br/>res.redirect(&quot;/catalog&quot;);<br/>});<br/></li></ul></li></ul><ul id="1f5694d5-ea46-80a2-a320-c595d484b519" class="bulleted-list"><li style="list-style-type:disc">这是我们第一次使用 redirect() 响应方法。它会使路由重定向到指定的页面，默认发送 HTTP 状态代码“302 Found”。可以根据需要更改返回的状态代码、设置绝对或相对路径。</li></ul><p id="1f5694d5-ea46-8034-8973-d399666794d6" class="">
</p><p id="1f5694d5-ea46-8036-bbab-fb7a46bfc467" class=""><strong>更新app.js：</strong></p><ul id="1f5694d5-ea46-80de-a07d-c73c41e83d70" class="bulleted-list"><li style="list-style-type:disc">在app.js中将路由添加到中间件链<ul id="1f5694d5-ea46-80f3-aa40-f53ab8965d46" class="bulleted-list"><li style="list-style-type:circle">app.js中，在index和users路由下方添加catalog路由<ul id="1f5694d5-ea46-80ce-9f02-fcdb77125c65" class="bulleted-list"><li style="list-style-type:square">const indexRouter = require(&quot;./routes/index&quot;);<br/>const usersRouter = require(&quot;./routes/users&quot;);<br/>const catalogRouter = require(&quot;./routes/catalog&quot;); // 导入 catalog 路由<br/></li></ul></li></ul></li></ul><ul id="1f5694d5-ea46-805f-b36e-ec76c3a55615" class="bulleted-list"><li style="list-style-type:disc">在已定义的路由下方将目录路由添加进中间件栈<ul id="1f5694d5-ea46-8017-aa0f-e2c301756ceb" class="bulleted-list"><li style="list-style-type:circle">app.use(&quot;/&quot;, indexRouter);<br/>app.use(&quot;/users&quot;, usersRouter);<br/>app.use(&quot;/catalog&quot;, catalogRouter); // 将 catalog 路由添加进中间件链<br/></li></ul></li></ul><ul id="1f5694d5-ea46-807b-865e-f2210de59dd3" class="bulleted-list"><li style="list-style-type:disc">我们将图书编目模块添加到了 <code>&#x27;/catalog&#x27;</code> 路径，该路径是 catalog 模块中所有路径的前缀。例如，访问图书列表 的 URL 为：<code>/catalog/books/</code>。</li></ul><p id="1f5694d5-ea46-8076-9dc8-c1b4c180bcef" class="">
</p><p id="1f5694d5-ea46-80ff-a99a-da8194c299e9" class=""><strong>测试路由：</strong></p><ul id="1f5694d5-ea46-8068-9e15-d2016b08d0e5" class="bulleted-list"><li style="list-style-type:disc">首先启动网站<ul id="1f5694d5-ea46-809f-a281-e3d620eaa782" class="bulleted-list"><li style="list-style-type:circle">Windows<p id="1f5694d5-ea46-80a3-bd84-c389bed95a6c" class="">SET DEBUG=express-locallibrary-tutorial:* &amp; npm start</p></li></ul></li></ul><ul id="1f5694d5-ea46-8095-b0db-dece73f307eb" class="bulleted-list"><li style="list-style-type:disc">如果设置过nodemon，则可以使用<ul id="1f5694d5-ea46-80bf-b144-cc142d60b7cd" class="bulleted-list"><li style="list-style-type:circle">DEBUG=express-locallibrary-tutorial:* npm run devstart</li></ul></li></ul><ul id="1f5694d5-ea46-8043-b05f-ee238876882e" class="bulleted-list"><li style="list-style-type:disc">访问一些URL，确保不会受到错误页面404</li></ul><p id="1f6694d5-ea46-80d1-8c63-d188583ffc9e" class="">
</p><p id="1f6694d5-ea46-80fc-8628-ec6dbcdf02b1" class="">
</p><p id="1f6694d5-ea46-8055-9c9a-e605079286af" class=""><strong><span style="border-bottom:0.05em solid">【第四步-呈现图书馆数据】：</span></strong></p><p id="1f6694d5-ea46-80cf-bd9f-e2606e1b4a35" class="">现在准备新增网页，来显示图书馆网站的书本域其他资料，网站包含主页来显示拥有的每个模型的记录数，所有模型的清单和详细信息页面。</p><p id="1f6694d5-ea46-80f6-9b18-e229779f3e0f" class=""><strong>将从数据库中获取记录以及使用模板</strong></p><p id="1f6694d5-ea46-8062-9890-cb6758f027ad" class="">目标：了解如何使用异步模组与Pug样板语言，以及如何从控制器函数中的URL获取信息</p><p id="1f6694d5-ea46-801b-961b-ff3d350f0996" class="">
</p><p id="1f6694d5-ea46-80cd-8024-c771e291b1be" class=""><strong>概览：</strong></p><ul id="1f6694d5-ea46-801c-bb5b-d4b849a5e804" class="bulleted-list"><li style="list-style-type:disc">先前定义了和资料库互动的Mongoose models，并创建了一些图书馆记录。之后创建了图书馆网站需要的所有路由，但仅使用空壳控制器函数（即框架控制器函数，当网页被存取时，指回传一个为实现的信息）</li></ul><ul id="1f6694d5-ea46-802c-aea0-cb2a9fd4ef76" class="bulleted-list"><li style="list-style-type:disc">下一步，为显示图书馆信息的网页，提供适当的实现（聚焦网页表单的实现，创建、更新、删除信息等操作）。包含了更新控制器函数，已利用我们的模型获取记录，定义模板，为用户显示这些信息</li></ul><p id="1f6694d5-ea46-80f7-9249-e2919db9b3eb" class="">
</p><p id="1f6694d5-ea46-80f2-9e52-debb0452174f" class=""><strong><span style="border-bottom:0.05em solid">001-模板入门：</span></strong></p><ul id="1f6694d5-ea46-80b5-ac8f-ca1e912bd7aa" class="bulleted-list"><li style="list-style-type:disc">模板使用该文字档，定义了一个输出档的结构或排版，使用定位符号表示，当目标被绘制时，资料将插入何处（Express中，模板被称为视图）</li></ul><p id="1f6694d5-ea46-80b2-9790-cd1138f090c9" class=""><strong>Express模板选择：</strong></p><ul id="1f6694d5-ea46-8002-b16a-d9a75a86c392" class="bulleted-list"><li style="list-style-type:disc">Express可以与许多不同的模板渲染引擎一起使用，本项目使用Pug作为目标。</li></ul><ul id="1f6694d5-ea46-80c1-bff8-c81105ad4acd" class="bulleted-list"><li style="list-style-type:disc">不同的模板语言使用不同的方法，来定义布局和标记数据的占位符-，一些实用HTML来定义布局，而一些则可以使用编译为HTML的不同标记格式。</li></ul><ul id="1f6694d5-ea46-801c-ae04-f5a79937a8ec" class="bulleted-list"><li style="list-style-type:disc">Pug是第二种类型，使用HTML的表示形式，其中任何行中的第一个单词，通常表示为HTML元素，后续航中的缩进，用于表示嵌套在这些元素中的任何内容，结果时应该页面定义直接转换为HTML。<ul id="1f6694d5-ea46-8015-9287-d7cde7fa29c7" class="bulleted-list"><li style="list-style-type:circle">Pug缺点：对缩进和空格敏感，如果在错误位置添加额外的空格，可能会报错</li></ul></li></ul><p id="1f6694d5-ea46-8098-9468-c5b89c93eb29" class=""><strong>模板组态：</strong></p><ul id="1f6694d5-ea46-800a-a75e-f7db008e2a00" class="bulleted-list"><li style="list-style-type:disc">在创建框架网站时，LocalLibrary配置为使用Pug，Pug模块作为依赖项，包含在网站的package.json文件中，以及app.js文件的一下配置设置。<ul id="1f6694d5-ea46-805b-931a-e538e7010b64" class="bulleted-list"><li style="list-style-type:circle">// View engine setup.<br/>app.set(&quot;views&quot;, path.join(__dirname, &quot;views&quot;));<br/>app.set(&quot;view engine&quot;, &quot;pug&quot;);<br/></li></ul></li></ul><ul id="1f6694d5-ea46-80f4-9125-e9b49ebaccd3" class="bulleted-list"><li style="list-style-type:disc">设置已知，使用pug作为视图引擎，Express应该在/views子目录中搜索模板</li></ul><ul id="1f6694d5-ea46-801f-85e1-d00a0252a8c2" class="bulleted-list"><li style="list-style-type:disc">如果查看views目录，可以看到项目默认视图的.pug文件，这包括需要用自己的内容替换掉index.pug和基本模板layout.pug的视图</li></ul><p id="1f6694d5-ea46-808c-99c3-c5705066b15d" class=""><strong>模板语法：</strong></p><ul id="1f6694d5-ea46-8025-b1ba-dd987a2a261c" class="bulleted-list"><li style="list-style-type:disc">如下示例模板，展示Pug的主要功能</li></ul><ul id="1f6694d5-ea46-8018-9b76-d4d4a46da945" class="bulleted-list"><li style="list-style-type:disc">首先要注意，该我呢见映射典型HTML文件的结构，其中每一行的第一个单词为HTML元素，并且躲进用于指示签到元素。因此，body本文元素位于html元素内，而段落元素p位于body元素内等。非嵌套元素为与不同的行上<ul id="1f6694d5-ea46-80d5-9b65-c68de97153a7" class="bulleted-list"><li style="list-style-type:circle">PUG语法示例<ul id="1f6694d5-ea46-8016-8438-deaf719f4932" class="bulleted-list"><li style="list-style-type:square">html(lang=&quot;en&quot;)<br/>  head<br/>    title= title<br/>    script(type=&#x27;text/javascript&#x27;).<br/>  body<br/>    h1= title<br/><p id="1f6694d5-ea46-8002-a8e3-eaa4f8b85fe9" class="">    p This is a line with #[em some emphasis] and #[strong strong text] markup.<br/>    p This line has un-escaped data: !{&#x27;&lt;em&gt; is emphasised&lt;/em&gt;&#x27;} and escaped data: #{&#x27;&lt;em&gt; is not emphasised&lt;/em&gt;&#x27;}.<br/>  | This line follows on.<br/>    p= &#x27;Evaluated and &lt;em&gt;escaped expression&lt;/em&gt;:&#x27; + title<br/><br/>&lt;!-- You can add HTML comments directly --&gt;<br/>// You can add single line JavaScript comments and they are generated to HTML comments<br/>//- Introducing a single line JavaScript comment with &quot;//-&quot; ensures the comment isn&#x27;t rendered to HTML<br/><br/>    p A line with a link<br/>      a(href=&#x27;/catalog/authors&#x27;) Some link text<br/>  |  and some extra text.<br/><br/>#container.col<br/>      if title<br/>          p A variable named &quot;title&quot; exists.<br/>  else<br/>    p A variable named &quot;title&quot; does not exist.<br/>  p.<br/>    Pug is a terse and simple template language with a<br/>    strong focus on performance and powerful features.<br/><br/>h2 Generate a list<br/><br/>ul<br/>  each val in [1, 2, 3, 4, 5]<br/>    li= val<br/></p></li></ul></li></ul></li></ul><ul id="1f6694d5-ea46-8043-ab0e-e5f18a0fa648" class="bulleted-list"><li style="list-style-type:disc">元素属性被定义在其关联元素之后的括号中，在括号内，属性定义在以逗号或空格分隔的属性名称和属性值对的列表中，例如<ul id="1f6694d5-ea46-8023-b099-f8b97cb89a40" class="bulleted-list"><li style="list-style-type:circle"><code>script(type=&#x27;text/javascript&#x27;)</code>, <code>link(rel=&#x27;stylesheet&#x27;, href=&#x27;/stylesheets/style.css&#x27;)</code></li></ul><ul id="1f6694d5-ea46-806f-b411-fbd6d30f2245" class="bulleted-list"><li style="list-style-type:circle"> <code>meta(name=&#x27;viewport&#x27; content=&#x27;width=device-width initial-scale=1&#x27;)</code></li></ul></li></ul><ul id="1f6694d5-ea46-80b4-a1b8-edd2186d7450" class="bulleted-list"><li style="list-style-type:disc">所有属性的值都被转义，例如&gt;等字符转换为HTML代码等效项，如&amp;gt；</li></ul><ul id="1f6694d5-ea46-800a-a73f-f946abc0d869" class="bulleted-list"><li style="list-style-type:disc">如果标记后跟着等号，则一下文本被视为JS表达式，例如h1标记的内容是标题变量title（在文件中定义，或从Express传递到模板中），第二行中段落内容与标题变量title连接的文本字符串，这两种情况下，默认行为是转义该行<ul id="1f6694d5-ea46-8010-8306-f6e0163f1ad7" class="bulleted-list"><li style="list-style-type:circle">h1= title<br/>p= &#x27;Evaluated and &lt;em&gt;escaped expression&lt;/em&gt;:&#x27; + title<br/></li></ul></li></ul><ul id="1f6694d5-ea46-8071-9b2d-c7d45b3331fe" class="bulleted-list"><li style="list-style-type:disc">如果标记后面没有灯号，则将内容视为纯文本，在纯文本中，可以使用#{}和！{}语法，插入转义和肺转移数据，如下所示，可以在纯文本中添加原始HTML<ul id="1f6694d5-ea46-80f8-9dfc-d49b85e4e148" class="bulleted-list"><li style="list-style-type:circle">p This is a line with #[em some emphasis] and #[strong strong text] markup.<br/>p This line has an un-escaped string: !{&#x27;&lt;em&gt; is emphasised&lt;/em&gt;&#x27;}, an escaped string: #{&#x27;&lt;em&gt; is not emphasised&lt;/em&gt;&#x27;}, and escaped variables: #{title}.<br/></li></ul></li></ul><ul id="1f6694d5-ea46-8016-9f9a-d2168a4ff74a" class="bulleted-list"><li style="list-style-type:disc">转义来自用户的数据，使用#{}语法</li></ul><ul id="1f6694d5-ea46-803d-906c-d654f4d4951f" class="bulleted-list"><li style="list-style-type:disc">可信任的数据（例如，生成的记录计数等）可以不转义就显示</li></ul><ul id="1f6694d5-ea46-80e5-badd-e4f76845fa9b" class="bulleted-list"><li style="list-style-type:disc">可以在行的开头使用管道“|”字符来表示纯文本，例如下面显示的附加文本，见显示在前一个锚点相同的行上，但不会链接<ul id="1f6694d5-ea46-8046-933d-c9d6f72d579d" class="bulleted-list"><li style="list-style-type:circle">a(href=&#x27;<a href="http://someurl/">http://someurl/</a>&#x27;) Link text<br/>| Plain text<br/></li></ul></li></ul><ul id="1f6694d5-ea46-8040-92a6-eec4c7912235" class="bulleted-list"><li style="list-style-type:disc">Pug允许使用if、else、else if和unless执行条件操作，例如<ul id="1f6694d5-ea46-807c-9417-f3a1d75432c8" class="bulleted-list"><li style="list-style-type:circle">if title<br/>    p A variable named &quot;title&quot; exists<br/>else<br/>    p A variable named &quot;title&quot; does not exist<br/></li></ul></li></ul><ul id="1f6694d5-ea46-80d6-af96-d14c43fc2021" class="bulleted-list"><li style="list-style-type:disc">以使用each-in或while语法执行循环/迭代操作。例如循环遍历数组，来显示变量列表（主页，使用“li =”来评估val，作为下面的变量）迭代的值也可以传递给模板作为变量<ul id="1f6694d5-ea46-80d9-a7aa-c8afa15db9a8" class="bulleted-list"><li style="list-style-type:circle">ul<br/>    each val in [1, 2, 3, 4, 5]<br/>        li= val<br/></li></ul></li></ul><ul id="1f6694d5-ea46-80ac-af2e-cbc47cde481e" class="bulleted-list"><li style="list-style-type:disc">语法支持注释（可以在输出中呈现、可选）、支持mixins创建可以重用的代码块、case语法等功能</li></ul><p id="1f6694d5-ea46-8040-9d05-cf081fe9fbcf" class=""><strong>扩展模板：</strong></p><ul id="1f6694d5-ea46-8096-ae41-fb28bd60a1d3" class="bulleted-list"><li style="list-style-type:disc">在站点中，通常所有页面都有一个共同的结构，包括首页、页脚、导航等标准的HTML标记。Pug允许声明应该基本模板，然后扩展他，只替换每个特定页面不同的地方<ul id="1f6694d5-ea46-8061-a13d-f8dc3be4e3d4" class="bulleted-list"><li style="list-style-type:circle">例如，在框架项目中，创建的基本模板layout.pug，<ul id="1f6694d5-ea46-80a1-8d2a-d3af34594158" class="bulleted-list"><li style="list-style-type:square">doctype html<br/>html<br/>    head<br/>        title= title<br/>        link(rel=&#x27;stylesheet&#x27;, href=&#x27;/stylesheets/style.css&#x27;)<br/>    body<br/>        block content<br/></li></ul></li></ul></li></ul><ul id="1f6694d5-ea46-807b-a8ec-cdc8513d70be" class="bulleted-list"><li style="list-style-type:disc">块标记block用于标记可在派生模板中替换的内容不符，如果未重新定义快，则使用其在基类中的实现</li></ul><ul id="1f6694d5-ea46-807a-85ca-c25e4b055aab" class="bulleted-list"><li style="list-style-type:disc">默认的index.pug（为框架项目所创建），显示了我们如何覆盖基本模板，extends标记，表示要使用的基本模板，然后我们使用block section_name，来知识要覆盖的部分新内容<ul id="1f6694d5-ea46-805b-8fab-cdca58055f81" class="bulleted-list"><li style="list-style-type:circle">extends layout<p id="1f6694d5-ea46-80ab-b03b-de7d775a0b12" class="">block content<br/>    h1= title<br/>    p Welcome to #{title}<br/></p></li></ul></li></ul><p id="1f6694d5-ea46-8089-8c2d-c53166bc6943" class=""><strong><span style="border-bottom:0.05em solid">002-本地图书馆基础模板：</span></strong></p><ul id="1f6694d5-ea46-80f1-a8c5-f2d64d4febbc" class="bulleted-list"><li style="list-style-type:disc">了解Pug如何拓展模板。就图书馆项目，创建一个基础模板，这个目标会有一个侧边栏，连接到本教程中要创建的各个页面（例如，书本、种类、作者等等），以及一个主要内容区域，我们将在每个页面中进行覆写</li></ul><ul id="1f6694d5-ea46-8009-bcd3-dba80b14a58d" class="bulleted-list"><li style="list-style-type:disc">开启/views/layout.pug，并以下列代码置换其内容<ul id="1f6694d5-ea46-80d0-a1f0-f643cbe75042" class="bulleted-list"><li style="list-style-type:circle">doctype html<br/>html(lang=&#x27;en&#x27;)<br/>head<br/>title= title<br/>meta(charset=&#x27;utf-8&#x27;)<br/>meta(name=&#x27;viewport&#x27;, content=&#x27;width=device-width, initial-scale=1&#x27;)<br/>link(rel=&#x27;stylesheet&#x27;, href=&#x27;<br/><a href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css</a>&#x27;)<br/>script(src=&#x27;<br/><a href="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js">https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js</a>&#x27;)<br/>script(src=&#x27;<br/><a href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js">https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js</a>&#x27;)<br/>link(rel=&#x27;stylesheet&#x27;, href=&#x27;/stylesheets/style.css&#x27;)<br/>body<br/>div(class=&#x27;container-fluid&#x27;)<br/>div(class=&#x27;row&#x27;)<br/>div(class=&#x27;col-sm-2&#x27;)<br/>block sidebar<br/>ul(class=&#x27;sidebar-nav&#x27;)<br/>li<br/>a(href=&#x27;/catalog&#x27;) Home<br/>li<br/>a(href=&#x27;/catalog/books&#x27;) All books<br/>li<br/>a(href=&#x27;/catalog/authors&#x27;) All authors<br/>li<br/>a(href=&#x27;/catalog/genres&#x27;) All genres<br/>li<br/>a(href=&#x27;/catalog/bookinstances&#x27;) All book-instances<br/>li<br/>hr<br/>li<br/>a(href=&#x27;/catalog/author/create&#x27;) Create new author<br/>li<br/>a(href=&#x27;/catalog/genre/create&#x27;) Create new genre<br/>li<br/>a(href=&#x27;/catalog/book/create&#x27;) Create new book<br/>li<br/>a(href=&#x27;/catalog/bookinstance/create&#x27;) Create new book instance (copy)<br/></li></ul><p id="1f6694d5-ea46-80ee-a1fc-f57812cb00a0" class="">      div(class=&#x27;col-sm-10&#x27;)<br/>        block content<br/></p></li></ul><ul id="1f6694d5-ea46-80e6-bc58-ec53b025db1d" class="bulleted-list"><li style="list-style-type:disc">此模板使用Bootstrap布局。</li></ul><ul id="1f6694d5-ea46-8094-9b98-d250cabb8ded" class="bulleted-list"><li style="list-style-type:disc">使用block content当作定位符号，放到页面内容将放置的地方</li></ul><ul id="1f6694d5-ea46-8051-affb-d1bb9cfc18e4" class="bulleted-list"><li style="list-style-type:disc">基础模板参考了本地css，提供了额外的样式在/public/stylesheets/style.css<ul id="1f6694d5-ea46-8024-b0a5-f1194df0f861" class="bulleted-list"><li style="list-style-type:circle">.sidebar-nav {<br/>margin-top: 20px;<br/>padding: 0;<br/>list-style: none;<br/>}<br/></li></ul></li></ul><p id="1f6694d5-ea46-8002-b43e-f44fe3a81ed4" class=""><strong><span style="border-bottom:0.05em solid">003-主页：</span></strong></p><ul id="1f6694d5-ea46-804a-9835-c2083634a76b" class="bulleted-list"><li style="list-style-type:disc">创建第一个页面是网站的主页面，网站的根目录/或者catalog的根目录访问，这会呈现一些网站的静态文字描述，以及动态计算数据库中不同记录类型的技术</li></ul><ul id="1f6694d5-ea46-80d9-b0ee-d547ea0bb742" class="bulleted-list"><li style="list-style-type:disc">先前为主页创建了路由，为例完成页面需要更新控制器函数，在数据库中提取记录的技术，并创建一个可用于呈现页面的视图（模板）</li></ul><p id="1f6694d5-ea46-8029-b01d-d317207d9be9" class=""><strong>路由：</strong></p><ul id="1f6694d5-ea46-80d2-ac0b-e4669d2f7e0d" class="bulleted-list"><li style="list-style-type:disc">先前创建类索引页的路由，所有路由函数定义在/routes/catalog.js中<ul id="1f6694d5-ea46-80df-bd57-f9144865fde3" class="bulleted-list"><li style="list-style-type:circle">router.get(&quot;/&quot;, book_controller.index); // 实际上，它映射到 /catalog/，因为我们导入路由时使用了 /catalog 前缀</li></ul></li></ul><ul id="1f6694d5-ea46-8099-84bd-c849fe5f7afd" class="bulleted-list"><li style="list-style-type:disc">在/controllers/bookController.js中，定义回调函数参数（book_controller.index）<ul id="1f6694d5-ea46-80fa-85d4-eaf41b4a8f11" class="bulleted-list"><li style="list-style-type:circle">exports.index = asyncHandler（async （req、res、next）⇒{<ul id="1f6694d5-ea46-8066-929c-e2ef0664ff19" class="bulleted-list"><li style="list-style-type:square">res.send（“NOT IMPLEMENTED: SITE HOME PAGE”）；</li></ul></li></ul><ul id="1f6694d5-ea46-80c9-be0f-fde39612507f" class="bulleted-list"><li style="list-style-type:circle">}）；</li></ul><ul id="1f6694d5-ea46-80a7-9127-fb57e6b11719" class="bulleted-list"><li style="list-style-type:circle">扩展这个控制器函数，从我们的模型中获取信息，然后使用模板（视图）渲染它</li></ul></li></ul><p id="1f6694d5-ea46-8011-9d69-f04158892741" class=""><strong>控制器：</strong></p><ul id="1f6694d5-ea46-8038-be48-fb615209dce6" class="bulleted-list"><li style="list-style-type:disc">索引控制器函数需要获取一下有关信息，即数据库有多少Book、BookInstance，可用的BookInstance、Author、Genre记录，这些数据渲染到模板中，来创建HTML页面，然后将其返回到HTTP响应中。</li></ul><ul id="1f6694d5-ea46-80e3-9daf-d56ba531824e" class="bulleted-list"><li style="list-style-type:disc">打开/controllers/bookController.js，在文件顶部，可以看到导出的index（）函数<ul id="1f6694d5-ea46-80b1-bbe8-f1c90d9fb337" class="bulleted-list"><li style="list-style-type:circle">const Book = require(&quot;../models/book&quot;);<br/>const asyncHandler = require(&quot;express-async-handler&quot;);<br/><p id="1f6694d5-ea46-80ea-a8dd-da74f12a8ba5" class="">exports.index = asyncHandler(async (req, res, next) =&gt; {<br/>res.send(&quot;NOT IMPLEMENTED: Site Home Page&quot;);<br/>});<br/></p></li></ul></li></ul><ul id="1f6694d5-ea46-8052-9aaa-dac563c8572b" class="bulleted-list"><li style="list-style-type:disc">使用以下代码来替换上述片段，第一步是导入require（）所有模型。将使用他们来获取记录的技术，代码同样需要express-async-handler，可以捕获路由处理器函数抛出的异常<ul id="1f6694d5-ea46-803c-8a91-cc85bc973918" class="bulleted-list"><li style="list-style-type:circle">const Book = require(&quot;../models/book&quot;);<br/>const Author = require(&quot;../models/author&quot;);<br/>const Genre = require(&quot;../models/genre&quot;);<br/>const BookInstance = require(&quot;../models/bookinstance&quot;);<br/><p id="1f6694d5-ea46-80a4-bc95-fc61f98c085c" class="">const asyncHandler = require(&quot;express-async-handler&quot;);</p><p id="1f6694d5-ea46-80c6-9585-d437d2e9950c" class="">exports.index = asyncHandler(async (req, res, next) =&gt; {<br/>// 并行获取书的详细信息、书实例、作者和体裁的数量<br/>const [<br/>numBooks,<br/>numBookInstances,<br/>numAvailableBookInstances,<br/>numAuthors,<br/>numGenres,<br/>] = await Promise.all([<br/>Book.countDocuments({}).exec(),<br/>BookInstance.countDocuments({}).exec(),<br/>BookInstance.countDocuments({ status: &quot;Available&quot; }).exec(),<br/>Author.countDocuments({}).exec(),<br/>Genre.countDocuments({}).exec(),<br/>]);<br/></p><p id="1f6694d5-ea46-801c-bd8d-db4d961f2cf3" class="">res.render(&quot;index&quot;, {<br/>title: &quot;Local Library Home&quot;,<br/>book_count: numBooks,<br/>book_instance_count: numBookInstances,<br/>book_instance_available_count: numAvailableBookInstances,<br/>author_count: numAuthors,<br/>genre_count: numGenres,<br/>});<br/>});<br/></p></li></ul><ul id="1f6694d5-ea46-803f-a6a8-fa1c41a43bc4" class="bulleted-list"><li style="list-style-type:circle">使用countDocuments（）Fangf来获取每个模型的实例个数，在模型上调用盖房啊，并使用一组可选的条件进行匹配，然后返回一个Query对象，紧接着我们可以调用exex（）来进行查询操作，其返回一个Promise对象，该Promise对象要么兑现结果，要么再出现数据库错误时被拒绝</li></ul><ul id="1f6694d5-ea46-804d-9286-d1e8ce03a571" class="bulleted-list"><li style="list-style-type:circle">因为对文档数量查询的操作时独立的，使用Promise.all（），来运行这些查询请求，该方法返回一个新的Promise，因此我们使用await来等待其完成（即此函数的执行会在await处阻塞），当所有查询完成时，all（）Fanhuidepromise会兑现，便会继续执行路由处理函数，并使用数据库查询的结果填充数组</li></ul><ul id="1f6694d5-ea46-8027-aa29-f5d58f69bf5f" class="bulleted-list"><li style="list-style-type:circle">成功后，回调函数调用res.render（），指定index视图，以及一个对象包含了要插入其中的数据（这包括我们模型计数的结果对象）。数据以键值对形式提供，可以使用键在模板中访问</li></ul></li></ul><ul id="1f6694d5-ea46-809c-ade5-c575bd551a45" class="bulleted-list"><li style="list-style-type:disc">代码简单，是因为可以假设数据库查询成功，如果任何操作失败，抛出的一场会被asyncHandler（）捕获然后传递给链中的下一个next中间件处理器</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f6694d5-ea46-8071-82f0-fe63442dec43"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f6694d5-ea46-8021-8fd1-f91b865db1af" class="">Pug模板中，如果使用了为传入的键或变量，它将被渲染为空字符串，并且会在表达式中被求值为false，而其他的模板语言可能会要求你为所使用的所有对象传递值</p></div></figure><p id="1f6694d5-ea46-8099-a8b2-d733e3862bce" class=""><strong>视图：</strong></p><ul id="1f6694d5-ea46-80bb-a96f-ead52b404354" class="bulleted-list"><li style="list-style-type:disc">打开/views/index.pug，使用如下代码替换内容<ul id="1f6694d5-ea46-8046-9132-ff9dcb80b9bc" class="bulleted-list"><li style="list-style-type:circle">extends layout<p id="1f6694d5-ea46-80c4-8a2c-d1216d2cc375" class="">block content<br/>h1= title<br/>p Welcome to #[em LocalLibrary], a very basic Express website developed as a tutorial example on the Mozilla Developer Network.<br/></p><p id="1f6694d5-ea46-8050-9cec-eaa8335b1b9f" class="">h1 Dynamic content</p><p id="1f6694d5-ea46-80d6-a327-d82472405ba0" class="">p The library has the following record counts:</p><p id="1f6694d5-ea46-80d9-bd25-cc337f4ee019" class="">ul<br/>li #[strong Books:] !{book_count}<br/>li #[strong Copies:] !{book_instance_count}<br/>li #[strong Copies available:] !{book_instance_available_count}<br/>li #[strong Authors:] !{author_count}<br/>li #[strong Genres:] !{genre_count}<br/></p></li></ul></li></ul><ul id="1f6694d5-ea46-80a0-9ca1-d663deccb6f2" class="bulleted-list"><li style="list-style-type:disc">这个视图很简单，扩展了layout.pug基本模板，涵盖了名为content的模块block。第一个h1标题。将是传递给render（）函数的title变量的转移文本-请注意‘h1=’的使用方式使得接下来文本，被视为JS表达式，然后放入一个介绍本项目的段落</li></ul><ul id="1f6694d5-ea46-8057-9777-f9c1e21ddefc" class="bulleted-list"><li style="list-style-type:disc">在动态内容标题下，我们检查从render（）函数传入的错误变量，是否已定义，如果是，则列出这个错误，否，则从data变量中，获取并列出每个模型的副本数量</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f6694d5-ea46-80fb-8dc2-f5dba111b1ca"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f6694d5-ea46-8014-9153-ca5fa071e77c" class="">没有转义计数值（i.e我们使用！{}语法），因为计数值已经被计算过，如果信息是由终端用户提供的，我们会转义该变量，用于显示</p></div></figure><p id="1f6694d5-ea46-805d-8f00-dd973da9293e" class=""><strong>显示结果如下</strong></p><figure id="1f6694d5-ea46-8031-83af-d57acdd9a1df" class="image"><a href="image%205.png"><img style="width:561.1875px" src="image%205.png"/></a></figure><ul id="1f6694d5-ea46-8090-bf5e-d61699c5b491" class="bulleted-list"><li style="list-style-type:disc">无法使用侧边栏链接，因为这些网页的网址，视图、模板尚未定义。</li></ul><p id="1f6694d5-ea46-80fc-89a4-c38fb7982b59" class=""><strong><span style="border-bottom:0.05em solid">004-书本列表页面：</span></strong></p><ul id="1f6694d5-ea46-8085-b9d0-cfa600188814" class="bulleted-list"><li style="list-style-type:disc">接下来实现书本列表页面，这个页面需要呈现数据库中所有书本的列表，包含每本书的作者、标题，标题将成为一个链接，连接到书本详细内容页面</li></ul><p id="1f6694d5-ea46-80ee-9910-dbdb9e8d6d2d" class=""><strong>控制器：</strong></p><ul id="1f6694d5-ea46-8012-a01d-d3833d42aeba" class="bulleted-list"><li style="list-style-type:disc">书本列表控制器函数需要获取数据库中所有的Book对象的列表，对它们进行排序，然后将他们给模板进行渲染</li></ul><ul id="1f6694d5-ea46-8063-8d14-f9088bc79400" class="bulleted-list"><li style="list-style-type:disc">打开/controllers/bookController.js，找到导出的book_list控制器方法，并替换为下面的代码<ul id="1f6694d5-ea46-809c-8695-cec9fdbcd158" class="bulleted-list"><li style="list-style-type:circle">// 呈现数据库中所有书本的列表<br/>exports.book_list = asyncHandler(async (req, res, next) =&gt; {<br/>const allBooks = await Book.find({}, &quot;title author&quot;)<br/>.sort({ title: 1 })<br/>.populate(&quot;author&quot;)<br/>.exec();<br/><p id="1f6694d5-ea46-8075-ae74-e1b77c40e10b" class="">res.render(&quot;book_list&quot;, { title: &quot;Book List&quot;, book_list: allBooks });<br/>});<br/></p></li></ul></li></ul><p id="1f6694d5-ea46-80cc-a69c-edc22031174c" class=""><strong>视图：</strong></p><ul id="1f6694d5-ea46-803e-8027-e017141330c1" class="bulleted-list"><li style="list-style-type:disc">创建/views/book_list.pug并写入一下内容<ul id="1f6694d5-ea46-8020-aa3a-f240defc3325" class="bulleted-list"><li style="list-style-type:circle">extends layout<p id="1f6694d5-ea46-8079-8cbb-cef47f2c5e98" class="">block content<br/>h1= title<br/>if book_list.length<br/>ul<br/>each book in book_list<br/>li<br/>a(href=book.url) #{book.title}<br/>|  (#{<br/><a href="http://book.author.name/">book.author.name</a>})</p><p id="1f6694d5-ea46-809a-a6b7-fa8471c7f5b7" class="">else<br/>p There are no books.<br/></p></li></ul></li></ul><ul id="1f6694d5-ea46-8003-87ee-feb11438287f" class="bulleted-list"><li style="list-style-type:disc">视图扩展了layout.pug基本模板，并覆盖了名为content的区块（block），他先是了我们从控制器传入的标题title（使用render（）方法），然后使用each-in语法变量book_list变量，为每本书创建一个列表项，来显示书名、并作为书的详细信息页面的链接，后面跟着作者姓名，如果book_list页面没有书，则执行else字句，并显示文本there are no books</li></ul><ul id="1f6694d5-ea46-804d-9902-dbcc7a532058" class="bulleted-list"><li style="list-style-type:disc">每本书被定义为两行，第二行使用管道，这种方法是必要的，因为如果作者姓名位于上一行，他将成为连接的一部分</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f6694d5-ea46-80c8-a8b4-cfdbf243bfcd"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f6694d5-ea46-801d-a4c1-eb446fdd9545" class="">使用book.ur为每本书提供详细记录的链接（我们已经实现了此路由，并未实现此页面），这是Book模型的悉尼属性，它使用模型实例的_id字段，生成唯一的URL路径</p></div></figure><p id="1f6694d5-ea46-8065-8539-cd90ddcd310a" class=""><strong>显示结果如下：</strong></p><figure id="1f6694d5-ea46-8002-91e6-c6b02fbb492e" class="image"><a href="image%206.png"><img style="width:561.1875px" src="image%206.png"/></a></figure><p id="1f6694d5-ea46-80f3-8201-c34e28ec7c75" class=""><strong><span style="border-bottom:0.05em solid">004-书本实例列表页面：</span></strong></p><ul id="1f6694d5-ea46-80fa-8b7c-ec94992395ce" class="bulleted-list"><li style="list-style-type:disc">接下来实现图书馆中的所有书本实例BookInstance的列表页面，这个页面需要包含与每个BookInstance（链接到其详细信息页面）关联的书本Book标题，以及BookInstance模型中的其他信息，包含每个副本的状态、下述品牌、唯一ID。唯一ID的文本应该链接到BookInstance详细信息页面</li></ul><p id="1f6694d5-ea46-804b-938c-d59b57d49367" class=""><strong>控制器：</strong></p><ul id="1f6694d5-ea46-80e7-8f12-e61efae91fe5" class="bulleted-list"><li style="list-style-type:disc">BookInstance列表控制器函数需要获取所有书本实例的列表，填充关联的书本信息，然后将列表传递给模板进行渲染</li></ul><ul id="1f6694d5-ea46-8080-8c43-ea1a8fd0632c" class="bulleted-list"><li style="list-style-type:disc">打开/controllers/bookinstanceController.js，找到导出的bookinstance_list（）控制器方法没使用下面代码替换<ul id="1f6694d5-ea46-804c-92b8-d8922b2585f4" class="bulleted-list"><li style="list-style-type:circle">// 呈现所有书本实例（BookInstance）的列表<br/>exports.bookinstance_list = asyncHandler(async (req, res, next) =&gt; {<br/>const allBookInstances = await BookInstance.find().populate(&quot;book&quot;).exec();<br/><p id="1f6694d5-ea46-8002-b8dc-d8bb1154e30d" class="">res.render(&quot;bookinstance_list&quot;, {<br/>title: &quot;Book Instance List&quot;,<br/>bookinstance_list: allBookInstances,<br/>});<br/>});<br/></p></li></ul></li></ul><ul id="1f6694d5-ea46-80b0-a896-f6665dd040fb" class="bulleted-list"><li style="list-style-type:disc">路由处理器调用BookInstance模型的find（）函数，然后链式调用populate（）函数，并将book字段作为参数传递-将用完整的Book文档替换每个BookInstance对象中的书本ID，最后在链式调用的末尾调回用exec（）函数来执行查询操作并返回一个Promise</li></ul><ul id="1f6694d5-ea46-8017-8c3e-ee8e159182b4" class="bulleted-list"><li style="list-style-type:disc">路由处理器使用await关键字来等待Promise对象，直至Promise对象被解决才会执行后续代码，如果Promise对象被兑现，查询结果被保存到allBookInstances变量中，然后路由器继续执行，</li></ul><ul id="1f6694d5-ea46-8059-be6f-eb9edacbeb71" class="bulleted-list"><li style="list-style-type:disc">代码最后的部分调用render（）函数，指定bookinstance_list（.pug）模板，并将title和bookinstance_list的值传递到模板中</li></ul><p id="1f6694d5-ea46-80fa-bd34-cc294a5b7e2e" class=""><strong>视图：</strong></p><ul id="1f6694d5-ea46-80e7-9995-c4eaf18ab766" class="bulleted-list"><li style="list-style-type:disc">创建/views/bookinstance_list.pug，并复制粘贴下面的文本<ul id="1f6694d5-ea46-8044-ac8b-f99cb98fcb39" class="bulleted-list"><li style="list-style-type:circle">extends layout<p id="1f6694d5-ea46-806f-8c2e-e45c81f9062c" class="">block content<br/>h1= title<br/></p><p id="1f6694d5-ea46-80ea-b8a5-f8dd680d240f" class="">if bookinstance_list.length<br/>ul<br/>each val in bookinstance_list<br/>li<br/>a(href=val.url) #{val.book.title} : #{val.imprint} - <br/>if val.status==&#x27;Available&#x27;<br/>span.text-success #{val.status}<br/>else if val.status==&#x27;Maintenance&#x27;<br/>span.text-danger #{val.status}<br/>else<br/>span.text-warning #{val.status}<br/>if val.status!=&#x27;Available&#x27;<br/>span  (Due: #{val.due_back} )<br/></p><p id="1f6694d5-ea46-809d-80e0-edc7d80e3307" class="">else<br/>p There are no book copies in this library.<br/></p></li></ul></li></ul><ul id="1f6694d5-ea46-8034-a976-c404d52c4890" class="bulleted-list"><li style="list-style-type:disc">这个视图相似于其他视图，扩展了布局，替换了内容content区块，显示了从控制器传入的标题title，病变理论bookinstance_list中的所有书籍副本，对于每个副本，我们都会显示他的状态（使用颜色编码），如果书本book不可以，则显示其预期返回日期，这里引入了一个新特性-可以在标签之后使用点符号标识符来指定一个类别。这里的span.text-success将被编译为&lt;span class = ‘text-success’&gt;（也可以使用Pu改变写为span（class = ”text-success“））</li></ul><p id="1f6694d5-ea46-80d4-abf0-c08f78d100a5" class=""><strong>结果显示如下：</strong></p><figure id="1f6694d5-ea46-8076-a0fb-c80496e38b2b" class="image"><a href="image%207.png"><img style="width:561.1875px" src="image%207.png"/></a></figure><p id="1f6694d5-ea46-805f-96d0-f705ff43a12f" class=""><strong><span style="border-bottom:0.05em solid">005-使用luxon做日期格式化：</span></strong></p><ul id="1f6694d5-ea46-80d1-ac68-f524c3851a74" class="bulleted-list"><li style="list-style-type:disc">模型默认的日期呈现为：<em>Fri Apr 10 2020 12:49:58 GMT+0800 (中国标准时间)</em>。</li></ul><ul id="1f6694d5-ea46-806f-b3d4-d3676b50a08c" class="bulleted-list"><li style="list-style-type:disc">本节中展示如何在BookInstance模型中更友好的格式显示日期：2025 年 5 月 17 日</li></ul><ul id="1f6694d5-ea46-80a4-9ce5-c3c45f98518e" class="bulleted-list"><li style="list-style-type:disc">使用方法是在BookInstance模型中创建一个返回格式化日期的虚拟属性，使用luxon来格式化，这是应该JS日期库，用于解析、验证、操作、格式化、本地化日期</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f6694d5-ea46-800b-9e9c-dc086617ff04"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f6694d5-ea46-8092-a752-fda52bd35188" class="">可以直接在Pug模板中使用luxon格式化字符串，也可以在其他地方格式化字符串，使用虚拟属性允许与当前获取due_date完全相同的方式获取格式化日期</p></div></figure><p id="1f6694d5-ea46-803a-a43e-db256b3b9f0a" class=""><strong>安装luxon：</strong></p><ul id="1f6694d5-ea46-80ba-ab80-e1978df22c75" class="bulleted-list"><li style="list-style-type:disc">项目根目录输入命令<ul id="1f6694d5-ea46-8098-af50-ced0b78655f3" class="bulleted-list"><li style="list-style-type:circle">npm install luxon</li></ul></li></ul><p id="1f6694d5-ea46-807d-b15c-c5bfe25a4af8" class=""><strong>创建虚拟属性：</strong></p><ul id="1f6694d5-ea46-80e7-ae19-c207b609c56a" class="bulleted-list"><li style="list-style-type:disc">打开/models/bookinstance.js，</li></ul><ul id="1f6694d5-ea46-802d-853e-f9e22c0bcecd" class="bulleted-list"><li style="list-style-type:disc">在文件最上方引入luxon<ul id="1f6694d5-ea46-803a-8ae6-c210934b73dd" class="bulleted-list"><li style="list-style-type:circle">const {DateTime} = require(”luxon”)</li></ul></li></ul><ul id="1f6694d5-ea46-801e-b705-ee1404553f0c" class="bulleted-list"><li style="list-style-type:disc">在URL属性后面加入虚拟属性due_back_formatted<ul id="1f6694d5-ea46-80d0-bdc5-c2b780b93546" class="bulleted-list"><li style="list-style-type:circle">BookInstanceSchema.virtual(&quot;due_back_formatted&quot;).get(function () {<br/>return DateTime.fromJSDate(this.due_back).toLocaleString(DateTime.DATE_MED);<br/>});<br/></li></ul></li></ul><p id="1f6694d5-ea46-802c-9715-ece5091cd09d" class=""><strong>更新视图：</strong></p><ul id="1f6694d5-ea46-807a-98d9-fb8afdcf1140" class="bulleted-list"><li style="list-style-type:disc">打开/views/bookinstance_list.pug，然后用due_back_formatted取代due_back<ul id="1f6694d5-ea46-80df-a1c9-ca45330e8570" class="bulleted-list"><li style="list-style-type:circle">if val.status != &#x27;Available&#x27;<br/>//span  (Due: #{val.due_back} )<br/>span  (Due: #{val.due_back_formatted} )<br/></li></ul></li></ul><p id="1f6694d5-ea46-800a-9d1a-f71aea106147" class=""><strong>结果显示如下</strong></p><figure id="1f6694d5-ea46-8082-8c6a-e0388b8c639b" class="image"><a href="image%208.png"><img style="width:561.1875px" src="image%208.png"/></a></figure><p id="1f6694d5-ea46-8035-94e4-e2faa5d46c37" class=""><strong><span style="border-bottom:0.05em solid">006-作者清单页面：</span></strong></p><ul id="1f6694d5-ea46-8095-b801-e62e5a65e5bc" class="bulleted-list"><li style="list-style-type:disc">作者列表页面，需要呈现数据库中所有作者的列表，有每位作者的名字，并连接到作者详细内容页面，出生与死亡日期在每周末，并且在同一列</li></ul><p id="1f6694d5-ea46-809f-9d09-c3abca6143e3" class=""><strong>控制器：</strong></p><ul id="1f6694d5-ea46-807b-a0f2-dfe14011cb7b" class="bulleted-list"><li style="list-style-type:disc">作者列表控制器函数，需要获取所有作者实例的列表，然后将这些实力传递给模板进行渲染</li></ul><ul id="1f6694d5-ea46-8002-9574-c72844730f79" class="bulleted-list"><li style="list-style-type:disc">打开/controllers/authorController.js，文件顶部附近，找到导出的author_list控制器方法，并将其替换为下面代码<ul id="1f6694d5-ea46-8038-bf5b-dded5c430e51" class="bulleted-list"><li style="list-style-type:circle">// Display list of all Authors.<br/>exports.author_list = function (req, res, next) {<br/>Author.find()<br/>.sort([[&quot;family_name&quot;, &quot;ascending&quot;]])<br/>.exec(function (err, list_authors) {<br/>if (err) {<br/>return next(err);<br/>}<br/>//Successful, so render<br/>res.render(&quot;author_list&quot;, {<br/>title: &quot;Author List&quot;,<br/>author_list: list_authors,<br/>});<br/>});<br/>};<br/></li></ul></li></ul><ul id="1f6694d5-ea46-80d5-a698-e03ace56de3e" class="bulleted-list"><li style="list-style-type:disc">该方法使用模型的find（）、sort（）、exec（）函数，以返回所有Author对象，并按family_name的字符顺序排列，传递给exec（）方法的回调函数被调用，并将传入任何错误（null）作为第一个参数，成功时，传入所有作者列表，如果出现错误，则调用带有错误值的下一个中间件函数，如果没有错误，呈现author_list（.pug）模板，传递页面标题title，和作者列表author_list</li></ul><p id="1f6694d5-ea46-80b5-b9ec-d56e5fd2bdec" class=""><strong>视图：</strong></p><ul id="1f6694d5-ea46-80f8-8463-c1af52606a1e" class="bulleted-list"><li style="list-style-type:disc">打开/views/author_list.pug，使用下面文字替换内容<ul id="1f6694d5-ea46-803f-96c2-de3639881591" class="bulleted-list"><li style="list-style-type:circle">extends layout<p id="1f6694d5-ea46-80d1-97ef-cd014da79c22" class="">block content<br/>h1= title<br/></p><p id="1f6694d5-ea46-8052-9feb-d0c53e2900de" class="">ul<br/>each author in author_list<br/>li<br/>a(href=author.url) #{<br/><a href="http://author.name/">author.name</a>}<br/>| (#{author.date_of_birth} - #{author.date_of_death})<br/></p><p id="1f6694d5-ea46-8030-8c90-dffd2c5e2892" class="">else<br/>li There are no authors.<br/></p></li></ul></li></ul><p id="1f6694d5-ea46-80b4-8c2f-c840602cca6e" class=""><strong>结果显示如下：</strong></p><figure id="1f6694d5-ea46-801f-8cdc-cded3a56f5ca" class="image"><a href="image%209.png"><img style="width:561.1875px" src="image%209.png"/></a></figure><p id="1f6694d5-ea46-804b-8e78-c468b0a2bb7e" class=""><strong><span style="border-bottom:0.05em solid">同理，实现种类列表页面</span></strong></p><p id="1f6694d5-ea46-806a-a2f2-d8dda1d764f3" class=""><strong>控制器：</strong></p><p id="1f6694d5-ea46-8098-bc4e-ce3b17fdc3f6" class="">
</p><ul id="1f6694d5-ea46-8061-8195-c43da1ea3b63" class="bulleted-list"><li style="list-style-type:disc"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f6694d5-ea46-80f4-b8b3-e35e5d5afd86" class="code"><code class="language-undefined">
exports.genre_list = async function (req, res, next) {
  try {
    // 查询所有 Genre，并按名称升序排列
    const genre_list = await genre.find().sort({ name: 1 }).exec();

    // 渲染模板并传递数据
    res.render(&quot;genre_list&quot;, {
      title: &quot;Genre List&quot;,
      genre_list: genre_list,
    });
  } catch (err) {
    next(err);
  }
};</code></pre></li></ul><p id="1f6694d5-ea46-8010-88f2-eb44d042c596" class=""><strong>视图：</strong></p><ul id="1f6694d5-ea46-80bb-ae96-eb2bc13e9313" class="bulleted-list"><li style="list-style-type:disc"></li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f6694d5-ea46-80e2-8eda-c8971299a763" class="code"><code class="language-undefined">extends layout

block content
  h1= title
  
  if genre_list.length
    ul
      each genre in genre_list
        li 
          a(href=`/catalog/genre/${genre._id}`)= genre.name
  else
    p No genres found.
</code></pre><p id="1f6694d5-ea46-802a-837d-d8b94a68a1e6" class=""><strong>结果显示如下：</strong></p><figure id="1f6694d5-ea46-806c-8a58-c6762fbd71d4" class="image"><a href="image%2010.png"><img style="width:561.1875px" src="image%2010.png"/></a></figure><p id="1f6694d5-ea46-80ad-b572-deee7e552942" class=""><strong><span style="border-bottom:0.05em solid">007-种类细节页面：</span></strong></p><ul id="1f6694d5-ea46-80c9-87fa-e2ee750f09bc" class="bulleted-list"><li style="list-style-type:disc">种类细节页面，需要利用_id字段值自动生成的，来呈现特定种类实例的信息，该页面应该呈现种类名称，各个种类的所有书本列表（每本书都连接到书本的细节页面）</li></ul><p id="1f6694d5-ea46-800d-868c-f19918b4d017" class=""><strong>控制器：</strong></p><ul id="1f6694d5-ea46-80ee-ba32-d588d6583c0c" class="bulleted-list"><li style="list-style-type:disc">打开/controllers/genreController.js，引入async和Book模组<ul id="1f6694d5-ea46-8050-b45a-f8e41b64d275" class="bulleted-list"><li style="list-style-type:circle">var Book = require（”../models/book“）</li></ul><ul id="1f6694d5-ea46-800a-b9b9-d8cfb2bd5581" class="bulleted-list"><li style="list-style-type:circle">var async = require（”async“）</li></ul></li></ul><ul id="1f6694d5-ea46-8070-b582-e62baa696840" class="bulleted-list"><li style="list-style-type:disc">找到导出的genre_detail（）控制器方法，替换为下面代码<ul id="1f6694d5-ea46-8049-95f5-d549b94fad20" class="bulleted-list"><li style="list-style-type:circle">// Display detail page for a specific Genre.<br/>exports.genre_detail = function (req, res, next) {<br/>async.parallel(<br/>{<br/>genre: function (callback) {<br/>Genre.findById(<br/><a href="http://req.params.id/">req.params.id</a>).exec(callback);<br/>},<br/><p id="1f6694d5-ea46-802e-b8a2-c931f8f462f6" class="">  genre_books: function (callback) {<br/>    Book.find({ genre: req.params.id }).exec(callback);<br/>  },<br/>},<br/>function (err, results) {<br/>  if (err) {<br/>    return next(err);<br/>  }<br/>  if (results.genre == null) {<br/>    // No results.<br/>    var err = new Error(&quot;Genre not found&quot;);<br/>    err.status = 404;<br/>    return next(err);<br/>  }<br/>  // Successful, so render<br/>  res.render(&quot;genre_detail&quot;, {<br/>    title: &quot;Genre Detail&quot;,<br/>    genre: results.genre,<br/>    genre_books: results.genre_books,<br/>  });<br/>},<br/><br/></p><p id="1f6694d5-ea46-80f8-89cf-c9cfa8e70503" class="">);<br/>};<br/></p></li></ul></li></ul><ul id="1f6694d5-ea46-80ef-8aae-e2f29eeb837b" class="bulleted-list"><li style="list-style-type:disc">该方法使用async.parallel（），并行查询类型名称以及相关联的书本，并在两个请求完成时回调呈现页面</li></ul><ul id="1f6694d5-ea46-8066-8f0c-e0c0ef7dfd1a" class="bulleted-list"><li style="list-style-type:disc">所需种类记录的ID，在URL的末尾编码，并根据路由定义（/genre/：id）自动提取，通过请求参数（req.params.id）在控制器内访问ID，在Genre.findById（）中用于获取当前种类，他还用于获取符合当前种类的所有Book对象，就是在种类字段中具有种类ID的哪些Book.find（{‘genre’：req.params.id}）</li></ul><ul id="1f6694d5-ea46-8037-871e-feca52e27d54" class="bulleted-list"><li style="list-style-type:disc">渲染的视图为genre_detail，他传递的该类型的标题title，种类genre和书本列表的变量（genre_books）</li></ul><p id="1f6694d5-ea46-80a1-b716-dc87068385ce" class=""><strong>视图：</strong></p><ul id="1f6694d5-ea46-8080-83bf-eec9763f8569" class="bulleted-list"><li style="list-style-type:disc">创建/views/genre_detail.pug，并写入下面代码<ul id="1f6694d5-ea46-8083-bd25-ff499888bde1" class="bulleted-list"><li style="list-style-type:circle">extends layout<p id="1f6694d5-ea46-80b0-944a-df98943cd824" class="">block content</p><p id="1f6694d5-ea46-8082-89ce-f2648f50f678" class="">h1 Genre: #{<a href="http://genre.name/">genre.name</a>}</p><p id="1f6694d5-ea46-80a8-9b30-d9a02a3e5fd9" class="">div(style=&#x27;margin-left:20px;margin-top:20px&#x27;)</p><p id="1f6694d5-ea46-80df-8b39-e648aeb1071e" class="">h4 Books<br/><br/>dl<br/>each book in genre_books<br/>  dt<br/>    a(href=book.url) #{book.title}<br/>  dd #{book.summary}<br/><br/>else<br/>  p This genre has no books<br/></p></li></ul></li></ul><ul id="1f6694d5-ea46-80dd-92d2-ca25733c8fb1" class="bulleted-list"><li style="list-style-type:disc">与其他的模板唯一区别是，使用title传送第一个标题</li></ul><p id="1f6694d5-ea46-8011-bc87-cd4d20834c2b" class=""><strong>结果显示如下</strong></p><figure id="1f6694d5-ea46-80a6-9b92-c8dba4b4dc55" class="image"><a href="image%2011.png"><img style="width:561.1875px" src="image%2011.png"/></a></figure><p id="1f6694d5-ea46-80bd-bab3-e455e5eec4e6" class=""><strong><span style="border-bottom:0.05em solid">008-书本详细信息页面：</span></strong></p><ul id="1f6694d5-ea46-802e-b423-ef0708aa2d2f" class="bulleted-list"><li style="list-style-type:disc">书籍详细信息页面需要呈现指定书籍（Book，使用自动生成的_id字段值进行标识）的信息，以及图书馆中的每一个关联的副本（BookInstance）的信息，无论在哪里呈现作者、种类、书籍实例，都应该连接到关联的详细信息页面</li></ul><p id="1f6694d5-ea46-8064-8294-d215a874682e" class=""><strong>控制器：</strong></p><ul id="1f6694d5-ea46-802c-a003-ce7581746629" class="bulleted-list"><li style="list-style-type:disc">打开/controllers/bookController.js，找到book _detail（）控制器方法，替换为以下代码<ul id="1f6694d5-ea46-8075-9bf8-d3c1001ad293" class="bulleted-list"><li style="list-style-type:circle">const Book = require(&quot;../models/book&quot;);<br/>const BookInstance = require(&quot;../models/bookinstance&quot;);<br/>const asyncHandler = require(&quot;express-async-handler&quot;);<br/><p id="1f6694d5-ea46-80c9-b097-f331f299759b" class="">// 显示特定书籍的详细信息页面。<br/>exports.book_detail = asyncHandler(async (req, res, next) =&gt; {<br/>try {<br/>const bookId = <br/><a href="http://req.params.id/">req.params.id</a>;</p><p id="1f6694d5-ea46-808c-9c47-ee70c89956ee" class="">// 使用 Promise.all 并行查询<br/>const [book, bookInstances] = await Promise.all([<br/>  Book.findById(bookId).populate(&quot;author&quot;).populate(&quot;genre&quot;).exec(),<br/>  BookInstance.find({ book: bookId }).exec(),<br/>]);<br/><br/>// 如果没有找到书籍，抛出 404 错误<br/>if (!book) {<br/>  const err = new Error(&quot;Book not found&quot;);<br/>  err.status = 404;<br/>  return next(err);<br/>}<br/><br/>// 渲染模板<br/>res.render(&quot;book_detail&quot;, {<br/>  title: book.title,<br/>  book,<br/>  book_instances: bookInstances,<br/>});<br/><br/></p><p id="1f6694d5-ea46-8026-95e7-fdb9fc003dfd" class="">} catch (err) {<br/>next(err);<br/>}<br/>});<br/></p></li></ul></li></ul><ul id="1f6694d5-ea46-80ea-b177-f71f9eb20963" class="bulleted-list"><li style="list-style-type:disc">此方法与类别详细信息页面描述的方法相同，路由控制器函数使用Promise.all（）并行查询指定的书籍Book以及他的相关副本BookInstance，如果没有找到匹配的书籍美酒会返回一个带有404not found的错误对象，如果找到了书籍就会使用Book_detail模板呈现检索到的数据库信息，由于title键用于给网页命名（如layout.pug中定义的标题），所有这次在渲染网页时传递了results.book.title</li></ul><p id="1f6694d5-ea46-803e-a521-ebb97d60f69c" class=""><strong>视图：</strong></p><p id="1f6694d5-ea46-8071-8b96-d34bb8314e5c" class="">创建/views/book_detail.pug，并添加以下代码</p><ul id="1f6694d5-ea46-8016-9244-c31faa4e85d6" class="bulleted-list"><li style="list-style-type:disc">extends layout<p id="1f6694d5-ea46-8032-95e6-f00e2d63db5e" class="">block content<br/>h1 Title: #{book.title}<br/></p><p id="1f6694d5-ea46-80df-b789-cfb27dedf63f" class="">p #[strong Author:]<br/>a(href=book.author.url) #{<br/><a href="http://book.author.name/">book.author.name</a>}<br/>p #[strong Summary:] #{book.summary}<br/>p #[strong ISBN:] #{book.isbn}<br/>p #[strong Genre:]<br/>each val, index in book.genre<br/>a(href=val.url) #{<br/><a href="http://val.name/">val.name</a>}<br/>if index &lt; book.genre.length - 1<br/>|,<br/></p><p id="1f6694d5-ea46-805a-90d3-c9b253046c19" class="">div(style=&#x27;margin-left:20px;margin-top:20px&#x27;)<br/>h4 Copies<br/></p><p id="1f6694d5-ea46-8082-a09d-fe30d03c1590" class="">each val in book_instances<br/>  hr<br/>  if val.status==&#x27;Available&#x27;<br/>    p.text-success #{val.status}<br/>  else if val.status==&#x27;Maintenance&#x27;<br/>    p.text-danger #{val.status}<br/>  else<br/>    p.text-warning #{val.status}<br/>  p #[strong Imprint:] #{val.imprint}<br/>  if val.status!=&#x27;Available&#x27;<br/>    p #[strong Due back:] #{val.due_back}<br/>  p #[strong Id:]<br/>    a(href=val.url) #{val._id}<br/><br/>else<br/>  p There are no copies of this book in the library.<br/></p></li></ul><p id="1f6694d5-ea46-8031-87a8-cc9d5a7e2086" class=""><strong>结果展示如下</strong></p><figure id="1f6694d5-ea46-80fb-bbd7-eef1b00b33ee" class="image"><a href="image%2012.png"><img style="width:561.1875px" src="image%2012.png"/></a></figure><p id="1f6694d5-ea46-80fa-802b-fccaa54693cd" class=""><strong><span style="border-bottom:0.05em solid">009-作者详情页面：</span></strong></p><ul id="1f6694d5-ea46-8027-8946-ff0a77434262" class="bulleted-list"><li style="list-style-type:disc">控制器/controllers/authorController.js<ul id="1f6694d5-ea46-80f5-95ed-cd96985ebc74" class="bulleted-list"><li style="list-style-type:circle">引入模块<ul id="1f6694d5-ea46-80be-b2e1-d693ac517686" class="bulleted-list"><li style="list-style-type:square">const Book = require(&quot;../models/book&quot;);</li></ul></li></ul><ul id="1f6694d5-ea46-8062-bd2b-d21c4357ce2e" class="bulleted-list"><li style="list-style-type:circle">author_detail（）控制器方法，替换代码<ul id="1f6694d5-ea46-80ad-84b9-c50751c4844e" class="bulleted-list"><li style="list-style-type:square">// 呈现指定作者的详情页。<br/>exports.author_detail = asyncHandler(async (req, res, next) =&gt; {<br/>// （并行地）获取作者的详细信息及其所有作品<br/>const [author, allBooksByAuthor] = await Promise.all([<br/>Author.findById(<br/><a href="http://req.params.id/">req.params.id</a>).exec(),<br/>Book.find({ author: <br/><a href="http://req.params.id/">req.params.id</a> }, &quot;title summary&quot;).exec(),<br/>]);<br/><p id="1f6694d5-ea46-803f-9e80-c740947d2323" class="">if (author === null) {<br/>// 没有结果。<br/>const err = new Error(&quot;Author not found&quot;);<br/>err.status = 404;<br/>return next(err);<br/>}<br/></p><p id="1f6694d5-ea46-8028-8e1a-ed493fa048a7" class="">res.render(&quot;author_detail&quot;, {<br/>title: &quot;Author Detail&quot;,<br/>author: author,<br/>author_books: allBooksByAuthor,<br/>});<br/>});<br/></p></li></ul></li></ul></li></ul><ul id="1f6694d5-ea46-80ad-ad51-f474a0eb490d" class="bulleted-list"><li style="list-style-type:disc">该方法与<a href="https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/Displaying_data/Genre_detail_page">种类详情页面</a>中描述的方法完全相同。路由控制器函数使用 <code>Promise.all()</code> 并行地查询指定的作者（<code>Author</code>）及其关联的 <code>Book</code> 实例。如果没有找到匹配的作者，则会将错误（Error）对象发送到 Express 错误处理中间件。如果找到作者，则使用“author_detail”模板呈现检索到的数据库信息。</li></ul><p id="1f6694d5-ea46-8006-8b3f-fea95d550aa4" class=""><strong>视图：</strong></p><ul id="1f6694d5-ea46-80ff-9048-d81d85b85c49" class="bulleted-list"><li style="list-style-type:disc">创建/views/author_detail.pug<ul id="1f6694d5-ea46-8085-a68f-f6675aa6b293" class="bulleted-list"><li style="list-style-type:circle">extends layout<p id="1f6694d5-ea46-80c3-8d55-f539268dd5f7" class="">block content</p><p id="1f6694d5-ea46-808b-8222-c9d5c95a1afd" class="">h1 Author: #{<a href="http://author.name/">author.name</a>}<br/>p #{author.date_of_birth} - #{author.date_of_death}<br/></p><p id="1f6694d5-ea46-80a0-bb1b-f1955823672d" class="">div(style=&#x27;margin-left:20px;margin-top:20px&#x27;)</p><p id="1f6694d5-ea46-80af-aedb-df8ab800aa67" class="">h2(style=&#x27;font-size: 1.5rem;&#x27;) Books<br/>if author_books.length<br/>  dl<br/>    each book in author_books<br/>      dt<br/>        a(href=book.url) #{book.title}<br/>      dd #{book.summary}<br/>else<br/>  p This author has no books.<br/></p></li></ul></li></ul><p id="1f6694d5-ea46-8089-ba6d-ccbc843a6db8" class=""><strong>结果展示如下</strong></p><figure id="1f6694d5-ea46-80fc-8c3e-cbd62de09018" class="image"><a href="image%2013.png"><img style="width:561.1875px" src="image%2013.png"/></a></figure><p id="1f6694d5-ea46-8042-89a3-ed7f35f5b551" class=""><strong>010-书本实例详情页面：</strong></p><ul id="1f6694d5-ea46-8051-a987-c92c801f057a" class="bulleted-list"><li style="list-style-type:disc"><code>BookInstance</code> 详情页面需要展示每一个 <code>BookInstance</code> 的信息，使用其（自动生成的）<code>_id</code> 字段值进行标识。它包含了 <code>Book</code> 名称（作为<em>书本细节页面</em>的链接）以及记录中的其他信息。</li></ul><p id="1f6694d5-ea46-8086-9e1f-e92c865d2699" class=""><strong>控制器</strong></p><ul id="1f6694d5-ea46-806c-9325-dc842c00ccf8" class="bulleted-list"><li style="list-style-type:disc">/controllers/bookinstanceController.js，找出book instance_detail（）方法<ul id="1f6694d5-ea46-8027-af6e-d7626675b8dc" class="bulleted-list"><li style="list-style-type:circle">// 展示特定 BookInstance 的详情页。<br/>exports.bookinstance_detail = asyncHandler(async (req, res, next) =&gt; {<br/>const bookInstance = await BookInstance.findById(<br/><a href="http://req.params.id/">req.params.id</a>)<br/>.populate(&quot;book&quot;)<br/>.exec();<br/><p id="1f6694d5-ea46-8049-9cfd-d37a88035c99" class="">if (bookInstance === null) {<br/>// 没有结果。<br/>const err = new Error(&quot;Book copy not found&quot;);<br/>err.status = 404;<br/>return next(err);<br/>}<br/></p><p id="1f6694d5-ea46-8024-9f9b-d0cffb3e4a92" class="">res.render(&quot;bookinstance_detail&quot;, {<br/>title: &quot;Book:&quot;,<br/>bookinstance: bookInstance,<br/>});<br/>});<br/></p></li></ul></li></ul><ul id="1f6694d5-ea46-80c2-9371-dee60c1dea0c" class="bulleted-list"><li style="list-style-type:disc">该实现与其他模型详细信息页面所使用的非常相似。路由控制器函数使用从 URL（使用路由）中提取的特定的书籍实例的 ID 来调用 <code>BookInstance.findById()</code>，并通过请求参数 <code>req.params.id</code> 在控制器中访问。然后调用 <code>populate()</code> 来获取与 <code>Book</code> 相关的详细信息。如果没有找到匹配的 <code>BookInstance</code>，则将错误传递给 Express 的中间件。否则就将返回的数据传递给 <strong>bookinstance_detail.pug</strong> 视图呈现。</li></ul><p id="1f6694d5-ea46-8010-a15c-e1325a63ccd2" class=""><strong>视图：</strong></p><ul id="1f6694d5-ea46-80c9-9506-cad88f9b00cb" class="bulleted-list"><li style="list-style-type:disc">创建/views/bookinstance_detail.pug<ul id="1f6694d5-ea46-8036-9023-df6146608767" class="bulleted-list"><li style="list-style-type:circle">extends layout<p id="1f6694d5-ea46-8031-b06c-c2a325d984a2" class="">block content</p><p id="1f6694d5-ea46-803f-8539-d58cceeb3d4f" class="">h1 ID: #{bookinstance._id}</p><p id="1f6694d5-ea46-8099-84ff-e434c4f52556" class="">p #[strong Title: ]<br/>a(href=bookinstance.book.url) #{bookinstance.book.title}<br/>p #[strong Imprint:] #{bookinstance.imprint}<br/></p><p id="1f6694d5-ea46-8059-9ab7-f44fb4387eb4" class="">p #[strong Status: ]<br/>if bookinstance.status==&#x27;Available&#x27;<br/>span.text-success #{bookinstance.status}<br/>else if bookinstance.status==&#x27;Maintenance&#x27;<br/>span.text-danger #{bookinstance.status}<br/>else<br/>span.text-warning #{bookinstance.status}<br/></p><p id="1f6694d5-ea46-80b4-9e0b-ebcde2eada06" class="">if bookinstance.status!=&#x27;Available&#x27;<br/>p #[strong Due back:] #{bookinstance.due_back}<br/></p></li></ul></li></ul><p id="1f6694d5-ea46-8002-a517-ffb2747d26fe" class=""><strong>结果展示如下</strong></p><figure id="1f7694d5-ea46-801a-babb-db9b4735b7a6" class="image"><a href="image%2014.png"><img style="width:561.1749877929688px" src="image%2014.png"/></a></figure><p id="1f7694d5-ea46-80b3-80d8-d9648a727dea" class="">
</p><p id="1f7694d5-ea46-808d-a54b-d8dd4f7953b9" class=""><strong><span style="border-bottom:0.05em solid">【第五步-使用表单】：</span></strong></p><ul id="1f7694d5-ea46-80b3-8aa0-c60c0cf0e09e" class="bulleted-list"><li style="list-style-type:disc">使用Express结合Pug来实现HTML表单，从数据库中创建、更新、删除文档。</li></ul><p id="1f7694d5-ea46-80db-af1f-c380a426e9c7" class="">
</p><p id="1f7694d5-ea46-8014-b1f6-d131cdb22488" class=""><strong>概览：</strong></p><ul id="1f7694d5-ea46-80e7-a40f-e6faf7b16963" class="bulleted-list"><li style="list-style-type:disc">HTML表单在网页中使用一个或多个字段/小工具的集合，它被用来收集用户信息，并将信息上传到服务器，表单作为一种用来收集用户的机制，灵活，有各种各样的输入框接受各种类型的数据-文本框、复选框、单选按钮、时间选择器。表单和服务器交互数据相对安全，使用POST请求发送数据，保护不受跨站点请求伪造攻击的威胁。</li></ul><ul id="1f7694d5-ea46-807b-9288-e26cc3df4c90" class="bulleted-list"><li style="list-style-type:disc">表单同样复杂，开发者需要为表单编写HTML，在服务器上验证，并且正确去除有害的数据，对于不合法的字段，需要传给用户响应的错误信息，当数据成功提交后，处理数据，并设法通知用户提交成功</li></ul><ul id="1f7694d5-ea46-80cf-ac22-eb8beff1dd25" class="bulleted-list"><li style="list-style-type:disc">下面过程展示，在Express中实现，扩展图书馆下面，允许用户创建、编辑、删除图书馆中的项目</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f7694d5-ea46-805b-9789-c10d534cd0eb"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f7694d5-ea46-80a3-b8e8-f4337df1d015" class="">没有使用特定路由限制身份验证或授权的用户，任何用户都可以对数据库进行修改</p></div></figure><p id="1f7694d5-ea46-8033-80ac-df02774cf1bd" class="">
</p><p id="1f7694d5-ea46-80a7-957f-ef116c8de319" class=""><strong>HTML表单：</strong></p><ul id="1f7694d5-ea46-8016-87d1-d06861345126" class="bulleted-list"><li style="list-style-type:disc">首先考虑一个简单的HTML表单，其中包含一个文本字段，用于输入团队的名称以及相关标签<ul id="1f7694d5-ea46-8081-86f9-e9bc9558658e" class="bulleted-list"><li style="list-style-type:circle">表单在HTML中，定义为&lt;form&gt;  标签中，至少包含一个type=‘submit’的input输入元素。</li></ul></li></ul><ul id="1f7694d5-ea46-80e3-9632-fd53e350063e" class="bulleted-list"><li style="list-style-type:disc">这里使用input的submit而不是button。<ul id="1f7694d5-ea46-8001-bc19-c185b62a022b" class="bulleted-list"><li style="list-style-type:circle">&lt;form action=&quot;/team_name_url/&quot; method=&quot;post&quot;&gt;<br/>&lt;label for=&quot;team_name&quot;&gt;Enter name: &lt;/label&gt;<br/>&lt;input<br/>id=&quot;team_name&quot;<br/>type=&quot;text&quot;<br/>name=&quot;name_field&quot;<br/>value=&quot;Default name for team.&quot; /&gt;<br/>&lt;input type=&quot;submit&quot; value=&quot;OK&quot; /&gt;<br/>&lt;/form&gt;<br/></li></ul></li></ul><ul id="1f7694d5-ea46-8090-900d-ed5916ba52d7" class="bulleted-list"><li style="list-style-type:disc">这里只包含一个文本字段，用于输入团队名称，但表单可能包含任意数量的其他输入元素，及其相关标签。字段的type属性，定义显示哪种窗口小部件，该字段的name和id，用于表示JS/CSS/HTML的字段，儿value定义字段首次显示时的初始值，匹配团队标签是用label标签，指定for字段，包含input相关输入的id值</li></ul><ul id="1f7694d5-ea46-80cc-aee8-e48888d278af" class="bulleted-list"><li style="list-style-type:disc">HTML的form表单默认是post提交的，他比get方式存储量更大、传输更安全</li></ul><ul id="1f7694d5-ea46-80dc-b8ea-d20aa194f2d4" class="bulleted-list"><li style="list-style-type:disc">提交输入submit将显示为按钮。用户可以点击此按钮将其他输入元素怒包含的数据，上传到服务器，本项目中只有team_name，表单属性，定义用于发送数据的HTTP method方法，和服务器上数据的目标<ul id="1f7694d5-ea46-80b7-9fac-fb74b75d013b" class="bulleted-list"><li style="list-style-type:circle">action：提交表单时，要发送数据以进行处理的资源/URL，如果未设置（或设置为空字符串），表单将提交回当前页面URL</li></ul><ul id="1f7694d5-ea46-8054-af77-e63cbc51db97" class="bulleted-list"><li style="list-style-type:circle">method：用于发送数据的HTTP方法 POST或GET<ul id="1f7694d5-ea46-8095-8221-fb9d35ae0e95" class="bulleted-list"><li style="list-style-type:square">如果数据将导致服务器数据库的更改，则始终应该使用POST方法，因此这更加可以抵抗跨站点伪造请求攻击</li></ul><ul id="1f7694d5-ea46-80bd-a660-d833206ec369" class="bulleted-list"><li style="list-style-type:square">GET方法只应用于不更改用户数据的表单，例如搜索表单，希望能够为URL添加书签或者共享时，建议使用此选项</li></ul></li></ul></li></ul><p id="1f7694d5-ea46-801f-83bf-e9ad2314325b" class="">
</p><p id="1f7694d5-ea46-8055-80b3-c857f2241f6d" class=""><strong>表单处理流程：</strong></p><ul id="1f7694d5-ea46-8058-870e-fe7e387707e3" class="bulleted-list"><li style="list-style-type:disc">表单处理使用的技术，与显示相关模型的信息的技术是相同的，路由将我们的请求发送到控制器函数，该函数执行所需的数据库操作，包括从模型中读取数据，生成并返回HTML页面，更复杂情况是服务器需要能够处理用户提供的数据，并在出现问题时，重新显示带有错误信息的表单。<ul id="1f7694d5-ea46-8045-8234-d078b2ec6f03" class="bulleted-list"><li style="list-style-type:circle">下面为处理表单请求的流程图，从包含表单的页面请求开始</li></ul><figure id="1f7694d5-ea46-80ef-848c-f04bda4190c7" class="image"><a href="image%2015.png"><img style="width:531.1625366210938px" src="image%2015.png"/></a></figure></li></ul><ul id="1f7694d5-ea46-8090-9ae8-d8b6d0a19208" class="bulleted-list"><li style="list-style-type:disc">在用户第一次请求时显示默认表单<ul id="1f7694d5-ea46-80d5-a8ba-dbc3856f846b" class="bulleted-list"><li style="list-style-type:circle">表单可能包含空白字段（例如，正在创建新记录），或者预先填充了初始值（例如，要更改记录或则具有有用的默认初始值）</li></ul></li></ul><ul id="1f7694d5-ea46-8012-81d8-ef883845a35e" class="bulleted-list"><li style="list-style-type:disc">接受用户提交的数据，通常在HTTP POST请求中</li></ul><ul id="1f7694d5-ea46-8040-8749-fa1a862f51e4" class="bulleted-list"><li style="list-style-type:disc">验证并清理数据</li></ul><ul id="1f7694d5-ea46-801d-b5e0-f414899ed904" class="bulleted-list"><li style="list-style-type:disc">如果数据无效，则重新显示表单，这次使用用户填写的任何值，和问题字段的错误消息</li></ul><ul id="1f7694d5-ea46-8048-90e0-e1c816a23c57" class="bulleted-list"><li style="list-style-type:disc">如果所有数据都有效，执行所需的步骤（例如，将数据保存在数据库中，发送通知电子邮件、返回搜索结果、上传文件等）</li></ul><ul id="1f7694d5-ea46-804a-9256-d42b1c2f29ad" class="bulleted-list"><li style="list-style-type:disc">完成所有操作，将用户重定向到另一个页面</li></ul><p id="1f7694d5-ea46-8002-bff6-e253e469a5a9" class="">
</p><ul id="1f7694d5-ea46-8038-9880-e876c27f3666" class="bulleted-list"><li style="list-style-type:disc">表格处理代码，通常使用GET路由，以实现表单的初始显示，以及POST路由到同一路径，来处理表单数据的验证和处理。</li></ul><ul id="1f7694d5-ea46-80fc-a1f9-eaf8f9188419" class="bulleted-list"><li style="list-style-type:disc">上述为本项目中使用的方法，Express本身不提供表单处理操作中的任何特定支持，它可以使用中间件，来处理表单的POST 和GET参数，并验证/清理它们的值</li></ul><p id="1f7694d5-ea46-8099-8624-df12ff203e19" class="">
</p><p id="1f7694d5-ea46-80be-a036-da86a8ac0340" class=""><strong>验证和清理：</strong></p><ul id="1f7694d5-ea46-80a7-9eaa-ec406b24ddfe" class="bulleted-list"><li style="list-style-type:disc">在存储表单中的数据之前，就必须要对他进行验证和清理<ul id="1f7694d5-ea46-8055-af6f-d40a9671f42f" class="bulleted-list"><li style="list-style-type:circle">验证检查输入的值，适用于每个字段（范围、格式），并且为所有必填字段提供了值</li></ul><ul id="1f7694d5-ea46-8004-93eb-f7c9b2e9fe3c" class="bulleted-list"><li style="list-style-type:circle">清理删除/替换数据中的字符，可能用于将恶意内容发送到服务器</li></ul></li></ul><ul id="1f7694d5-ea46-804f-933b-c1ed2f6052d8" class="bulleted-list"><li style="list-style-type:disc">本项目使用express-validator模块，来执行表单数据的验证和清理</li></ul><p id="1f7694d5-ea46-8099-9e67-e3e89947a32e" class="">
</p><p id="1f7694d5-ea46-801d-b5ec-c3c7a49bf1a7" class=""><strong>安装</strong></p><ul id="1f7694d5-ea46-8022-ba33-fbd9b912ae52" class="bulleted-list"><li style="list-style-type:disc">项目命令行执行命令<ul id="1f7694d5-ea46-80be-b39b-e4c2453959b2" class="bulleted-list"><li style="list-style-type:circle">npm install express-validator —save</li></ul></li></ul><p id="1f7694d5-ea46-8054-8f47-cfb362a4d461" class="">
</p><p id="1f7694d5-ea46-8086-8d5a-cb56956b7be0" class=""><strong>使用express-validator：</strong></p><ul id="1f7694d5-ea46-80bc-b1bf-ed21081f2d9d" class="bulleted-list"><li style="list-style-type:disc">在控制器中使用验证码，必须从‘express-validator/check’和‘express-validator/filter’模块中，导入我们要使用的函数。<ul id="1f7694d5-ea46-8023-bbcc-f4c612f6b112" class="bulleted-list"><li style="list-style-type:circle">const { body, validationResult } = require(&quot;express-validator/check&quot;);<br/>const { sanitizeBody } = require(&quot;express-validator/filter&quot;);<br/></li></ul></li></ul><ul id="1f7694d5-ea46-806e-8103-f493810385ef" class="bulleted-list"><li style="list-style-type:disc">有许多可用的功能，允许一次检查和清理请求参数，正文、标头、cookie等数据，或所有数据，对于本项目，主要使用body、sanitizeBody和validationResult，功能如下<ul id="1f7694d5-ea46-80a4-953f-c138248ce9ba" class="bulleted-list"><li style="list-style-type:circle">body：（fields【，message】）：指定请求本文中的一组字段（POST参数）以及可选的错误消息，如果测试失败，则显示该字段。验证标准以菊花链形式连接到body（）方法。例如，下面的第一个检查测试，name字段不为空，如果不是，则设置错误消息为Empty name。第二个测试，检查age字段是否为有效日期，并使用optional（）指定nyull和空字符串不会验证失败<ul id="1f7694d5-ea46-80ae-8442-c09abb9e63d9" class="bulleted-list"><li style="list-style-type:square">body(&#x27;name&#x27;, &#x27;Empty name&#x27;).isLength({ min: 1 }),<br/>body(&#x27;age&#x27;, &#x27;Invalid age&#x27;).optional({ checkFalsy: true }).isISO8601(),<br/></li></ul></li></ul><ul id="1f7694d5-ea46-80ef-a05b-ffe74d0252d4" class="bulleted-list"><li style="list-style-type:circle">还可以用菊花链式连接不同的验证其，并添加前面验证器为真时显示的消息<ul id="1f7694d5-ea46-8006-be52-f94cb018cd5a" class="bulleted-list"><li style="list-style-type:square">body(&#x27;name&#x27;).isLength({ min: 1 }).trim().withMessage(&#x27;Name empty.&#x27;)<br/>.isAlpha().withMessage(&#x27;Name must be alphabet letters.&#x27;),<br/></li></ul></li></ul></li></ul><ul id="1f7694d5-ea46-80e1-8973-e8713cfba076" class="bulleted-list"><li style="list-style-type:disc">也可以添加内联清理器，如trim（），如上所示，此处应用清理器只适合用于验证步骤，如果要对最终输出进行清理，需要单独的清理器方法，如下所示<ul id="1f7694d5-ea46-80df-8209-e54e2a4eca2e" class="bulleted-list"><li style="list-style-type:circle">sanitizeBody（fields）：指定一个正文要清理的字段，然后将清理操作，以菊花链形式连接到此方法，例如，下面的escape（）清理操作，回从名称变量中，删除可能在JS跨站点脚本攻击中使用的HTML字符<ul id="1f7694d5-ea46-8088-8202-d9aa78366941" class="bulleted-list"><li style="list-style-type:square">sanitizeBody(&#x27;name&#x27;).trim().escape(),<br/>sanitizeBody(&#x27;date&#x27;).toDate(),<br/></li></ul></li></ul><ul id="1f7694d5-ea46-8087-b41f-e839bc6853b6" class="bulleted-list"><li style="list-style-type:circle">validationResult（req）：运行验证，以validation验证结果对象的形式，提供错误，这是在单独的回调中调用的。<ul id="1f7694d5-ea46-805c-bf6c-c9dae4b81053" class="bulleted-list"><li style="list-style-type:square">(req, res, next) =&gt; {<br/>// Extract the validation errors from a request.<br/>const errors = validationResult(req);<br/><p id="1f7694d5-ea46-80e8-8880-f7e24fbc6de2" class="">if (!errors.isEmpty()) {<br/>// There are errors. Render form again with sanitized values/errors messages.<br/>// Error messages can be returned in an array using <br/><code>errors.array()</code>.<br/>} else {<br/>// Data from form is valid.<br/>}<br/>};<br/></p><ul id="1f7694d5-ea46-8076-9137-e37ea5982471" class="bulleted-list"><li style="list-style-type:disc">使用验证结果的isEmpty（）方法，来检查是否存在错误，并使用其array（）方法，来获取错误消息集合</li></ul></li></ul></li></ul></li></ul><ul id="1f7694d5-ea46-8003-bde5-c38b8274ee5f" class="bulleted-list"><li style="list-style-type:disc">验证和清理链，是应该传递给Express路由处理程序的中间件（我们通过控制器，间接的执行该操作）。中间件运行时，每个验证其/清理程序都按指定的顺序运行，</li></ul><ul id="1f7694d5-ea46-80e4-bf64-c6b8fc458d56" class="bulleted-list"><li style="list-style-type:disc">下面实现本项目表单时，举例</li></ul><p id="1f7694d5-ea46-80e1-ab24-e1b9daee1565" class="">
</p><p id="1f7694d5-ea46-80f8-9a3b-fcbe9e252931" class=""><strong>表单设计：</strong></p><ul id="1f7694d5-ea46-80a9-a6c0-d0723c81f526" class="bulleted-list"><li style="list-style-type:disc">图书馆中的许多模型都是相关/依赖的，例如，一本书需要一个作者，也有可能有一个或多个种类。下面时如何处理用户希望的情况<ul id="1f7694d5-ea46-805b-8dc0-d812e31461d6" class="bulleted-list"><li style="list-style-type:circle">在其相关对象不存在时，创建对象（例如，尚未定义作者对象的书）</li></ul><ul id="1f7694d5-ea46-80c5-8e59-e68dd9f744aa" class="bulleted-list"><li style="list-style-type:circle">删除另一个对象仍在使用的对象（例如，删除仍有书本使用的种类）</li></ul></li></ul><ul id="1f7694d5-ea46-8095-bd4c-cf727799c146" class="bulleted-list"><li style="list-style-type:disc">本项目中，简单声明表单<ul id="1f7694d5-ea46-808e-bd16-cd07d2fdbaf7" class="bulleted-list"><li style="list-style-type:circle">使用已经存在的对象创建对象（因此用户在尝试创建任何Book对象之前，必须创建所需的Author和Genre实例）</li></ul><ul id="1f7694d5-ea46-806c-9282-dafc50a14051" class="bulleted-list"><li style="list-style-type:circle">如果对象未被其他对象引用，则删除该对象（例如，在删除所有关联的BookInstance的对象之前，无法删除该Book）</li></ul></li></ul><ul id="1f7694d5-ea46-8084-a0bb-fcf3744169f2" class="bulleted-list"><li style="list-style-type:disc"><strong>进阶内容</strong><ul id="1f7694d5-ea46-8065-877e-f720755db941" class="bulleted-list"><li style="list-style-type:circle">通常会在后台接收form表单提交的数据，这里是express</li></ul><ul id="1f7694d5-ea46-8076-b921-c822b9a63069" class="bulleted-list"><li style="list-style-type:circle">首先引入express<ul id="1f7694d5-ea46-80b9-9ec0-e8d0e623d811" class="bulleted-list"><li style="list-style-type:square">const app = express（）</li></ul></li></ul><ul id="1f7694d5-ea46-807e-b95b-f803372735dc" class="bulleted-list"><li style="list-style-type:circle">POST提交，这里使用body-parser中间件，处理body数据</li></ul><ul id="1f7694d5-ea46-804d-91a4-e7b65bfca7a9" class="bulleted-list"><li style="list-style-type:circle">设计文件上传，需要multer中间件。</li></ul></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f7694d5-ea46-804c-8ccc-de318642bd43"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f7694d5-ea46-809d-a666-c462c1747bbe" class="">更常用的是，允许在创建新对象时创建依赖对象，并随时删除任何对象（例如，通过删除依赖对象，从数据库中，删除已删除对象的引用）</p></div></figure><p id="1f7694d5-ea46-80e3-991d-c331e275fb3d" class="">
</p><p id="1f7694d5-ea46-8076-9f52-e6ff617d0273" class=""><strong>路由：</strong></p><ul id="1f7694d5-ea46-808f-a741-c14f5e08fbb2" class="bulleted-list"><li style="list-style-type:disc">实现表单处理代码，需要两个具有相同URL模式的路由<ul id="1f7694d5-ea46-80e7-9b76-dc1cdcadca12" class="bulleted-list"><li style="list-style-type:circle">第一个GET路由，用于显示用于创建对象的新空表单</li></ul><ul id="1f7694d5-ea46-8018-a82f-fd53f764aa65" class="bulleted-list"><li style="list-style-type:circle">第二个POST路由，用于验证用户输入的数据，然后保存信息，并重定向到详细信息页面（数据有效），或重新显示有错误的表单（数据无效）</li></ul></li></ul><ul id="1f7694d5-ea46-80a6-8c3e-c038f343ef84" class="bulleted-list"><li style="list-style-type:disc">在/routes/catalog.js中未模型创建了页面，创建了路径<ul id="1f7694d5-ea46-8016-b73b-f97704025183" class="bulleted-list"><li style="list-style-type:circle">种类路由如下所示<ul id="1f7694d5-ea46-80c4-b219-f94b972cc5a6" class="bulleted-list"><li style="list-style-type:square">// GET request for creating a Genre. NOTE This must come before route that displays Genre (uses id).<br/>router.get(&quot;/genre/create&quot;, genre_controller.genre_create_get);<br/><p id="1f7694d5-ea46-809e-bc4c-f850dffae83f" class="">// POST request for creating Genre.<br/>router.post(&quot;/genre/create&quot;, genre_controller.genre_create_post);<br/></p></li></ul></li></ul></li></ul><p id="1f7694d5-ea46-8094-a113-dcec19fe2fde" class="">
</p><p id="1f7694d5-ea46-8091-bb12-e7cf2a6655e3" class=""><strong>Express表单子文件：类似于上述各详情页面。</strong></p><p id="1f7694d5-ea46-8064-86b4-d4f8059e4822" class="">
</p><p id="1f7694d5-ea46-80ff-93e8-c9090cd15f8d" class=""><strong>001-创建类型表单：</strong></p><ul id="1f7694d5-ea46-8037-bb93-f76b3f64e825" class="bulleted-list"><li style="list-style-type:disc">演示如何定义页面来创建Genre对象。因为Genre只有一个字段name，且没有依赖项。与其他页面一样，需要设置路由、控制器、视图</li></ul><p id="1f7694d5-ea46-8040-8de8-c4bcc0bcf789" class="">【导入验证和清理】：</p><ul id="1f7694d5-ea46-808b-9ef5-d3ce9d5c06b0" class="bulleted-list"><li style="list-style-type:disc">控制器中使用express-validator，从‘express-validator’模块中require使用的函数<ul id="1f7694d5-ea46-80c6-88f3-f2c7d7565a07" class="bulleted-list"><li style="list-style-type:circle">/controllers/genreController.js，引入函数<ul id="1f7694d5-ea46-80e8-af7d-df3454794907" class="bulleted-list"><li style="list-style-type:square">const { body, validationResult } = require(&quot;express-validator&quot;);</li></ul></li></ul></li></ul><p id="1f7694d5-ea46-8027-a724-c8f8e1afc3dd" class="">【控制器-get路由】</p><ul id="1f7694d5-ea46-806c-9a87-c4e9883e0248" class="bulleted-list"><li style="list-style-type:disc">找到genre_create_get（）控制器方法，替换为下面代码，渲染genre_from.pug视图<ul id="1f7694d5-ea46-8006-9a7c-f6ddcedacef4" class="bulleted-list"><li style="list-style-type:circle">// 呈现 GET 方法获取的 Genre 表单<br/>exports.genre_create_get = (req, res, next) =&gt; {<br/>res.render(&quot;genre_form&quot;, { title: &quot;Create Genre&quot; });<br/>};<br/></li></ul></li></ul><ul id="1f7694d5-ea46-800d-8c56-ca9892516d16" class="bulleted-list"><li style="list-style-type:disc">请注意，这里使用一个“普通”express 路由处理器替换我们在 <a href="https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/routes">Express 教程 4：路由和控制器</a>中添加的占位异步处理器。我们不需要为该路由添加 <code>asyncHandler()</code> 包装器，因为它不包含任何可能引发异常的代码。</li></ul><p id="1f7694d5-ea46-80e0-992e-fbb7128f44ed" class="">【控制器-post路由】</p><ul id="1f7694d5-ea46-8053-9e20-e53cd542a0b6" class="bulleted-list"><li style="list-style-type:disc">找到genre_create_post（）控制器方法，替换<ul id="1f7694d5-ea46-800a-b810-d1c2c5cd562e" class="bulleted-list"><li style="list-style-type:circle">// 处理 POST 方法创建的 Genre<br/>exports.genre_create_post = [<br/>// 验证及清理名称字段<br/>body(&quot;name&quot;, &quot;Genre name must contain at least 3 characters&quot;)<br/>.trim()<br/>.isLength({ min: 3 })<br/>.escape(),<br/><p id="1f7694d5-ea46-8058-931f-dac459c2b376" class="">// 处理验证及清理过后的请求<br/>asyncHandler(async (req, res, next) =&gt; {<br/>// 从请求中提取验证时产生的错误信息<br/>const errors = validationResult(req);<br/></p><p id="1f7694d5-ea46-8054-84f6-f79aaa3507f1" class="">// 使用经去除空白字符和转义处理的数据创建一个类型对象<br/>const genre = new Genre({ name: req.body.name });<br/><br/>if (!errors.isEmpty()) {<br/>  // 出现错误。使用清理后的值/错误信息重新渲染表单<br/>  res.render(&quot;genre_form&quot;, {<br/>    title: &quot;Create Genre&quot;,<br/>    genre: genre,<br/>    errors: errors.array(),<br/>  });<br/>  return;<br/>} else {<br/>  // 表格中的数据有效<br/>  // 检查是否存在同名的 Genre<br/>  const genreExists = await Genre.findOne({ name: req.body.name })<br/>    .collation({ locale: &quot;en&quot;, strength: 2 })<br/>    .exec();<br/>  if (genreExists) {<br/>    // 存在同名的 Genre，则重定向到详情页面<br/>    res.redirect(genreExists.url);<br/>  } else {<br/>    await genre.save();<br/>    // 保存新创建的 Genre，然后重定向到类型的详情页面<br/>    res.redirect(genre.url);<br/>  }<br/>}<br/><br/></p><p id="1f7694d5-ea46-808e-a565-dbddf0725cd2" class="">}),<br/>];<br/></p></li></ul></li></ul><ul id="1f7694d5-ea46-8047-a4be-d713997c1d6c" class="bulleted-list"><li style="list-style-type:disc">先需要注意的是，控制器不是单个中间件函数（带有参数 <code>(req, res, next)</code>），而是指定了中间件函数<em>数组</em>。该数组传递给路由器函数并依次执行各个方法。</li></ul><ul id="1f7694d5-ea46-805e-96f6-ed3c4a03e209" class="bulleted-list"><li style="list-style-type:disc">数组中的第一个方法定义了一个 body 验证器（<code>body()</code>），用于验证和清理字段。这个方法使用 <code>trim()</code> 删除所有的首部/尾部空白，检查 <em>name</em> 字段是否为空，然后使用 <code>escape()</code> 删除任何危险的 HTML 字符。<ul id="1f7694d5-ea46-803b-bbec-d924c7e6dd32" class="bulleted-list"><li style="list-style-type:circle">[<br/>// 检验 name 字段不为空<br/>body(&quot;name&quot;, &quot;Genre name must contain at least 3 characters&quot;)<br/>.trim()<br/>.isLength({ min: 3 })<br/>.escape(),<br/>// …<br/>];<br/></li></ul></li></ul><ul id="1f7694d5-ea46-8023-8988-ef83f0337a26" class="bulleted-list"><li style="list-style-type:disc">指定验证器后，我们创建一个中间件函数来提取任何验证错误。我们使用 <code>isEmpty()</code> 来检查验证结果是否有错误。如果有，我们就再次渲染表单，传入经过清理的类型对象和错误消息数组（<code>errors.array()</code>）。<ul id="1f7694d5-ea46-809f-933c-f01bc11f0752" class="bulleted-list"><li style="list-style-type:circle">// 处理验证和清理之后的请求<br/>asyncHandler(async (req, res, next) =&gt; {<br/>// 从请求中提取验证错误<br/>const errors = validationResult(req);<br/><p id="1f7694d5-ea46-80f2-a57f-f211ce323a04" class="">// 使用经去除空白字符和转义处理的数据创建一个类型对象<br/>const genre = new Genre({ name: <br/><a href="http://req.body.name/">req.body.name</a> });</p><p id="1f7694d5-ea46-80e6-bc39-ecad0a90cf46" class="">if (!errors.isEmpty()) {<br/>// 出现错误。使用清理后的值/错误信息重新渲染表单<br/>res.render(&quot;genre_form&quot;, {<br/>title: &quot;Create Genre&quot;,<br/>genre: genre,<br/>errors: errors.array(),<br/>});<br/>return;<br/>} else {<br/>// 表单中的数据有效<br/>// …<br/>}<br/>});<br/></p></li></ul></li></ul><ul id="1f7694d5-ea46-80c7-a851-dc1d8e29e26f" class="bulleted-list"><li style="list-style-type:disc">如果类型名称数据有效，那么我们执行不区分大小写的搜索，以查看是否存在具有相同名称的 <code>Genre</code>（因为我们不想创建仅字母大小写不同的重复或过于近似的记录，例如“Fantasy”、“fantasy”、“FaNtAsY”等等）。为了在搜索时忽略掉大小写和重音，我们链式调用了 <code><a href="https://mongoosejs.com/docs/api/query.html#Query.prototype.collation()">collation()</a></code> 方法，指定“en”的区域设置和 2 的强度</li></ul><ul id="1f7694d5-ea46-80b3-959e-f39364f79d4c" class="bulleted-list"><li style="list-style-type:disc">如果匹配名称的 <code>Genre</code> 已经存在，我们将重定向到其详情页面。如果不存在，我们则保存新种类并重定向到其详情页面。请注意，这里我们 <code>await</code> 数据库的查询结果，遵循与其他路由处理器相同的模式<ul id="1f7694d5-ea46-8083-9bf8-fcffb0f18638" class="bulleted-list"><li style="list-style-type:circle">// 检查是否存在同名的 Genre<br/>const genreExists = await Genre.findOne({ name: <br/><a href="http://req.body.name/">req.body.name</a> })<br/>.collation({ locale: &quot;en&quot;, strength: 2 })<br/>.exec();<br/>if (genreExists) {<br/>// 存在同名的 Genre，则重定向到详情页面<br/>res.redirect(genreExists.url);<br/>} else {<br/>await genre.save();<br/>// 保存新创建的 Genre，然后重定向到详情页面<br/>res.redirect(genre.url);<br/>}<br/></li></ul></li></ul><ul id="1f7694d5-ea46-80f4-b17c-e808d92da94d" class="bulleted-list"><li style="list-style-type:disc">我们所有的 post 控制器中都使用了相同的模式：运行验证器（带有清理功能），然后检查错误并重新渲染带有错误信息的表单或保存数据</li></ul><p id="1f7694d5-ea46-805a-bf3d-c5f5b274975c" class="">【视图】</p><ul id="1f7694d5-ea46-8090-84a3-c485ebb7b1e3" class="bulleted-list"><li style="list-style-type:disc">当我们创建新的种类 <code>Genre</code> 时，会在 <code>GET</code> 和 <code>POST</code> 控制器/路由中渲染相同的视图（稍后当我们<em>更新</em>种类时也会使用它），在 <code>GET</code> 情况下，表单为空，我们只传递一个标题变量。在 <code>POST</code> 情况下，用户之前输入了无效数据——对于 <code>genre</code> 变量，我们回传经清理后的输入数据，对于错误变量，则回传一组错误消息。下面的代码显示了在两种情况下渲染模板的控制器代码<ul id="1f7694d5-ea46-804d-b8a9-ee562958a9e5" class="bulleted-list"><li style="list-style-type:circle">// 渲染 GET 路由<br/>res.render(&quot;genre_form&quot;, { title: &quot;Create Genre&quot; });<br/><p id="1f7694d5-ea46-8055-8c6f-c80c552a5bb6" class="">// 渲染 POST 路由<br/>res.render(&quot;genre_form&quot;, {<br/>title: &quot;Create Genre&quot;,<br/>genre,<br/>errors: errors.array(),<br/>});<br/></p></li></ul></li></ul><ul id="1f7694d5-ea46-80ec-a127-c063f4a577ca" class="bulleted-list"><li style="list-style-type:disc">创建/views/genre_from.pug，写入下面代码<ul id="1f7694d5-ea46-809c-97ba-fb21f74902c7" class="bulleted-list"><li style="list-style-type:circle">extends layout<p id="1f7694d5-ea46-8077-bb70-eab9d6a7d3ce" class="">block content</p><p id="1f7694d5-ea46-80d8-9166-da77490f76ed" class="">h1 #{title}</p><p id="1f7694d5-ea46-8077-8e05-d2b3c85a4471" class="">form(method=&#x27;POST&#x27;)<br/>div.form-group<br/>label(for=&#x27;name&#x27;) Genre:<br/>input#name.form-control(type=&#x27;text&#x27;, placeholder=&#x27;Fantasy, Poetry etc.&#x27; name=&#x27;name&#x27; required value=(undefined===genre ? &#x27;&#x27; : <br/><a href="http://genre.name/">genre.name</a>) )<br/>button.btn.btn-primary(type=&#x27;submit&#x27;) Submit<br/></p><p id="1f7694d5-ea46-80a5-bc93-f805c1087dbd" class="">if errors<br/>ul<br/>for error in errors<br/>li!= error.msg<br/></p></li></ul></li></ul><ul id="1f7694d5-ea46-80ce-8c40-e9f27415086a" class="bulleted-list"><li style="list-style-type:disc">从我们之前的教程中可以很好地理解这个模板的大部分内容。首先，我们扩展 <strong>layout.pug</strong> 基本模板并覆盖名为“<strong>content</strong>”的 <code>block</code>。然后我们使用从控制器传入 <code>title</code>（通过 <code>render()</code> 方法）创建了一个标题。</li></ul><ul id="1f7694d5-ea46-80e5-ba41-c3198301e3eb" class="bulleted-list"><li style="list-style-type:disc">接下来，pug 代码中的 HTML 表单部分则会使用 <code>method=&quot;POST&quot;</code> 方法将数据发送到服务器，并且由于 <code>action</code> 是空字符串，因此会将数据发送到与页面相同的 URL。</li></ul><ul id="1f7694d5-ea46-8016-912a-ef84448981c1" class="bulleted-list"><li style="list-style-type:disc">该表单定义了一个名为“name”的“text”类型的必填字段。该字段的默认值取决于是否定义了种类 <code>genre</code> 变量。如果从 <code>GET</code> 路由调用，它将为空，因为这是一个新表单。如果从 <code>POST</code> 路由调用，它将包含用户最初输入的（无效）值。<p id="1f7694d5-ea46-8012-8642-e87db385bc02" class="">该页面的最后一部分是错误代码。如果已定义错误变量，则只会打印错误列表（换句话说，当模板在 <code>GET</code> 路由上呈现时，此部分将不会出现）</p></li></ul><p id="1f7694d5-ea46-8055-8cea-f7ed43044c3e" class=""><strong>结果显示如下：</strong></p><figure id="1f7694d5-ea46-8022-b787-e6c52bff7eab" class="image"><a href="image%2016.png"><img style="width:561.1875px" src="image%2016.png"/></a></figure><p id="1f7694d5-ea46-806e-9fd1-f7940d3eda25" class=""><strong>002-创建作者表单：（方法同上，不过多讲述）</strong></p><p id="1f7694d5-ea46-807a-8487-efa1d033f21d" class="">【导入验证和清理方法】</p><ul id="1f7694d5-ea46-8011-a960-f04a72385e57" class="bulleted-list"><li style="list-style-type:disc">打开 <strong>/controllers/authorController.js</strong>，并将以下代码添加到文件顶部<ul id="1f7694d5-ea46-805f-a564-d1cc1111cd8b" class="bulleted-list"><li style="list-style-type:circle">const { body, validationResult } = require(&quot;express-validator&quot;);</li></ul></li></ul><p id="1f7694d5-ea46-8069-9886-e3a9f1fd8d7d" class="">【控制器-get路由】</p><ul id="1f7694d5-ea46-806e-9333-e7ccfe335e6e" class="bulleted-list"><li style="list-style-type:disc">找到导出的 <code>author_create_get()</code> 控制器方法并用以下代码替换<ul id="1f7694d5-ea46-8063-912e-f16d8b8b57cd" class="bulleted-list"><li style="list-style-type:circle">// 展示 GET 方法获取的创建作者表单<br/>exports.author_create_get = (req, res, next) =&gt; {<br/>res.render(&quot;author_form&quot;, { title: &quot;Create Author&quot; });<br/>};<br/></li></ul></li></ul><p id="1f7694d5-ea46-8047-8519-fb9ba0548c71" class="">【控制器-post路由】</p><ul id="1f7694d5-ea46-8040-84ce-d105bed58c5c" class="bulleted-list"><li style="list-style-type:disc">// 处理 POST 方法提交的创建作者表单<br/>exports.author_create_post = [<br/>// 验证并且清理字段<br/>body(&quot;first_name&quot;)<br/>.trim()<br/>.isLength({ min: 1 })<br/>.escape()<br/>.withMessage(&quot;First name must be specified.&quot;)<br/>.isAlphanumeric()<br/>.withMessage(&quot;First name has non-alphanumeric characters.&quot;),<br/>body(&quot;family_name&quot;)<br/>.trim()<br/>.isLength({ min: 1 })<br/>.escape()<br/>.withMessage(&quot;Family name must be specified.&quot;)<br/>.isAlphanumeric()<br/>.withMessage(&quot;Family name has non-alphanumeric characters.&quot;),<br/>body(&quot;date_of_birth&quot;, &quot;Invalid date of birth&quot;)<br/>.optional({ values: &quot;falsy&quot; })<br/>.isISO8601()<br/>.toDate(),<br/>body(&quot;date_of_death&quot;, &quot;Invalid date of death&quot;)<br/>.optional({ values: &quot;falsy&quot; })<br/>.isISO8601()<br/>.toDate(),<br/><p id="1f7694d5-ea46-8053-aedd-d3bdfaf97c69" class="">// 在验证和修整完字段后处理请求<br/>asyncHandler(async (req, res, next) =&gt; {<br/>// 从请求中提取验证错误<br/>const errors = validationResult(req);<br/></p><p id="1f7694d5-ea46-80f9-aaae-f7643de4f657" class="">// 使用经转义和去除空白字符处理的数据创建作者对象<br/>const author = new Author({<br/>  first_name: req.body.first_name,<br/>  family_name: req.body.family_name,<br/>  date_of_birth: req.body.date_of_birth,<br/>  date_of_death: req.body.date_of_death,<br/>});<br/><br/>if (!errors.isEmpty()) {<br/>  // 出现错误。使用清理后的值/错误信息重新渲染表单<br/>  res.render(&quot;author_form&quot;, {<br/>    title: &quot;Create Author&quot;,<br/>    author: author,<br/>    errors: errors.array(),<br/>  });<br/>  return;<br/>} else {<br/>  // 表格中的数据有效<br/><br/>  // 保存作者信息<br/>  await author.save();<br/>  // 重定向到新的作者记录<br/>  res.redirect(author.url);<br/>}<br/><br/></p><p id="1f7694d5-ea46-80bf-b129-f2369f4a25b4" class="">}),<br/>];<br/></p></li></ul><ul id="1f7694d5-ea46-8054-994e-ca78f1bdcab3" class="bulleted-list"><li style="list-style-type:disc">此代码的结构和行为几乎与创建 <code>Genre</code> 对象一致。首先，我们验证并清理数据。如果数据无效，我们将重新显示表单以及用户最初输入的数据和错误消息列表。如果数据有效，那么我们将保存新的作者记录并将用户重定向到作者详情页面。<p id="1f7694d5-ea46-8048-a12d-e1c081964cde" class="">与 <code>Genre</code> 的 post 处理器不同，我们不会在保存 <code>Author</code> 对象之前检查其是否已经存在。从某种程度上说我们应该这样做，但目前我们可能会有多个同名作者。</p></li></ul><ul id="1f7694d5-ea46-803e-89e6-e9848ef27616" class="bulleted-list"><li style="list-style-type:disc">验证代码中使用了新特性<ul id="1f7694d5-ea46-80fc-9460-e544ffd26dd0" class="bulleted-list"><li style="list-style-type:circle">链式调用验证其，使用withMessage（）指定在先前的验证方法失败时需要显示的错误消息，这使得在没有大量代码重复的情况下，提供特定的错误消息变得容易<p id="1f7694d5-ea46-8077-87fc-e97bb46fdb4c" class="">[<br/>// 验证并修整字段<br/>body(&quot;first_name&quot;)<br/>.trim()<br/>.isLength({ min: 1 })<br/>.escape()<br/>.withMessage(&quot;First name must be specified.&quot;)<br/>.isAlphanumeric()<br/>.withMessage(&quot;First name has non-alphanumeric characters.&quot;),<br/>// …<br/>];<br/></p></li></ul><ul id="1f7694d5-ea46-806a-9053-dac0860abb6d" class="bulleted-list"><li style="list-style-type:circle">使用optional（）函数，保证仅有字段输入时才会去运行后续的验证（允许验证可选字段），例如西面检查可选的出生日期是否符合ISO8601标准（传递{values：“falsy”}）对象意味着将接受空字符串或null作为空值<p id="1f7694d5-ea46-80df-843b-eda1823a390b" class="">[<br/>body(&quot;date_of_birth&quot;, &quot;Invalid date of birth&quot;)<br/>.optional({ values: &quot;falsy&quot; })<br/>.isISO8601()<br/>.toDate(),<br/>];<br/></p></li></ul><ul id="1f7694d5-ea46-806a-9880-dbd6a4230e17" class="bulleted-list"><li style="list-style-type:circle">参数以字符串形式从请求中接受，可以使用toDate（）或toBoolean（）将它们转换为正确的JS类型</li></ul></li></ul><p id="1f7694d5-ea46-8094-84bb-fe9520f451bb" class="">【视图】</p><ul id="1f7694d5-ea46-80ad-bd90-f7daeb2b8718" class="bulleted-list"><li style="list-style-type:disc">创建/views/author_from.pug<ul id="1f7694d5-ea46-80c1-b194-c0e21d1fe4cc" class="bulleted-list"><li style="list-style-type:circle"></li></ul><p id="1f7694d5-ea46-80c3-872a-c74dfc2076de" class="">extends layout</p><p id="1f7694d5-ea46-80d2-b84e-edf5b5c84afb" class="">block content<br/>h1=title<br/></p><p id="1f7694d5-ea46-8021-bb55-e9ffb0c10045" class="">form(method=&#x27;POST&#x27;)<br/>div.form-group<br/>label(for=&#x27;first_name&#x27;) First Name:<br/>input#first_name.form-control(type=&#x27;text&#x27;, placeholder=&#x27;First name (Christian)&#x27; name=&#x27;first_name&#x27; required value=(undefined===author ? &#x27;&#x27; : author.first_name) )<br/>label(for=&#x27;family_name&#x27;) Family Name:<br/>input#family_name.form-control(type=&#x27;text&#x27;, placeholder=&#x27;Family name (Surname)&#x27; name=&#x27;family_name&#x27; required value=(undefined===author ? &#x27;&#x27; : author.family_name))<br/>div.form-group<br/>label(for=&#x27;date_of_birth&#x27;) Date of birth:<br/>input#date_of_birth.form-control(type=&#x27;date&#x27; name=&#x27;date_of_birth&#x27; value=(undefined===author ? &#x27;&#x27; : author.date_of_birth) )<br/>button.btn.btn-primary(type=&#x27;submit&#x27;) Submit<br/></p><p id="1f7694d5-ea46-8038-8393-f8e003388122" class="">if errors<br/>ul<br/>for error in errors<br/>li!= error.msg<br/></p></li></ul><p id="1f7694d5-ea46-80d6-9076-e6c5226b8b44" class=""><strong>结果显示如下</strong><div class="indented"><figure id="1f7694d5-ea46-80fc-9110-f72ecbc95dd7" class="image"><a href="image%2017.png"><img style="width:535.1749877929688px" src="image%2017.png"/></a></figure></div></p><p id="1f7694d5-ea46-8043-928c-ee5623f5858f" class=""><strong>003-创建书本表单：</strong></p><p id="1f7694d5-ea46-8049-bdb9-f39611a2b1bf" class="">【导入验证和清理方法】：</p><p id="1f7694d5-ea46-8020-b967-d279b182e6aa" class="">const { body, validationResult } = require(&quot;express-validator/check&quot;);<br/>const { sanitizeBody } = require(&quot;express-validator/filter&quot;);<br/></p><p id="1f7694d5-ea46-8067-aea8-d0999802527a" class="">【控制器-get路由】</p><p id="1f7694d5-ea46-808c-a357-d97d4b4698b7" class="">// Display book create form on GET.<br/>exports.book_create_get = function (req, res, next) {<br/>// Get all authors and genres, which we can use for adding to our book.<br/>async.parallel(<br/>{<br/>authors: function (callback) {<br/>Author.find(callback);<br/>},<br/>genres: function (callback) {<br/>Genre.find(callback);<br/>},<br/>},<br/>function (err, results) {<br/>if (err) {<br/>return next(err);<br/>}<br/>res.render(&quot;book_form&quot;, {<br/>title: &quot;Create Book&quot;,<br/>authors: results.authors,<br/>genres: results.genres,<br/>});<br/>},<br/>);<br/>};<br/></p><p id="1f7694d5-ea46-8051-912d-df69ccdb605c" class="">【控制器-post路由】</p><p id="1f7694d5-ea46-8021-acce-e3c98e7fe3f4" class="">// Handle book create on POST.<br/>exports.book_create_post = [<br/>// Convert the genre to an array.<br/>(req, res, next) =&gt; {<br/>if (!(req.body.genre instanceof Array)) {<br/>if (typeof req.body.genre === &quot;undefined&quot;) req.body.genre = [];<br/>else req.body.genre = new Array(req.body.genre);<br/>}<br/>next();<br/>},<br/></p><p id="1f7694d5-ea46-80b4-81ad-ffcc8654a205" class="">// Validate fields.<br/>body(&quot;title&quot;, &quot;Title must not be empty.&quot;).isLength({ min: 1 }).trim(),<br/>body(&quot;author&quot;, &quot;Author must not be empty.&quot;).isLength({ min: 1 }).trim(),<br/>body(&quot;summary&quot;, &quot;Summary must not be empty.&quot;).isLength({ min: 1 }).trim(),<br/>body(&quot;isbn&quot;, &quot;ISBN must not be empty&quot;).isLength({ min: 1 }).trim(),<br/></p><p id="1f7694d5-ea46-80e3-b931-caf129742205" class="">// Sanitize fields (using wildcard).<br/>sanitizeBody(&quot;<br/><em>&quot;).trim().escape(),<br/>sanitizeBody(&quot;genre.<br/></em>&quot;).escape(),<br/>// Process request after validation and sanitization.<br/>(req, res, next) =&gt; {<br/>// Extract the validation errors from a request.<br/>const errors = validationResult(req);<br/></p><p id="1f7694d5-ea46-809d-ac7c-f18f729d16bc" class="">// Create a Book object with escaped and trimmed data.<br/>var book = new Book({<br/>  title: req.body.title,<br/>  author: req.body.author,<br/>  summary: req.body.summary,<br/>  isbn: req.body.isbn,<br/>  genre: req.body.genre,<br/>});<br/><br/>if (!errors.isEmpty()) {<br/>  // There are errors. Render form again with sanitized values/error messages.<br/><br/>  // Get all authors and genres for form.<br/>  async.parallel(<br/>    {<br/>      authors: function (callback) {<br/>        Author.find(callback);<br/>      },<br/>      genres: function (callback) {<br/>        Genre.find(callback);<br/>      },<br/>    },<br/>    function (err, results) {<br/>      if (err) {<br/>        return next(err);<br/>      }<br/><br/>      // Mark our selected genres as checked.<br/>      for (let i = 0; i &lt; results.genres.length; i++) {<br/>        if (book.genre.indexOf(results.genres[i]._id) &gt; -1) {<br/>          results.genres[i].checked = &quot;true&quot;;<br/>        }<br/>      }<br/>      res.render(&quot;book_form&quot;, {<br/>        title: &quot;Create Book&quot;,<br/>        authors: results.authors,<br/>        genres: results.genres,<br/>        book: book,<br/>        errors: errors.array(),<br/>      });<br/>    },<br/>  );<br/>  return;<br/>} else {<br/>  // Data from form is valid. Save book.<br/>  book.save(function (err) {<br/>    if (err) {<br/>      return next(err);<br/>    }<br/>    //successful - redirect to new book record.<br/>    res.redirect(book.url);<br/>  });<br/>}<br/><br/></p><p id="1f7694d5-ea46-80a6-89a1-c77a1a5f3898" class="">},<br/>];<br/></p><p id="1f7694d5-ea46-80fb-80df-eda6f3dc3450" class="">【视图】</p><p id="1f7694d5-ea46-800c-9c1a-fb6d2601ab4e" class="">extends layout<br/><br/>block content<br/>  h1= title<br/><br/>  form(method=&#x27;POST&#x27; action=&#x27;&#x27;)<br/>    div.form-group<br/>      label(for=&#x27;title&#x27;) Title:<br/>      input#title.form-control(type=&#x27;text&#x27;, placeholder=&#x27;Name of book&#x27; name=&#x27;title&#x27; required=&#x27;true&#x27; value=(undefined===book ? &#x27;&#x27; : book.title) )<br/>    div.form-group<br/>      label(for=&#x27;author&#x27;) Author:<br/>      select#author.form-control(type=&#x27;select&#x27;, placeholder=&#x27;Select author&#x27; name=&#x27;author&#x27; required=&#x27;true&#x27; )<br/>        for author in authors<br/>          if book<br/>            option(value=author._id selected=(author._id.toString()==book.author ? &#x27;selected&#x27; : false) ) #{author.name}<br/>          else<br/>            option(value=author._id) #{author.name}<br/>    div.form-group<br/>      label(for=&#x27;summary&#x27;) Summary:<br/>      input#summary.form-control(type=&#x27;textarea&#x27;, placeholder=&#x27;Summary&#x27; name=&#x27;summary&#x27; value=(undefined===book ? &#x27;&#x27; : book.summary) required=&#x27;true&#x27;)<br/>    div.form-group<br/>      label(for=&#x27;isbn&#x27;) ISBN:<br/>      input#isbn.form-control(type=&#x27;text&#x27;, placeholder=&#x27;ISBN13&#x27; name=&#x27;isbn&#x27; value=(undefined===book ? &#x27;&#x27; : book.isbn) required=&#x27;true&#x27;)<br/>    div.form-group<br/>      label Genre:<br/>      div<br/>        for genre in genres<br/>          div(style=&#x27;display: inline; padding-right:10px;&#x27;)<br/>            input.checkbox-input(type=&#x27;checkbox&#x27;, name=&#x27;genre&#x27;, id=genre._id, value=genre._id, checked=genre.checked )<br/>            label(for=genre._id) #{genre.name}<br/>    button.btn.btn-primary(type=&#x27;submit&#x27;) Submit<br/><br/>  if errors<br/>    ul<br/>      for error in errors<br/>        li!= error.msg<br/></p><p id="1f7694d5-ea46-8039-9fd0-e447162d159a" class=""><strong>结果展示如下</strong></p><figure id="1f7694d5-ea46-800e-9fd0-e56e79c6a0d6" class="image"><a href="image%2018.png"><img style="width:561.1875px" src="image%2018.png"/></a></figure><p id="1f7694d5-ea46-80b6-99d2-e68f1c660c5c" class=""><strong>004-创建书本实例表单：</strong></p><p id="1f7694d5-ea46-807d-b8d8-f1790f592d7d" class="">【导入验证和清理】</p><p id="1f7694d5-ea46-8056-97e9-cd192108fa15" class="">const { body, validationResult } = require(&quot;express-validator/check&quot;);<br/>const { sanitizeBody } = require(&quot;express-validator/filter&quot;);<br/></p><p id="1f7694d5-ea46-802f-b9b9-cd91068eaa7b" class="">【控制器-get路由】</p><p id="1f7694d5-ea46-8086-a057-cc0f0946bf18" class="">var Book = require(&quot;../models/book&quot;);</p><p id="1f7694d5-ea46-8096-be91-c3ab10bfacfc" class="">
</p><p id="1f7694d5-ea46-802f-96a4-c635f2d03deb" class="">// Display BookInstance create form on GET.<br/>exports.bookinstance_create_get = function (req, res, next) {<br/>Book.find({}, &quot;title&quot;).exec(function (err, books) {<br/>if (err) {<br/>return next(err);<br/>}<br/>// Successful, so render.<br/>res.render(&quot;bookinstance_form&quot;, {<br/>title: &quot;Create BookInstance&quot;,<br/>book_list: books,<br/>});<br/>});<br/>};<br/></p><p id="1f7694d5-ea46-8028-81a0-e9e9dba9ecc3" class="">【控制器-post路由】</p><p id="1f7694d5-ea46-806a-b034-d69fef2d0a11" class="">// Handle BookInstance create on POST.<br/>exports.bookinstance_create_post = [<br/>// Validate fields.<br/>body(&quot;book&quot;, &quot;Book must be specified&quot;).isLength({ min: 1 }).trim(),<br/>body(&quot;imprint&quot;, &quot;Imprint must be specified&quot;).isLength({ min: 1 }).trim(),<br/>body(&quot;due_back&quot;, &quot;Invalid date&quot;).optional({ checkFalsy: true }).isISO8601(),<br/></p><p id="1f7694d5-ea46-80e8-a1ab-e1d8f0050449" class="">// Sanitize fields.<br/>sanitizeBody(&quot;book&quot;).trim().escape(),<br/>sanitizeBody(&quot;imprint&quot;).trim().escape(),<br/>sanitizeBody(&quot;status&quot;).trim().escape(),<br/>sanitizeBody(&quot;due_back&quot;).toDate(),<br/></p><p id="1f7694d5-ea46-8096-89c7-e77d3e969552" class="">// Process request after validation and sanitization.<br/>(req, res, next) =&gt; {<br/>// Extract the validation errors from a request.<br/>const errors = validationResult(req);<br/></p><p id="1f7694d5-ea46-80aa-b2e6-d0b8e689e2cb" class="">// Create a BookInstance object with escaped and trimmed data.<br/>var bookinstance = new BookInstance({<br/>  book: req.body.book,<br/>  imprint: req.body.imprint,<br/>  status: req.body.status,<br/>  due_back: req.body.due_back,<br/>});<br/><br/>if (!errors.isEmpty()) {<br/>  // There are errors. Render form again with sanitized values and error messages.<br/>  Book.find({}, &quot;title&quot;).exec(function (err, books) {<br/>    if (err) {<br/>      return next(err);<br/>    }<br/>    // Successful, so render.<br/>    res.render(&quot;bookinstance_form&quot;, {<br/>      title: &quot;Create BookInstance&quot;,<br/>      book_list: books,<br/>      selected_book: bookinstance.book._id,<br/>      errors: errors.array(),<br/>      bookinstance: bookinstance,<br/>    });<br/>  });<br/>  return;<br/>} else {<br/>  // Data from form is valid.<br/>  bookinstance.save(function (err) {<br/>    if (err) {<br/>      return next(err);<br/>    }<br/>    // Successful - redirect to new record.<br/>    res.redirect(bookinstance.url);<br/>  });<br/>}<br/><br/></p><p id="1f7694d5-ea46-8057-8537-c5720378f5e4" class="">},<br/>];<br/></p><p id="1f7694d5-ea46-8071-8a8d-e56cd53afc81" class="">【视图】</p><p id="1f7694d5-ea46-8033-bcf8-e5a8375cc3b5" class="">extends layout<br/><br/>block content<br/>  h1=title<br/><br/>  form(method=&#x27;POST&#x27; action=&#x27;&#x27;)<br/>    div.form-group<br/>      label(for=&#x27;book&#x27;) Book:<br/>      select#book.form-control(type=&#x27;select&#x27; placeholder=&#x27;Select book&#x27; name=&#x27;book&#x27; required=&#x27;true&#x27;)<br/>        for book in book_list<br/>          if bookinstance<br/>            option(value=book._id selected=(bookinstance.book.toString()==book._id.toString() ? &#x27;selected&#x27; : false)) #{book.title}<br/>          else<br/>            option(value=book._id) #{book.title}<br/><br/>    div.form-group<br/>      label(for=&#x27;imprint&#x27;) Imprint:<br/>      input#imprint.form-control(type=&#x27;text&#x27; placeholder=&#x27;Publisher and date information&#x27; name=&#x27;imprint&#x27; required=&#x27;true&#x27; value=(undefined===bookinstance ? &#x27;&#x27; : bookinstance.imprint))<br/>    div.form-group<br/>      label(for=&#x27;due_back&#x27;) Date when book available:<br/>      input#due_back.form-control(type=&#x27;date&#x27; name=&#x27;due_back&#x27; value=(undefined===bookinstance ? &#x27;&#x27; : bookinstance.due_back))<br/><br/>    div.form-group<br/>      label(for=&#x27;status&#x27;) Status:<br/>      select#status.form-control(type=&#x27;select&#x27; placeholder=&#x27;Select status&#x27; name=&#x27;status&#x27; required=&#x27;true&#x27;)<br/>        option(value=&#x27;Maintenance&#x27;) Maintenance<br/>        option(value=&#x27;Available&#x27;) Available<br/>        option(value=&#x27;Loaned&#x27;) Loaned<br/>        option(value=&#x27;Reserved&#x27;) Reserved<br/><br/>    button.btn.btn-primary(type=&#x27;submit&#x27;) Submit<br/><br/>  if errors<br/>    ul<br/>      for error in errors<br/>        li!= error.msg<br/></p><p id="1f7694d5-ea46-8019-888b-f6d71cf97787" class=""><strong>结果展示如下</strong></p><figure id="1f7694d5-ea46-80ce-bd66-e958bc828960" class="image"><a href="image%2019.png"><img style="width:561.1875px" src="image%2019.png"/></a></figure><p id="1f7694d5-ea46-8002-b7ec-cabacd658d5a" class="">
</p><p id="1f7694d5-ea46-80d9-8508-e1b4e02a142b" class=""><strong>005-删除作者表单</strong></p><p id="1f7694d5-ea46-8009-834a-c84fa9a9b958" class="">【控制器-get路由】</p><p id="1f7694d5-ea46-807b-9243-dae8c437d60f" class="">// Display Author delete form on GET.<br/>exports.author_delete_get = function (req, res, next) {<br/>async.parallel(<br/>{<br/>author: function (callback) {<br/>Author.findById(<br/><a href="http://req.params.id/">req.params.id</a>).exec(callback);<br/>},<br/>authors_books: function (callback) {<br/>Book.find({ author: <br/><a href="http://req.params.id/">req.params.id</a> }).exec(callback);<br/>},<br/>},<br/>function (err, results) {<br/>if (err) {<br/>return next(err);<br/>}<br/>if (results.author == null) {<br/>// No results.<br/>res.redirect(&quot;/catalog/authors&quot;);<br/>}<br/>// Successful, so render.<br/>res.render(&quot;author_delete&quot;, {<br/>title: &quot;Delete Author&quot;,<br/>author: results.author,<br/>author_books: results.authors_books,<br/>});<br/>},<br/>);<br/>};<br/></p><ul id="1f7694d5-ea46-8014-a138-e5e76ba1f181" class="bulleted-list"><li style="list-style-type:disc">控制器从 URL 参数（<code>req.params.id</code>）中，获取要删除的 <code>Author</code> 实例的 id。它使用 <code>async.parallel()</code> 方法，并行获取作者记录和所有相关书本。当两个操作都完成后，它将呈现 <strong>author_delete.pug</strong> 视图，为 <code>title</code>、<code>author</code> 和 <code>author_books</code> 传递变量。</li></ul><p id="1f7694d5-ea46-80af-b7ae-de2cd828a8a5" class="">【控制器-post路由】</p><p id="1f7694d5-ea46-80c5-b71f-f7ba903985db" class="">// Handle Author delete on POST.<br/>exports.author_delete_post = function (req, res, next) {<br/>async.parallel(<br/>{<br/>author: function (callback) {<br/>Author.findById(req.body.authorid).exec(callback);<br/>},<br/>authors_books: function (callback) {<br/>Book.find({ author: req.body.authorid }).exec(callback);<br/>},<br/>},<br/>function (err, results) {<br/>if (err) {<br/>return next(err);<br/>}<br/>// Success<br/>if (results.authors_books.length &gt; 0) {<br/>// Author has books. Render in same way as for GET route.<br/>res.render(&quot;author_delete&quot;, {<br/>title: &quot;Delete Author&quot;,<br/>author: results.author,<br/>author_books: results.authors_books,<br/>});<br/>return;<br/>} else {<br/>// Author has no books. Delete object and redirect to the list of authors.<br/>Author.findByIdAndRemove(req.body.authorid, function deleteAuthor(err) {<br/>if (err) {<br/>return next(err);<br/>}<br/>// Success - go to author list<br/>res.redirect(&quot;/catalog/authors&quot;);<br/>});<br/>}<br/>},<br/>);<br/>};<br/></p><ul id="1f7694d5-ea46-8006-a51e-ec2ede667206" class="bulleted-list"><li style="list-style-type:disc">首先，我们验证是否已提供 id（这是通过表单主体参数发送的，而不是使用 URL 中的版本）。然后我们以与 <code>GET</code> 路由相同的方式，获得作者及其相关书本。如果没有书本，那么我们删除作者对象，并重定向到所有作者的列表。如果还有书本，那么我们只需重新呈现表格，传递作者和要删除的书本列表。</li></ul><p id="1f7694d5-ea46-8031-a02c-e9408c7886f1" class="">【视图】</p><ul id="1f7694d5-ea46-8048-a200-ce0d5f4640e0" class="bulleted-list"><li style="list-style-type:disc">创建views/author_delete.pug<ul id="1f7694d5-ea46-80d4-ae92-e8ef60de4e8c" class="bulleted-list"><li style="list-style-type:circle"></li></ul><p id="1f7694d5-ea46-8038-9e78-e6e8cc6f8654" class="">extends layout<br/><br/>block content<br/>  h1 #{title}: #{author.name}<br/>  p= author.lifespan<br/><br/>  if author_books.length<br/><br/>    p #[strong Delete the following books before attempting to delete this author.]<br/><br/>    div(style=&#x27;margin-left:20px;margin-top:20px&#x27;)<br/><br/>      h4 Books<br/><br/>      dl<br/>      each book in author_books<br/>        dt<br/>          a(href=book.url) #{book.title}<br/>        dd #{book.summary}<br/><br/>  else<br/>    p Do you really want to delete this Author?<br/><br/>    form(method=&#x27;POST&#x27; action=&#x27;&#x27;)<br/>      div.form-group<br/>        input#authorid.form-control(type=&#x27;hidden&#x27;,name=&#x27;authorid&#x27;, required=&#x27;true&#x27;, value=author._id )<br/><br/>      button.btn.btn-primary(type=&#x27;submit&#x27;) Delete<br/></p></li></ul><p id="1f7694d5-ea46-804c-9727-fbbf4cb32057" class="">视图扩展了布局模板，覆盖了名为 <code>content</code> 的区块。在顶部显示作者详细信息。然后它包含一个，基于 <code>author_books</code>（<code>if</code> 和 <code>else</code> 子句）数量的条件语句。</p><ul id="1f7694d5-ea46-80db-9217-f50ae888aa7e" class="bulleted-list"><li style="list-style-type:disc">如果存在与作者相关联的书本，则该页面列出书本，并说明在删除该作者 <code>Author</code> 之前，必须删除这些书籍。</li></ul><ul id="1f7694d5-ea46-8067-8c6d-c88068d2e1cb" class="bulleted-list"><li style="list-style-type:disc">如果没有书本，则页面会显示确认提示。如果单击“删除”按钮，则会在 <code>POST</code> 请求中，将作者 ID 发送到服务器，并且将删除该作者的记录。</li></ul><p id="1f7694d5-ea46-806e-a1af-df81bdb3e0fa" class=""><strong>006-更新书本表单：</strong></p><p id="1f7694d5-ea46-80ef-9d90-c3e19c571832" class="">【控制器-get路由】</p><p id="1f7694d5-ea46-80b1-a105-f382e8661f43" class="">// Display book update form on GET.<br/>exports.book_update_get = function (req, res, next) {<br/>// Get book, authors and genres for form.<br/>async.parallel(<br/>{<br/>book: function (callback) {<br/>Book.findById(<br/><a href="http://req.params.id/">req.params.id</a>)<br/>.populate(&quot;author&quot;)<br/>.populate(&quot;genre&quot;)<br/>.exec(callback);<br/>},<br/>authors: function (callback) {<br/>Author.find(callback);<br/>},<br/>genres: function (callback) {<br/>Genre.find(callback);<br/>},<br/>},<br/>function (err, results) {<br/>if (err) {<br/>return next(err);<br/>}<br/>if (results.book == null) {<br/>// No results.<br/>var err = new Error(&quot;Book not found&quot;);<br/>err.status = 404;<br/>return next(err);<br/>}<br/>// Success.<br/>// Mark our selected genres as checked.<br/>for (<br/>var all_g_iter = 0;<br/>all_g_iter &lt; results.genres.length;<br/>all_g_iter++<br/>) {<br/>for (<br/>var book_g_iter = 0;<br/>book_g_iter &lt; results.book.genre.length;<br/>book_g_iter++<br/>) {<br/>if (<br/>results.genres[all_g_iter]._id.toString() ==<br/>results.book.genre[book_g_iter]._id.toString()<br/>) {<br/>results.genres[all_g_iter].checked = &quot;true&quot;;<br/>}<br/>}<br/>}<br/>res.render(&quot;book_form&quot;, {<br/>title: &quot;Update Book&quot;,<br/>authors: results.authors,<br/>genres: results.genres,<br/>book: results.book,<br/>});<br/>},<br/>);<br/>};<br/></p><p id="1f7694d5-ea46-80cf-a756-c3fe8624056e" class="">【控制器-post路由】</p><p id="1f7694d5-ea46-80fe-8b81-dcc44e50a23c" class="">// Handle book update on POST.<br/>exports.book_update_post = [<br/>// Convert the genre to an array<br/>(req, res, next) =&gt; {<br/>if (!(req.body.genre instanceof Array)) {<br/>if (typeof req.body.genre === &quot;undefined&quot;) req.body.genre = [];<br/>else req.body.genre = new Array(req.body.genre);<br/>}<br/>next();<br/>},<br/></p><p id="1f7694d5-ea46-80a3-a226-f917903e30ab" class="">// Validate fields.<br/>body(&quot;title&quot;, &quot;Title must not be empty.&quot;).isLength({ min: 1 }).trim(),<br/>body(&quot;author&quot;, &quot;Author must not be empty.&quot;).isLength({ min: 1 }).trim(),<br/>body(&quot;summary&quot;, &quot;Summary must not be empty.&quot;).isLength({ min: 1 }).trim(),<br/>body(&quot;isbn&quot;, &quot;ISBN must not be empty&quot;).isLength({ min: 1 }).trim(),<br/></p><p id="1f7694d5-ea46-807b-be7d-cafb9f374c91" class="">// Sanitize fields.<br/>sanitizeBody(&quot;title&quot;).trim().escape(),<br/>sanitizeBody(&quot;author&quot;).trim().escape(),<br/>sanitizeBody(&quot;summary&quot;).trim().escape(),<br/>sanitizeBody(&quot;isbn&quot;).trim().escape(),<br/>sanitizeBody(&quot;genre.*&quot;).trim().escape(),<br/></p><p id="1f7694d5-ea46-80fe-9555-de3808fe211e" class="">// Process request after validation and sanitization.<br/>(req, res, next) =&gt; {<br/>// Extract the validation errors from a request.<br/>const errors = validationResult(req);<br/></p><p id="1f7694d5-ea46-80e5-b0c8-dbaf922dfd12" class="">// Create a Book object with escaped/trimmed data and old id.<br/>var book = new Book({<br/>  title: req.body.title,<br/>  author: req.body.author,<br/>  summary: req.body.summary,<br/>  isbn: req.body.isbn,<br/>  genre: typeof req.body.genre === &quot;undefined&quot; ? [] : req.body.genre,<br/>  _id: req.params.id, //This is required, or a new ID will be assigned!<br/>});<br/><br/>if (!errors.isEmpty()) {<br/>  // There are errors. Render form again with sanitized values/error messages.<br/><br/>  // Get all authors and genres for form.<br/>  async.parallel(<br/>    {<br/>      authors: function (callback) {<br/>        Author.find(callback);<br/>      },<br/>      genres: function (callback) {<br/>        Genre.find(callback);<br/>      },<br/>    },<br/>    function (err, results) {<br/>      if (err) {<br/>        return next(err);<br/>      }<br/><br/>      // Mark our selected genres as checked.<br/>      for (let i = 0; i &lt; results.genres.length; i++) {<br/>        if (book.genre.indexOf(results.genres[i]._id) &gt; -1) {<br/>          results.genres[i].checked = &quot;true&quot;;<br/>        }<br/>      }<br/>      res.render(&quot;book_form&quot;, {<br/>        title: &quot;Update Book&quot;,<br/>        authors: results.authors,<br/>        genres: results.genres,<br/>        book: book,<br/>        errors: errors.array(),<br/>      });<br/>    },<br/>  );<br/>  return;<br/>} else {<br/>  // Data from form is valid. Update the record.<br/>  Book.findByIdAndUpdate(req.params.id, book, {}, function (err, thebook) {<br/>    if (err) {<br/>      return next(err);<br/>    }<br/>    // Successful - redirect to book detail page.<br/>    res.redirect(thebook.url);<br/>  });<br/>}<br/><br/></p><p id="1f7694d5-ea46-8003-b716-e27f88562d86" class="">},<br/>];<br/></p><p id="1f7694d5-ea46-802b-bf9b-de46cf530cff" class="">【视图】</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f7694d5-ea46-8094-8ad2-c729ec19ac1b" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">iv.form-group
      label(for=&#x27;author&#x27;) Author:
      select#author.form-control(type=&#x27;select&#x27; placeholder=&#x27;Select author&#x27; name=&#x27;author&#x27; required=&#x27;true&#x27; )
        for author in authors
          if book
            //- Handle GET form, where book.author is an object, and POST form, where it is a string.
            option(
              value=author._id
              selected=(
                author._id.toString()==book.author._id
                || author._id.toString()==book.author
              ) ? &#x27;selected&#x27; : false
            ) #{author.name}
          else
            option(value=author._id) #{author.name}</code></pre><p id="1f7694d5-ea46-80a0-aed8-d0c618a3f898" class=""><strong>结果展示如下</strong></p><figure id="1f7694d5-ea46-80f8-a563-d82211e9f5e0" class="image"><a href="image%2020.png"><img style="width:561.2000122070312px" src="image%2020.png"/></a></figure><p id="1f8694d5-ea46-80fa-ace6-e25ef95a3447" class="">
</p><p id="1f8694d5-ea46-80dd-8e8d-d9bcf725d567" class=""><strong><span style="border-bottom:0.05em solid">【第六步-部署到生产环境】</span></strong></p><p id="1f8694d5-ea46-80ef-bac4-c7095fc4edeb" class="">现在以及创建一个本地图书馆网站，可以将其发布到公共网络服务器，网络上其他成员可以访问。</p><p id="1f8694d5-ea46-80ab-833d-c56e705f5a90" class="">该步骤总结了如何使用一台主机部署网站</p><p id="1f8694d5-ea46-80a5-995f-f872117e07b8" class="">
</p><p id="1f8694d5-ea46-8067-bfbe-c0a654fbf898" class=""><strong>概览：</strong></p><ul id="1f8694d5-ea46-809d-91bc-e6232afcdd87" class="bulleted-list"><li style="list-style-type:disc">站点完成之后，可以将其托管在比个人开发计算机更公开可访问的地方</li></ul><ul id="1f8694d5-ea46-800b-ada6-f3765bba4db4" class="bulleted-list"><li style="list-style-type:disc">目前为止，一直在开发环境中工作，使用Express/Node作为web服务器，将网站共享到本地浏览器中，使用不安全的开发设置运行网站，来显示调试和其他私人信息。在外部托管网站之前，必须要<ul id="1f8694d5-ea46-8003-9f94-d74882c55f99" class="bulleted-list"><li style="list-style-type:circle">选择托管Express应用程序的环节</li></ul><ul id="1f8694d5-ea46-8040-83e6-e52348d5fcb4" class="bulleted-list"><li style="list-style-type:circle">对项目设置进行更改</li></ul><ul id="1f8694d5-ea46-808b-aa5e-ea3193d0cb23" class="bulleted-list"><li style="list-style-type:circle">设置生产级别的基础架构，来服务网站</li></ul></li></ul><ul id="1f8694d5-ea46-8000-b189-f82024881c1a" class="bulleted-list"><li style="list-style-type:disc">本步骤介绍有关托管站点选项的指导，简要概述了未Express应用程序准备好生产所需执行的操作，以及将图书馆网站安装到Heroku云托管商的工作实例</li></ul><ul id="1f8694d5-ea46-804f-b7d5-e8ee1a464aee" class="bulleted-list"><li style="list-style-type:disc">这里使用Heroku，不必须使用，也可以使用其他托管服务。</li></ul><p id="1f8694d5-ea46-802b-a171-c1efc0f16e42" class="">
</p><p id="1f8694d5-ea46-80eb-b698-f5c83adb85cf" class=""><strong>什么生产环境：</strong></p><ul id="1f8694d5-ea46-80bf-bc9d-d7bda7105904" class="bulleted-list"><li style="list-style-type:disc">生产环境是服务器计算机提供的环境，可以在其中运行网站，供外部使用。环境包括<ul id="1f8694d5-ea46-80eb-9db7-f3d806a77907" class="bulleted-list"><li style="list-style-type:circle">网站运行的计算机硬件</li></ul><ul id="1f8694d5-ea46-8076-973b-db8833a96278" class="bulleted-list"><li style="list-style-type:circle">操作系统，windows</li></ul><ul id="1f8694d5-ea46-808a-9dfd-cfd3e916d1c0" class="bulleted-list"><li style="list-style-type:circle">编程语言运行库和框架库，在上面编写网站</li></ul><ul id="1f8694d5-ea46-8081-acf1-e4150348e4cb" class="bulleted-list"><li style="list-style-type:circle">Web服务器基础结构，可能包含Web服务器，反向代理，负载平衡器等</li></ul><ul id="1f8694d5-ea46-8034-b3a3-e86c25a13321" class="bulleted-list"><li style="list-style-type:circle">网站所依赖的数据库</li></ul></li></ul><ul id="1f8694d5-ea46-80dc-9400-fd2eb7e11c5f" class="bulleted-list"><li style="list-style-type:disc">服务计算机，可以位于场所，使用款苏链接，连接到internet，使用托管在云服务器上的计算机更为常见。这意味着，代码运行在托管公司的数据中心的某台远程计算机或虚拟计算机上。远程服务器会以特定价格提供互联网连接，和一些保证级别的计算资源，例如CPU RAM 存储器等</li></ul><ul id="1f8694d5-ea46-80c1-900b-c91dfbdbf458" class="bulleted-list"><li style="list-style-type:disc">这种可以远程访问的计算/网络硬件，被称为基础架构即服务laaS。许多laaS供应商提供项目安装特定操作系统的选项，在必须上面安装生产环境的其他组件，其他供应商允许选择功能更全面的环境，包括完整的node设置。</li></ul><ul id="1f8694d5-ea46-8042-bfcb-df6fd90d427d" class="bulleted-list"><li style="list-style-type:disc">其他托管服务器提供商，支持Express作为平台即服务PaaS产品的一部分，使用此类托管时，不必担心大多数生产环境。因为主机平台会矗立着新问题，这使得部署非常简单，因为只需要专注于Web应用程序，而不是任何其他服务器基础结构</li></ul><ul id="1f8694d5-ea46-8094-844e-eb11e3fe0925" class="bulleted-list"><li style="list-style-type:disc">一些开发人员选择laaS，相对于PaaS，laaS提供更灵活，而其他开发人员偏好PaaS降低维护开销和更轻松地扩展性。一开始使用时，在PaaS系统上设置网站，要更容易</li></ul><p id="1f8694d5-ea46-801e-97cd-f288ea80cae0" class="">
</p><p id="1f8694d5-ea46-8012-a6c4-ffba4cbf0d22" class=""><strong>选择主机供应商：</strong></p><ul id="1f8694d5-ea46-80af-8dd9-d0de9cbdfaac" class="bulleted-list"><li style="list-style-type:disc">众多托管服务提供商，都积极支持与Node合作，提供不同类型的环境LaaS\PaaS，不同的价格不同界别的计算和网络资源</li></ul><ul id="1f8694d5-ea46-804b-8d2c-db48b23ad6b1" class="bulleted-list"><li style="list-style-type:disc">选择主机时考虑的事项<ul id="1f8694d5-ea46-808b-a88d-f73736c88287" class="bulleted-list"><li style="list-style-type:circle">网站可能有多忙，以及满足该需求所需的数据，和计算资源的成本</li></ul><ul id="1f8694d5-ea46-8029-bd7d-c876ae352ec1" class="bulleted-list"><li style="list-style-type:circle">水平扩展（添加更多机器），垂直扩展（升级更强大机器）的支持级别，以及这样做的成本</li></ul><ul id="1f8694d5-ea46-80cb-be11-ef80e74d7dcf" class="bulleted-list"><li style="list-style-type:circle">供应商有数据中心的地方，访问更快</li></ul><ul id="1f8694d5-ea46-80da-b96b-e46641d36afb" class="bulleted-list"><li style="list-style-type:circle">注意正常运行时间和停机时间的历史表现</li></ul><ul id="1f8694d5-ea46-8054-8b31-f9116f1b9eb2" class="bulleted-list"><li style="list-style-type:circle">用于管理站点的工具-易于使用且安全，例如SFTP和FTP</li></ul><ul id="1f8694d5-ea46-8089-86f0-fec7fdd35bf6" class="bulleted-list"><li style="list-style-type:circle">用于监控服务器的内置框架</li></ul><ul id="1f8694d5-ea46-8064-bcf5-e68a142cfc87" class="bulleted-list"><li style="list-style-type:circle">已知限制。有些主机会故意阻止某些服务，例如电子邮件。其他在某些价格层中，仅提供一定小时的事件，或仅提供少量存储空间</li></ul><ul id="1f8694d5-ea46-80da-b311-fec9e31924a0" class="bulleted-list"><li style="list-style-type:circle">额外的好处，一些提供商会提供免费域名和SSL证书支持，否则将不得不为此另外支付费用</li></ul><ul id="1f8694d5-ea46-80a4-98e9-fe3940586a44" class="bulleted-list"><li style="list-style-type:circle">所依赖的免费等级，是否会随时间推移而过期，以及迁移到更昂贵的成本，是否意味着最好在一开始就使用其他服务</li></ul></li></ul><ul id="1f8694d5-ea46-80cf-b0b4-f24befc68b49" class="bulleted-list"><li style="list-style-type:disc">当你刚开始时，好消息是有很多网站提供“免费”的计算环境，尽管有一些条件。例如， <a href="https://www.heroku.com/">Heroku</a> “永远”提供免费但资源有限的 PaaS 环境，而 <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/billing-free-tier.html">Amazon Web Services</a>, <a href="https://azure.microsoft.com/en-us/pricing/details/app-service/">Microsoft Azure</a> 和开源选项 PWS/Cloud Foundry 在你第一次加入时，提供免费信用额度。<p id="1f8694d5-ea46-80cb-8df2-ca409ef07360" class="">许多提供商还拥有“基本”层，可提供更多有用的计算能力，和更少的限制。举例来说， <a href="https://www.digitalocean.com/">Digital Ocean</a> 是一个流行的托管服务提供商，它提供了一个相对便宜的基本计算层（在本教程写作时，是每月 5 美元的较低范围）。</p></li></ul><ul id="1f8694d5-ea46-8087-a677-ff64eb190eb5" class="bulleted-list"><li style="list-style-type:disc">注意，价格不是唯一选择标准，网站成功，可能会发现可扩展性是最重要的考虑因素</li></ul><p id="1f8694d5-ea46-8089-a34e-d56a8d0b3681" class="">
</p><p id="1f8694d5-ea46-802b-b758-df63d19443ef" class=""><strong>准备好发布的网站：</strong></p><ul id="1f8694d5-ea46-80b7-974a-e3c1f9b1b43d" class="bulleted-list"><li style="list-style-type:disc">发布网站时，要考虑的主要问题时网络安全性和性能，至少，需要删除开发期间，错误页面上包含的堆栈跟踪，整理日志记录，设置适当的标头，避免许多常见的安全威胁</li></ul><ul id="1f8694d5-ea46-8011-a035-d2709b4af03d" class="bulleted-list"><li style="list-style-type:disc">以下是对应用进行最重要的修改<ul id="1f8694d5-ea46-80d2-9c1a-d60c33f7e9ec" class="bulleted-list"><li style="list-style-type:circle">设置NODE_DEV为production</li></ul><ul id="1f8694d5-ea46-80eb-8b6b-da9e70f96e53" class="bulleted-list"><li style="list-style-type:circle">Log appropriately</li></ul><ul id="1f8694d5-ea46-8015-b31d-cfc829041dfe" class="bulleted-list"><li style="list-style-type:circle">使用gzip/deflate压缩响应文件</li></ul><ul id="1f8694d5-ea46-8086-a0eb-d5792d1d8c3c" class="bulleted-list"><li style="list-style-type:circle">使用Helmet避免被常见漏洞侵袭</li></ul></li></ul><p id="1f8694d5-ea46-8003-8177-fd2877e5a23c" class="">
</p><p id="1f8694d5-ea46-806d-b4ea-f92b7bb6c99f" class="">【设置NODE_dEV为production】</p><ul id="1f8694d5-ea46-80de-9d07-e8e813b5768b" class="bulleted-list"><li style="list-style-type:disc">将NODE_ENV环境变量设置为production，来删除错误页面中的堆栈跟踪（默认设置为development），处理生成较为不详细的错误信息之外，还要将变量设置为生产缓存视图模板，和从CSS扩展生成的CSS文件。</li></ul><ul id="1f8694d5-ea46-80f8-bcb2-fae4477f7101" class="bulleted-list"><li style="list-style-type:disc">测试表明将NODE_DEV设置为生产production，可以将应用性能提高三倍。</li></ul><ul id="1f8694d5-ea46-8077-a111-cbf259b4009e" class="bulleted-list"><li style="list-style-type:disc">使用导出或环境文件，或使用OS初始化系统，以进行修改<figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1f8694d5-ea46-80e7-a63c-eea316af0b87"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="1f8694d5-ea46-8072-a348-fc516839814d" class="">这里实际是在环境设置，而不是应用中的更改，但重要的是，要注意下面如何为托管设置</p></div></figure></li></ul><p id="1f8694d5-ea46-801f-ade8-d73cabfb599d" class="">
</p><p id="1f8694d5-ea46-8027-a44f-c0743846e161" class="">【Log appropriately】</p><ul id="1f8694d5-ea46-806d-81e7-ca0580544c77" class="bulleted-list"><li style="list-style-type:disc">记录呼叫会对高流量网站产生影响，在生产环境中，可能需要记录网站活动（例如跟踪流量，或记录API调用。），应该尝试最小化为调试目的而添加的日志记录量</li></ul><ul id="1f8694d5-ea46-80ca-94c1-e6328c7953be" class="bulleted-list"><li style="list-style-type:disc">在生产环境中，最小化调试日志记录是一种方法，使用类似调试debug的模块，允许通过设置环境变量，来控制执行的日志记录。<ul id="1f8694d5-ea46-80ea-88e4-d0ef0137ef7c" class="bulleted-list"><li style="list-style-type:circle">例如，下面的代码片段，显示了如何设置author日志记录，调试变量使用名称author声明，自动显示名来自此对象的所有日志前缀author<ul id="1f8694d5-ea46-80d9-a1fa-d5ce42088a94" class="bulleted-list"><li style="list-style-type:square"></li></ul><p id="1f8694d5-ea46-809e-9986-d8fa31391a40" class="">var debug = require(&quot;debug&quot;)(&quot;author&quot;);</p><p id="1f8694d5-ea46-808d-91ab-f9ae9cbd4d49" class="">// Display Author update form on GET<br/>exports.author_update_get = function (req, res, next) {<br/>req.sanitize(&quot;id&quot;).escape().trim();<br/>Author.findById(<br/><a href="http://req.params.id/">req.params.id</a>, function (err, author) {<br/>if (err) {<br/>debug(&quot;update error:&quot; + err);<br/>return next(err);<br/>}<br/>//On success<br/>res.render(&quot;author_form&quot;, { title: &quot;Update Author&quot;, author: author });<br/>});<br/>};<br/></p></li></ul><ul id="1f8694d5-ea46-807b-9f20-c16b2bcfc628" class="bulleted-list"><li style="list-style-type:circle">可以通过在DEBUG环境变量中，将他们指定为逗号分隔列表，来启用特定日志集，可以设置显示作者和书籍日志的变量，如图所示，也支持通配符<ul id="1f8694d5-ea46-8011-acea-ec879fd0fb59" class="bulleted-list"><li style="list-style-type:square"></li></ul><p id="1f8694d5-ea46-805a-bae9-ffe46f0940bd" class="">#Windows<br/>set DEBUG=author,book<br/></p><p id="1f8694d5-ea46-80d1-89ff-d0b921b6c89c" class="">#Linux<br/>export DEBUG=&quot;author,book&quot;<br/></p></li></ul></li></ul><ul id="1f8694d5-ea46-8041-a3d3-c8a303ecd531" class="bulleted-list"><li style="list-style-type:disc">调用<code>debug</code>可以替换你以前使用<code>console.log()</code>或<code>console.error()</code>执行的日志记录。通过调试模块<a href="https://www.npmjs.com/package/debug">debug</a>进行日志记录，替换代码中的所有<code>console.log()</code>调用。通过设置 DEBUG 变量，并在其中记录对日志记录的影响，在开发环境中，打开和关闭日志记录。</li></ul><p id="1f8694d5-ea46-80f4-8011-c37c4d70e5cc" class="">
</p><p id="1f8694d5-ea46-80ec-81af-c11f75aedcad" class="">【使用gzip/deflate压缩响应文件】</p><ul id="1f8694d5-ea46-80f5-b013-fa06556954ad" class="bulleted-list"><li style="list-style-type:disc">Web服务器，通常可以压缩发送给回客户端的HTTP响应，从而减少客户端获取和加载页面所需要的时间，使用的压缩方法，取决于客户端在请求中支持的解压缩方法。如果不支持压缩方法，响应将以未压缩的方式发送<ul id="1f8694d5-ea46-8090-b381-ef13334b04a3" class="bulleted-list"><li style="list-style-type:circle">使用压缩中间件compression，将其添加到站点，在根目录命令行安装<ul id="1f8694d5-ea46-8023-bbed-d2ca9705677f" class="bulleted-list"><li style="list-style-type:square">npm install compression</li></ul></li></ul><ul id="1f8694d5-ea46-8069-a82a-dfa47abc9201" class="bulleted-list"><li style="list-style-type:circle">打开./app.js，导入压缩裤，使用use方法，将压缩库添加到中间件链<ul id="1f8694d5-ea46-807a-9b98-ee7cd5764cd4" class="bulleted-list"><li style="list-style-type:square">这个会出现在想要压缩的任何路由之前。</li></ul><p id="1f8694d5-ea46-801a-99bd-c51b7e4e3170" class="">var catalogRouter = require(&#x27;./routes/catalog&#x27;); //Import routes for &quot;catalog&quot; area of site<br/>var compression = require(&#x27;compression&#x27;);<br/></p><p id="1f8694d5-ea46-807c-8ea9-d8a0bdb3cb3e" class="">// Create the Express application object<br/>var app = express();<br/></p><p id="1f8694d5-ea46-80eb-8209-de813c5c5763" class="">...</p><p id="1f8694d5-ea46-8081-ae09-d5b328fd846c" class="">app.use(compression()); //Compress all routes</p><p id="1f8694d5-ea46-8078-a76a-ed31b308f2a7" class="">app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));</p><p id="1f8694d5-ea46-801d-98a3-e68ab848fae9" class="">app.use(&#x27;/&#x27;, indexRouter);<br/>app.use(&#x27;/users&#x27;, usersRouter);<br/>app.use(&#x27;/catalog&#x27;, catalogRouter);  // Add catalog routes to middleware chain.<br/></p><p id="1f8694d5-ea46-8037-bf27-fd90e61a59a5" class="">...</p></li></ul></li></ul><ul id="1f8694d5-ea46-80ab-a3bd-ec5471da2647" class="bulleted-list"><li style="list-style-type:disc">对于生产中流量较大的网站，不会使用此中间件，会使用Nginx类似的反向代理</li></ul><p id="1f8694d5-ea46-8090-a963-d66e9373b082" class="">
</p><p id="1f8694d5-ea46-806e-9e31-d938eb2f0414" class="">【使用Helmet避免被常见漏洞侵袭】</p><ul id="1f8694d5-ea46-80d6-9775-f0286f856eca" class="bulleted-list"><li style="list-style-type:disc">Helmet是一个中间件包，可以通过设置适当的HTTP标头，保护应用，免受Web漏洞的影响<ul id="1f8694d5-ea46-80a4-83ec-ee2bcd646219" class="bulleted-list"><li style="list-style-type:circle">在项目根目录命令行安装<ul id="1f8694d5-ea46-8024-b3c5-e10e7fa29f57" class="bulleted-list"><li style="list-style-type:square">npm install helmet</li></ul></li></ul><ul id="1f8694d5-ea46-8003-919a-e0137a64efa8" class="bulleted-list"><li style="list-style-type:circle">app.js导入helmet库，使用use（）方法将模块添加到中间件链中<ul id="1f8694d5-ea46-8028-b5de-dcbf01212446" class="bulleted-list"><li style="list-style-type:square"></li></ul><p id="1f8694d5-ea46-800c-aa93-dedea3313c61" class="">var compression = require(&#x27;compression&#x27;);<br/>var helmet = require(&#x27;helmet&#x27;);<br/></p><p id="1f8694d5-ea46-8009-bf44-daeef502781d" class="">// Create the Express application object<br/>var app = express();<br/></p><p id="1f8694d5-ea46-802a-b088-c6a5139d952c" class="">app.use(helmet());<br/>...<br/></p></li></ul></li></ul><ul id="1f8694d5-ea46-80aa-8e04-c0fc1454c1cd" class="bulleted-list"><li style="list-style-type:disc">上述命令添加类对大多数站点有意义的可用标头子集，可用按照npm的说明，根据需要添加/禁用特定标头</li></ul><p id="1f8694d5-ea46-8087-aafb-e40377bcbbc5" class="">
</p><p id="1f8694d5-ea46-8096-9732-ec73760bec7a" class=""><strong><span style="border-bottom:0.05em solid">在Hero上部署图书馆项目：</span></strong></p><ul id="1f8694d5-ea46-8088-baca-e2b638d376b7" class="bulleted-list"><li style="list-style-type:disc">本节展示在Heroku PaaS cloud云安装图书馆项目</li></ul><p id="1f8694d5-ea46-805c-84bb-e2e909d4f9a5" class="">【为什么选择Herku】</p><p id="1f8694d5-ea46-80e7-b308-c42a0c281a84" class="">Heroku 是运行时间最长，且最受欢迎的基于云的 PaaS 服务之一。它最初只支持 Ruby 应用程序，但现在可用于托管来自许多编程环境的应用程序，包括 Node（以及 Express）！</p><p id="1f8694d5-ea46-80a4-a9df-d03d1d7423e5" class="">我们选择使用 Heroku 有以下几个原因：</p><ul id="1f8694d5-ea46-80c4-8ddf-fcbd33f39adf" class="bulleted-list"><li style="list-style-type:disc">Heroku 有一个<a href="https://www.heroku.com/pricing">免费套餐</a>（尽管有一些限制）。</li></ul><ul id="1f8694d5-ea46-80c9-8656-c92f8c228c25" class="bulleted-list"><li style="list-style-type:disc">作为 PaaS，Heroku 为我们提供了大量的 Web 基础架构。这使得入门更加容易，因为你不必担心服务器，负载平衡器，反向代理，崩溃时重新启动网站，或者 Heroku 为我们提供的任何其他 Web 基础结构。</li></ul><ul id="1f8694d5-ea46-8070-96ce-faa6ca6a333a" class="bulleted-list"><li style="list-style-type:disc">虽然它确实有一些限制，但这些不会影响这个特定的应用程序。例如：<ul id="1f8694d5-ea46-805a-ab9f-eb1bdd76efa9" class="bulleted-list"><li style="list-style-type:circle">Heroku 只提供短期存储，因此用户上传的文件无法安全地存储在 Heroku 本身。</li></ul><ul id="1f8694d5-ea46-80cc-8c75-c9755cdf1a4a" class="bulleted-list"><li style="list-style-type:circle">如果半小时内没有请求，免费套餐将使不活动的网络应用程序进入睡眠。然后，该网站可能需要几秒钟才能被唤醒。</li></ul><ul id="1f8694d5-ea46-80d2-aa4a-e803272f7855" class="bulleted-list"><li style="list-style-type:circle">免费套餐将你网站运行的时间，限制为每月一定的小时数（不包括网站“睡着”的时间）。这对于低使用/演示站点来说很好，但如果需要 100％的正常运行时间，则不适用。</li></ul><ul id="1f8694d5-ea46-808a-afce-c197f8006c00" class="bulleted-list"><li style="list-style-type:circle"><a href="https://devcenter.heroku.com/articles/limits">Heroku 官方文档</a>中列出的其他限制。</li></ul></li></ul><ul id="1f8694d5-ea46-80f5-9e25-f2bb7b6e63aa" class="bulleted-list"><li style="list-style-type:disc">大多数情况下它只是可以工作，如果你最终喜欢它，并希望升级，那么扩展你的应用程序非常容易。</li></ul><p id="1f8694d5-ea46-80a6-ad32-f00b8614c489" class="">虽然 Heroku 非常适合举办此演示，但它可能并不适合你的真实网站。Heroku 可以轻松设置和扩展，但代价是灵活性较低，而且一旦退 出免费套餐，可能会花费更多。</p><p id="1f8694d5-ea46-8047-8ced-c789694d9b36" class="">【Heroku如何工作】</p><p id="1f8694d5-ea46-80c4-81bf-ff253eaf5c74" class="">Heroku 在一个或多个“<a href="https://devcenter.heroku.com/articles/dynos">Dynos</a>”中运行网站，这些“Dynos”是独立的虚拟化 Unix 容器，提供运行应用程序所需的环境。Dynos 是完全隔离的，并且有一个短暂的文件系统（一个短暂的文件系统，每次 dyno 重新启动时都会清理/清空）。dynos 默认共享的唯一内容，是应用程序<a href="https://devcenter.heroku.com/articles/config-vars">配置变量</a>。Heroku 内部使用负载均衡器，将 Web 流量分配给所有“web”dynos。由于它们之间没有任何共享，Heroku 可以通过添加更多 dynos，来水平扩展应用程序（当然，你可能还需要扩展数据库，以接受其他连接）。</p><p id="1f8694d5-ea46-8055-a156-d34bbba52a74" class="">由于文件系统是短暂的，因此无法直接安装应用程序所需的服务（例如数据库，队列，缓存系统，存储，电子邮件服务等）。相反，Heroku Web 应用程序使用 Heroku 或第三方作为独立“附加组件”提供的支持服务。连接到 Web 应用程序后，可以通过环境变量，在 Web 应用程序中访问附加服务。</p><p id="1f8694d5-ea46-80fc-b5bd-c5c1b9f95b8a" class="">为了执行你的应用程序，Heroku 需要能够设置适当的环境和依赖关系，并了解它是如何启动的。对于 Node 应用程序，它所需的所有信息都是从<strong>package.json</strong>文件中获取的。</p><p id="1f8694d5-ea46-8092-a655-e49a33d4f1d2" class="">开发人员使用特殊的客户端应用程序/终端，与 Heroku 交互，这很像 Unix bash 脚本。这允许你上传存储在 git 存储库中的代码，检查正在运行的进程，查看日志，设置配置变量等等！</p><p id="1f8694d5-ea46-80a0-8a32-e59141c1ae5a" class="">为了让我们的应用程序在 Heroku 上工作，我们需要将我们的 Express Web 应用程序放入 git 存储库，并对 package.json 进行一些小的更改。完成后，我们可以设置 Heroku 帐户，获取 Heroku 客户端，并使用它来安装我们的网站。</p><p id="1f8694d5-ea46-802d-a943-d2970049ff10" class="">
</p><p id="1f8694d5-ea46-80b2-92c5-f767e1fd8efc" class="">【在Github上创建应用仓库】</p><p id="1f8694d5-ea46-8093-99df-dc075601216e" class="">Heroku 与 <strong>git</strong> 源代码版本控制系统紧密集成，使用它来上传/同步你对实时运行系统所做的任何更改。它通过添加一个名为 heroku 的新 Heroku“远程”存储库，来指向你在 Heroku 云上的源存储库。在开发期间，你使用 git 在“主”存储库 master 中存储更改。如果要部署站点，请将更改同步到 Heroku 存储库。<br/><br/></p><p id="1f8694d5-ea46-8076-a484-f0c85952233b" class="">有很多方法可以使用 git，但最简单的方法之一，是首先在<a href="https://github.com/">GitHub</a>上建立一个帐户，在那里创建存储库，然后在本地同步它：</p><ol type="1" id="1f8694d5-ea46-801e-bc68-d47836464d25" class="numbered-list" start="1"><li>访问 <a href="https://github.com/">https://github.com/</a> 并创建一个帐户。</li></ol><ol type="1" id="1f8694d5-ea46-8026-b541-df6b46eb5a64" class="numbered-list" start="2"><li>登录后，单击顶部工具栏中的 <strong>+</strong> 号链接，然后选择新建存储库<strong>New repository</strong>。</li></ol><ol type="1" id="1f8694d5-ea46-806d-b535-d8fe19a7acf0" class="numbered-list" start="3"><li>填写此表单上的所有字段。虽然这些不是强制性的，但强烈建议使用它们。<ul id="1f8694d5-ea46-80ba-9ba6-dec0cc462d2a" class="bulleted-list"><li style="list-style-type:disc">输入新的存储库名称（例如，express-locallibrary-tutorial）和描述（例如“以 Express（node）编写的本地图书馆网站”）。</li></ul><ul id="1f8694d5-ea46-8097-ade3-d39a5f94fce3" class="bulleted-list"><li style="list-style-type:disc">在 Add .gitignore 选择列表中选择 <strong>Node</strong>。</li></ul><ul id="1f8694d5-ea46-800d-b98e-cc4509885c77" class="bulleted-list"><li style="list-style-type:disc">在添加许可证 <em>Add license</em> 选择列表中，选择你偏好的许可证。</li></ul><ul id="1f8694d5-ea46-8019-a1cd-e1621290e259" class="bulleted-list"><li style="list-style-type:disc">点选 <strong>使用自述文件初始化此存储库</strong> “<strong>Initialize this repository with a README</strong>”</li></ul></li></ol><ol type="1" id="1f8694d5-ea46-8083-a695-efa129bb0955" class="numbered-list" start="4"><li>按 <strong>Create repository</strong>.</li></ol><ol type="1" id="1f8694d5-ea46-80cc-b67e-e90ebda6bb5f" class="numbered-list" start="5"><li>单击新仓库页面上的绿色“克隆或下载”按钮 &quot;<strong>Clone or download</strong>&quot;。</li></ol><ol type="1" id="1f8694d5-ea46-8032-8bf9-cea2e032ba58" class="numbered-list" start="6"><li>从显示的对话框的文本字段，复制 URL 值（它应该类似于：<code>https://github.com/&lt;your_git_user_id&gt;/express-locallibrary-tutorial.git</code>）。</li></ol><p id="1f8694d5-ea46-8075-aaa6-f319856c69f1" class="">现在创建了存储库（“repo”），我们将要在本地计算机上克隆它：</p><ol type="1" id="1f8694d5-ea46-8027-bed4-c4875ecf5add" class="numbered-list" start="1"><li>为你的本地计算机安装 git（你可以在<a href="https://git-scm.com/downloads">此处</a>找到不同平台的版本）。</li></ol><ol type="1" id="1f8694d5-ea46-8018-b1a2-ed850c27e9e0" class="numbered-list" start="2"><li>打开命令提示符/终端，并使用你在上面复制的 URL，克隆 clone 存储库：<p id="1f8694d5-ea46-807a-9c40-c6a21cb240e0" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-80cf-8442-c6e5af047d32" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">git clone https://github.com/&lt;your_git_user_id&gt;/express-locallibrary-tutorial.git
</code></pre><p id="1f8694d5-ea46-8095-8c06-d86b7cef04b8" class="">这将在当前时间点之后，创建存储库。</p></li></ol><ol type="1" id="1f8694d5-ea46-80e4-93aa-d17af5130399" class="numbered-list" start="3"><li>到新的仓库。<p id="1f8694d5-ea46-801d-a95b-eb89ff5c0e33" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-8042-8d29-cc5d10c8d612" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">cd express-locallibrary-tutorial
</code></pre></li></ol><p id="1f8694d5-ea46-802d-8e71-d57450c67bb1" class="">最后一步，是复制你的应用程序，然后使用 git，将文件添加到你的仓库：</p><ol type="1" id="1f8694d5-ea46-80a6-a94e-e391410655e7" class="numbered-list" start="1"><li>将 Express 应用程序，复制到此文件夹中（不包括**/node_modules**，其中包含你应根据需要，从 NPM 获取的依赖项文件）。</li></ol><ol type="1" id="1f8694d5-ea46-8055-a1d1-c2cb9102a2e0" class="numbered-list" start="2"><li>打开命令提示符/终端，并使用<code>add</code>命令，将所有文件添加到 git。<p id="1f8694d5-ea46-808b-886e-cc1a5272babd" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-80ee-9336-eb1f638ddfa6" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">git add -A
</code></pre></li></ol><ol type="1" id="1f8694d5-ea46-808f-affc-fb314867e181" class="numbered-list" start="3"><li>使用 status 命令，检查要添加的所有文件是否正确（你希望包含源文件，而不是二进制文件，临时文件等）。它应该看起来有点像下面的列表。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-8058-ac4d-dffa7cd232bd" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">&gt; git status
On branch master
Your branch is up-to-date with &#x27;origin/master&#x27;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        new file:   ...
</code></pre></li></ol><ol type="1" id="1f8694d5-ea46-802c-8b4f-fd5aa893d0ed" class="numbered-list" start="4"><li>如果你满意，请将文件提交到本地存储库：<p id="1f8694d5-ea46-80c1-9882-cb2eee71926b" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-8008-a7b9-efa5606ff282" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">git commit -m &quot;First version of application moved into github&quot;
</code></pre></li></ol><ol type="1" id="1f8694d5-ea46-8053-8148-c4af5790849f" class="numbered-list" start="5"><li>然后使用以下内容，将本地存储库同步到 Github 网站：<p id="1f8694d5-ea46-8098-9ff1-fcf32889df6d" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-8056-a32e-cd8322db7a71" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">git push origin master
</code></pre></li></ol><p id="1f8694d5-ea46-80c1-88fc-de07a19fef9d" class="">完成此操作后，你应该可以返回创建存储库的 Github 上的页面，刷新页面，并查看你的整个应用程序现已上传。使用此添加/提交/推送循环，你可以在文件更改时，继续更新存储库。</p><p id="1f8694d5-ea46-8009-a936-d4b409c2ba98" class="">
</p><p id="1f8694d5-ea46-80aa-babf-c254752934f9" class="">【更新Heroku应用程序】</p><ul id="1f8694d5-ea46-801e-9b6a-fcdac995d601" class="bulleted-list"><li style="list-style-type:disc">设置Node版本<ul id="1f8694d5-ea46-806a-865e-d2a29aa48830" class="bulleted-list"><li style="list-style-type:circle"><strong>package.json</strong>包含解决应用程序依赖项所需的所有内容，以及启动站点时，应启动的文件。Heroku 检测到此文件的存在，并将使用它来配置你的应用程序环境。</li></ul><ul id="1f8694d5-ea46-8025-8f3e-dc49569fb9ec" class="bulleted-list"><li style="list-style-type:circle">我们当前的<strong>package.json</strong>中，缺少的唯一有用信息，是 node 的版本。我们可以通过输入命令，找到我们用于开发的 node 版本：<blockquote id="1f8694d5-ea46-80ae-af98-dd04697fbc1d" class="">node --version<br/>v8.9.1<br/></blockquote></li></ul><ul id="1f8694d5-ea46-80b8-a402-f9c89041a8c0" class="bulleted-list"><li style="list-style-type:circle">打开package.json，将此信息添加为engines&gt;node部分<ul id="1f8694d5-ea46-80d9-af39-cac55db044c8" class="bulleted-list"><li style="list-style-type:square">{<br/>&quot;name&quot;: &quot;express-locallibrary-tutorial&quot;,<br/>&quot;version&quot;: &quot;0.0.0&quot;,<br/>&quot;engines&quot;: {<br/>&quot;node&quot;: &quot;8.9.1&quot;<br/>},<br/>&quot;private&quot;: true,<br/>...<br/></li></ul></li></ul></li></ul><p id="1f8694d5-ea46-800f-8515-d2fcf759b687" class="">【数据库配置】</p><ul id="1f8694d5-ea46-80dc-8a47-edf78cb4e686" class="bulleted-list"><li style="list-style-type:disc">到目前为止，在本教程中，我们使用了一个硬编码到<strong>app.js</strong>的单个数据库。通常我们希望，能够为生产和开发创建不同的数据库，接下来我们将修改 LocalLibrary 网站，以从 OS 环境获取数据库 URI（如果已定义），否则使用我们的开发数据库。<ul id="1f8694d5-ea46-8015-bc07-db6b053edca7" class="bulleted-list"><li style="list-style-type:circle">打开app.js，找到链接变量mongoDB的行代码替换为如下<ul id="1f8694d5-ea46-8015-a99a-cc620cfb16f3" class="bulleted-list"><li style="list-style-type:square">var mongoDB =<br/>process.env.MONGODB_URI ||<br/>&quot;mongodb://your_user_id:your_password@ds119748.mlab.com:19748/local_library&quot;;<br/></li></ul></li></ul></li></ul><p id="1f8694d5-ea46-806a-a3c6-ef75fa2047dc" class="">
</p><p id="1f8694d5-ea46-8031-9201-dbbba29d23fd" class="">【安装依赖并重新测试】</p><p id="1f8694d5-ea46-809c-adf2-ee2f1720393c" class="">npm install</p><p id="1f8694d5-ea46-807c-9728-d8ffae7612af" class="">【更改保存到Github】</p><p id="1f8694d5-ea46-80cd-ad46-c1bbbbfab0ac" class="">git add -A<br/>git commit -m &quot;Added files and changes required for deployment to heroku&quot;<br/>git push origin master<br/></p><p id="1f8694d5-ea46-8089-8401-c70949aef0d8" class="">
</p><p id="1f8694d5-ea46-80a1-87e7-f430b1c44646" class=""><strong><span style="border-bottom:0.05em solid">开始部署Heroku</span></strong></p><p id="1f8694d5-ea46-80a5-9168-fedad860c9f3" class="">【获取Heroku账户】</p><p id="1f8694d5-ea46-80a9-a355-fffdc84301e2" class="">要开始使用 Heroku，你首先需要创建一个帐户（如果你已经拥有一个帐户，并安装了 Heroku 客户端，请跳过创建并上传网站）：</p><ul id="1f8694d5-ea46-8057-9a15-ea427a7a0d5f" class="bulleted-list"><li style="list-style-type:disc">访问 <a href="https://www.heroku.com/">www.heroku.com</a> ，并单击免费注册按钮 <strong>SIGN UP FOR FREE</strong> 。</li></ul><ul id="1f8694d5-ea46-80c2-a1d5-f989f820e805" class="bulleted-list"><li style="list-style-type:disc">输入你的详细信息，然后按<strong>CREATE FREE ACCOUNT</strong>。系统会要求你，检查帐户中是否有注册电子邮件。</li></ul><ul id="1f8694d5-ea46-8083-bf2a-f53a2a7cb4e6" class="bulleted-list"><li style="list-style-type:disc">单击注册电子邮件中的帐户激活链接。你将在网络浏览器上收回你的帐户。</li></ul><ul id="1f8694d5-ea46-80fe-be64-e094f5e6f1e0" class="bulleted-list"><li style="list-style-type:disc">输入你的密码，然后单击 <strong>SET PASSWORD AND LOGIN</strong>.</li></ul><ul id="1f8694d5-ea46-8072-898a-c6daff984800" class="bulleted-list"><li style="list-style-type:disc">然后，你将登录并进入 Heroku 仪表板：<a href="https://dashboard.heroku.com/apps">https://dashboard.heroku.com/apps</a>.</li></ul><p id="1f8694d5-ea46-802e-bbcc-d195d1cba81c" class="">【安装Heroku客户端】</p><p id="1f8694d5-ea46-8084-893e-d714deb3adf7" class="">heroku help查看帮助说明</p><p id="1f8694d5-ea46-80f3-8d43-c9e7985420c8" class="">【创建并上传网站】</p><p id="1f8694d5-ea46-80fe-8ac4-cdd9e99762f1" class="">要创建应用程序，我们在存储库的根目录中，运行“create”命令。这将在我们的本地 git 环境中，创建一个名为 heroku 的 git remote（“指向远程存储库的指针”）。</p><p id="1f8694d5-ea46-80e9-bb86-e73af6bfefec" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-80b4-904b-d28c4be06cb8" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">heroku create
</code></pre><p id="1f8694d5-ea46-80fc-81eb-c27c29a4e60c" class=""><strong>备注：</strong> 如果你愿意，可以在“创建”create 之后指定远程存储库的命名。如果你不这样做，你会得到一个随机的名字。该名称用于默认 URL。</p><p id="1f8694d5-ea46-80c9-b9f0-ec80efb6cde2" class="">然后，我们可以将我们的应用程序，推送到 Heroku 存储库，如下所示。这将上传应用程序，获取所有依赖项，将其打包到 dyno 中，然后启动该站点。</p><p id="1f8694d5-ea46-80ff-9360-c96ea2fe26c6" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-8063-a086-e9e77420f215" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">git push heroku master
</code></pre><p id="1f8694d5-ea46-80e4-aa3d-cd15cf030531" class="">如果我们很幸运，该应用程序现在正在网站上“运行”。要打开浏览器并运行新网站，请使用以下命令：</p><p id="1f8694d5-ea46-8041-af1a-cf8592af7cac" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-805f-992c-c78bb59b8eba" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">heroku open
</code></pre><p id="1f8694d5-ea46-8020-8e36-ee899c4e82e6" class=""><strong>备注：</strong> 该站点将使用我们的开发数据库运行。创建一些书本和其他对象，并检查该网站是否按预期运行。在下一节中，我们将其设置为使用我们的新数据库。</p><p id="1f8694d5-ea46-80e8-a0d3-f04d26430832" class="">【设定配置变量】</p><p id="1f8694d5-ea46-8008-ba95-e87a59c9ff62" class="">我们需要将 NODE_ENV 设置为&#x27;production&#x27;，以便提高性能，并生成更简洁的错误消息。我们通过输入以下命令，来完成此操作：</p><p id="1f8694d5-ea46-800f-84b9-e40e5a22f92c" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-800d-9cfb-e9a988541581" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">&gt;heroku config:set NODE_ENV=&#x27;production&#x27;
Setting NODE_ENV and restarting limitless-tor-18923... done, v13
NODE_ENV: production
</code></pre><p id="1f8694d5-ea46-80f6-aeee-f5b1632c3d12" class="">我们还应该使用单独的数据库进行生产，在<strong>MONGODB_URI</strong>环境变量中，设置其 URI。你可以完全按照<a href="https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/mongoose#setting_up_the_mongodb_database">我们原来的方式</a>，设置新数据库和数据库用户，并获取其 URI。你可以如下图所示设置 URI（显然，要使用你自己的 URI！）</p><p id="1f8694d5-ea46-807a-8ded-f4f033991748" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-80d1-892f-f51aca181fda" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">&gt;heroku config:set MONGODB_URI=&#x27;mongodb://your_user:your_password@ds139278.mlab.com:39278/local_library_production&#x27;
Setting MONGODB_URI and restarting limitless-tor-18923... done, v13
MONGODB_URI: mongodb://your_user:your_password@ds139278.mlab.com:39278/local_library_production
</code></pre><p id="1f8694d5-ea46-8043-ba95-e3ad3ae49110" class="">你可以使用<code>heroku config</code>命令，随时检查配置变量 - 立即尝试：</p><p id="1f8694d5-ea46-80c8-a678-f4c31dcb156a" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-8070-930f-c5775111e3f1" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">&gt;heroku config
=== limitless-tor-18923 Config Vars
MONGODB_URI: mongodb://your_user:your_password@ds139278.mlab.com:39278/local_library_production
NODE_ENV:    production
</code></pre><p id="1f8694d5-ea46-80d3-8f22-dc1dea9b8d53" class="">Heroku 会在更新变量时，重新启动应用程序。如果你现在检查主页，它应该显示对象计数的零值，因为上面的更改，意味着我们现在正在使用新的（空）数据库。</p><p id="1f8694d5-ea46-8036-8935-cc903892b718" class="">【惯例附加组件】</p><p id="1f8694d5-ea46-8089-be5f-ef9d7b9ddd97" class="">Heroku 使用独立的附加组件，为应用程序提供支持服务 - 例如电子邮件或数据库服务。我们不在本网站中使用任何插件，但它们是使用 Heroku 的重要部分，因此你可能需要查看主题<a href="https://devcenter.heroku.com/articles/managing-add-ons">管理插件</a>（Heroku docs）<br/>【调试】<br/></p><p id="1f8694d5-ea46-80d2-a655-e33acee731ce" class="">Heroku 客户端提供了一些调试工具：</p><p id="1f8694d5-ea46-80c4-bc68-d1770c32d17e" class="">bashCopy to Clipboard</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1f8694d5-ea46-80ee-9272-c973f54f60b0" class="code"><code class="language-Shell" style="white-space:pre-wrap;word-break:break-all">heroku logs  # Show current logs
heroku logs --tail # Show current logs and keep updating with any new results
heroku ps   #Display dyno status</code></pre></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>